#!/usr/bin/perl -w

use strict;
use lib '~/Generic-Genome-Browser/lib';
#use Bio::Graphics::Browser;
#use Bio::Graphics::Browser::Render;
#use Bio::Graphics::Browser::Session;
use CGI qw(:standard);
#use CGI::Cookie;
#use CGI::Session;
use DBI;
use Digest::SHA qw(sha1);
use JSON;
use LWP::UserAgent;
#use LWPx::ParanoidAgent; (Better, but currently broken, try installing when a bug fix is released)
use Mail::Mailer;
use Net::OpenID::Consumer;
use Text::ParseWords 'quotewords';

#required installation of Crypt::SSLeay and libssl-dev
#If you dont have Math::BigInt, then Crypt::DH (installed with Net::OpenID::Consumer) will complain on every run.

our $VERSION = '$Id: gbrowse_login,v 1.1.2.7 2009-08-12 21:11:51 idavies Exp $';

umask 022;

my $url   = "http://$ENV{'HTTP_HOST'}/gb2/gbrowse/yeast_advanced";
my $smtp  = "mx.oicr.on.ca";

my $login = DBI->connect("DBI:mysql:gbrowse_login", 'idavies')
    or (print "Error: Could not open gbrowse login database."
    and die "Could not open gbrowse login database");

my %actions  = map {$_=>1}  param('action');
my %callback;

my $user     = param('user');
my $pass     = param('pass');
my $email    = param('email');
my $userid   = param('session');
my $remember = param('remember');

my $old      = param('old_val');
my $new      = param('new_val');
my $column   = param('column');

my $confirm  = param('confirm');
my $openid   = param('openid');
my $option   = param('option');

if($actions{list_openid}) {
    print header('application/json');
    do_list_openid($login,$user)  if $actions{list_openid};
    exit 0;
}

if($actions{confirm_openid}) {
    my $arg;
    my $print = -1;

    foreach(param('callback')) {
        $arg   = $_           if($print == -1);
        $callback{$arg} = $_  if($print ==  1);
        $print = $print * -1;
    }

    print header('application/json');
    do_confirm_openid($login,\%callback,$userid,$option);
    exit 0;
}

print header();

do_add_user          ($login,$smtp,$url,$user,$email,$pass,$userid)  if $actions{add_user};
do_validate          ($login,$user,$pass,$remember)                  if $actions{validate};
do_edit_details      ($login,$user,$column,$old,$new)                if $actions{edit_details};
do_email_info        ($login,$smtp,$email)                           if $actions{email_info};
do_confirm_account   ($login,$user,$confirm)                         if $actions{confirm_account};
do_delete_user       ($login,$user,$pass)                            if $actions{delete_user};

do_add_openid_user   ($login,$user,$openid,$userid,$remember)        if $actions{add_openid_user};
do_check_openid      ($openid,$userid,$option)                       if $actions{check_openid};
do_change_openid     ($login,$user,$pass,$openid,$option)            if $actions{change_openid};

exit 0;

sub create_key {
    my $val = shift;
    my $key;
    my @char=('a'..'z','A'..'Z','0'..'9','_');
    foreach (1..$val) {$key.=$char[rand @char];}
    return $key;
}

sub check_email {
    if(shift =~ /^(\w|\-|\_|\&|\+|\.)+\@((\w|\-|\_)+\.)+[a-zA-Z]{2,}$/) {
        return "true";
    } else {
        return "false";
    }
}

sub do_validate {
    my ($login,$user,$pass,$remember) = @_;
    my $update;

    if($user =~ /(\s|\\)/) {print "Usernames cannot contain any backslashes or whitespace characters.";return;}

    if($remember != 2) {
        $update = $login->prepare(
            "UPDATE users SET last_login=now(),remember=$remember WHERE username=? AND pass=? AND confirmed=1");
    } else {
        $update = $login->prepare(
            "UPDATE users SET last_login=now() WHERE username=? AND pass=? AND confirmed=1");
    }

    $pass = sha1($pass);
    $update->execute($user,$pass)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    my $rows = $update->rows;
    if($rows == 1) {
        if($remember != 2) {
            my $query = $login->prepare(
                "SELECT userid FROM users WHERE username=? AND pass=? AND confirmed=1");
            $query->execute($user,$pass)
                or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);
            print session=>$query->fetchrow_array;
        } else {
            print "Success";
        }
    } elsif($rows == 0) {
        print "Invalid username or password provided, please try again.";
    } else {
        print "Error: $rows rows returned, please consult your service host.";
    }
    return;
}

sub do_add_user {
    my ($login,$smtp,$url,$user,$email,$pass,$userid) = @_;
    if(check_email($email) eq "false") {print "Invalid e-mail address provided.";return;}
    if($user =~ /(\s|\\)/) {print "Usernames cannot contain any backslashes or whitespace characters.";return;}

    my $confirm = create_key('32');
    my $check = $login->prepare(
        "SELECT * FROM users WHERE userid=? OR username=? OR email=?");
    $check->execute($userid,$user,$email)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    if($check->rows == 0) {
        my ($mailer,$message) = do_send_confirmation($smtp,$url,$email,$confirm,$user,$pass);
    }

    my $query = $login->prepare(
        "INSERT INTO users VALUES (?,?,?,?,0,0,0,?,now(),now())"
    );

    $pass = sha1($pass);
    if($query->execute($userid,$user,$email,$pass,$confirm)) {
        print "Success";
    } else {
        if(DBI->errstr =~ m/for key 1$/) {
            print "Username already in use, please try another.";
        } elsif(DBI->errstr =~ m/for key 3$/) {
            print "E-mail address already in use, please provide another.";
        } elsif(DBI->errstr =~ m/for key 2$/) {
            print "Session Error";
        } else {
            print "Error: ",DBI->errstr,".";
        }
    }
    return;
}

sub do_send_confirmation {
    my ($smtp,$url,$email,$confirm,$user,$pass) = @_;
    my $link = $url."/?confirm=1;code=$confirm;id=logout";

    my $message  = "\nThank you for creating an account with GBrowse: ";
       $message .= "The Generic Genome Browser\n\nThe account information found below ";
       $message .= "is for your reference only. Please keep all account names and passwords ";
       $message .= "in a safe location and do not share your password with others.\n\n    ";
       $message .= "Username: $user\n    Password: $pass\n    E-mail:   $email\n\n";
       $message .= "To activate your account and complete the sign up process, please click ";
       $message .= "on the following link:\n    $link\n";
       $message .= get_footer();

    my $mailer  = Mail::Mailer->new('smtp', Server=>$smtp);
    $mailer->open({ From    => "noreply\@gbrowse.com",
                    To      => $email,
                    Subject => "GBrowse Account Activation",})
        or (print "Error: Can't open mailer: $!." and die "Can't open mailer: $!");

    print $mailer $message;
    $mailer->close()
        or (print "Error: Can't close mailer: $!." and die "Can't close mailer: $!");

    return ($mailer,$message);
}

sub do_confirm_account {
    my ($login,$user,$confirm) = @_;
    my $new_confirm = sha1($confirm);

    my $select = $login->prepare(
        "SELECT * FROM users WHERE cnfrm_code=? AND confirmed=0");
    $select->execute($confirm)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    my $rows = $select->rows;
    if($rows != 1) {print "Already Active"; return;}

    my $update = $login->prepare(
        "UPDATE users SET confirmed=1,cnfrm_code=? WHERE username=? AND cnfrm_code=? AND confirmed=0");
    $update->execute($new_confirm,$user,$confirm)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    $rows = $update->rows;
    if($rows == 1) {
        my $query = $login->prepare(
            "SELECT userid FROM users WHERE username=? AND cnfrm_code=? AND confirmed=1");
        $query->execute($user,$new_confirm)
            or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

        print $query->fetchrow_array();
    } elsif($rows == 0) {
        print "Error: Incorrect username provided, please check your spelling and try again.";
    } else {
        print "Error: $rows rows returned, please consult your service host.";
    }
    return;
}

sub do_edit_details {
    my ($login,$user,$column,$old,$new) = @_;

    if($column eq 'email') {
        if(check_email($new) eq "false") {
            print "New e-mail address is invalid, please try another.";return;}
    }

    $old = sha1($old) if($column eq 'pass');
    $new = sha1($new) if($column eq 'pass');

    my $querystring  = "UPDATE users       ";
       $querystring .= "   SET $column  = ?";
       $querystring .= " WHERE username = ?";
       $querystring .= "   AND $column  = ?";

    my $query = $login->prepare($querystring);
    unless($query->execute($new,$user,$old)) {
        if($column eq 'email') {
            print "New e-mail already in use, please try another.";
            die "Error: ",DBI->errstr;
        } else {
            print "Error: ",DBI->errstr,".";
            die "Error: ",DBI->errstr;
        }
    }

    if(DBI->errstr =~ m/for key 3$/) {
        print "New e-mail already in use, please try another.";}

    my $rows = $query->rows;
    if($rows == 1) {
        print "Success";
    } elsif($rows == 0) {
        print "Incorrect password provided, please check your spelling." if($column eq 'pass');
        print "Incorrect e-mail provided, please check your spelling."   if($column eq 'email');
    } else {
        if(($column eq 'email') and ($rows == -1)) {
            print "New e-mail already in use, please try another.";
        } else {
            print "Error: $rows rows returned, please consult your service host.";
        }
    }
    return;
}

sub do_email_info {
    my ($login,$smtp,$email) = @_;
    if(check_email($email) eq "false") {print "Invalid e-mail address provided.";return;}

    my ($user,$rows,$openid_ref) = do_retrieve_user($login,$email);
    my @openids = @$openid_ref;
    my $openid  = "";
    
    if($rows != 1) {print $user; return;}

    if(@openids) {foreach(@openids) {$openid .= "$_\n             ";}}
    else {$openid = "None\n";}

    my $pass = create_key('23');
    my $message  = "\nYour password has been reset to the one seen below. To fix this,";
       $message .= " select \"My Account\" from the log in menu and log in with the";
       $message .= " credentials found below.\n\n    Username: $user\n    ";
       $message .= "Password: $pass\n\n    OpenIDs: $openid";
       $message .= get_footer();

    my $mailer  = Mail::Mailer->new('smtp', Server=>$smtp);
    $mailer->open({ From    => "noreply\@gbrowse.com",
                    To      => $email,
                    Subject => "GBrowse Account Information",})
        or (print "Error: Can't open mailer: $!." and die "Can't open mailer: $!");

    my $secret = sha1($pass);
    my $query = $login->prepare(
        "UPDATE users SET pass=? WHERE username=? AND email=? AND confirmed=1");
    $query->execute($secret,$user,$email)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    print $mailer $message;
    $mailer->close()
        or (print "Failed to send message: $!."
        and die "Failed to send message: $!");

    print "Success";
    return;
}

sub do_retrieve_user {
    my ($login,$email) = @_;
    my @openids;

    my $select = $login->prepare(
        "SELECT username FROM users WHERE email=? AND confirmed=1");
    $select->execute($email)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    my $rows = $select->rows;
    if($rows == 1) {
        my $user  = $select->fetchrow_array();
        my $query = $login->prepare(
            "SELECT openid_url FROM openid_users WHERE username=?");
        $query->execute($user)
            or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

        while (my $openid = $query->fetchrow_array) {
            push (@openids,$openid);
        }

        return ($user,$rows,\@openids);
    } elsif($rows == 0) {
        return ("Sorry, an account does not exist for the e-mail provided.",$rows,\@openids);
    } else {
        return ("Error: $rows accounts match your e-mail, please consult your service host.",$rows,\@openids);
    }
}

sub get_footer {
    my $message  = "\n\nCourtesy of GBrowse Administration\n\n";
       $message .= "This message and any attachments may contain confidential and/or ";
       $message .= "privileged information for the sole use of the intended recipient. ";
       $message .= "Any review or distribution by anyone other than the person for whom ";
       $message .= "it was originally intended is strictly prohibited. If you have ";
       $message .= "received this message in error, please contact the sender and delete ";
       $message .= "all copies. Opinions, conclusions or other information contained in ";
       $message .= "this message may not be that of the organization.";

    return $message;
}

sub do_delete_user {
    my ($login,$user,$pass) = @_;
    my $unseqpass = $pass;
    $pass = sha1($pass);

    my ($sql,@bind);
    if($unseqpass eq "") {
        $sql  = "DELETE FROM users WHERE username=?";
        @bind = $user;
    } else {
        $sql  = "DELETE FROM users WHERE username=? AND pass=?";
        @bind = ($user,$pass);
    }

    my $delete = $login->prepare($sql);
    $delete->execute(@bind)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);
    my $rows = $delete->rows;
    if($rows != 1) {
        if($rows != 0) {
            print "Error: $rows rows returned, please consult your service host.";
        } else {
            print "Incorrect password provided, please check your spelling and try again.";
        }
        return;
    }

    my $query = $login->prepare(
        "DELETE FROM openid_users WHERE username=?");
    if($query->execute($user)) {
        print "Success";
    } else {
        print "Error: ",DBI->errstr,".";
    }
    return;
}


###################################################################
# OpenID functions
###################################################################

sub do_check_openid {
    my ($openid,$userid,$option) = @_;
    my $return_to  = "http://$ENV{'HTTP_HOST'}/gb2/gbrowse/yeast_advanced/";
       $return_to .= "?openid_confirm=1;page=$option;s=$userid;";
       $return_to .= "id=logout;" if $option ne "openid-add";
       #id=logout needed in case another user is already signed in

    my $csr = Net::OpenID::Consumer->new(
        ua              => LWP::UserAgent->new,
        args            => CGI->new,
        consumer_secret => "cQzMJPUqKOPIQ0E5iq4Y4vT7u58yMwfS",
        required_root   => "http://$ENV{'HTTP_HOST'}/"
    );

    my $claimed_identity = $csr->claimed_identity($openid)
        or print "The URL provided is not a valid OpenID, please check your spelling and try again."
        and die $csr->err;

    my $check_url = $claimed_identity->check_url(
        return_to  => $return_to,
        trust_root => "http://$ENV{'HTTP_HOST'}/",
        delayed_return => 1
    );

    print "Location: $check_url";
    return;
}

sub do_confirm_openid {
    my ($login,$callback,$userid,$option) = @_;
    my ($error,@results,$select,$user,$only);

    my $csr = Net::OpenID::Consumer->new(
        ua              => LWP::UserAgent->new,
        args            => $callback,
        consumer_secret => "cQzMJPUqKOPIQ0E5iq4Y4vT7u58yMwfS",
        required_root   => "http://$ENV{'HTTP_HOST'}/"
    );

    if($option eq "openid-add") {
        $select = $login->prepare("SELECT username,openid_only FROM users WHERE userid=?");
        $select->execute($userid)
            or ($error = DBI->errstr and push @results,{error=>"Error: $error."}
            and print JSON::to_json(\@results) and return);
        if($select->rows == 0) {
            push @results,{error=>"Error: Wrong session ID provided, please try again."};
            print JSON::to_json(\@results);
            return;
        }
        ($user,$only) = $select->fetchrow_array();
    }

    $csr->handle_server_response(
        not_openid => sub {
            push @results,{user=>$user,only=>$only,error=>"Invalid OpenID provided, please check your spelling."};
            print JSON::to_json(\@results);
        },
        setup_required => sub {
            push @results,{user=>$user,only=>$only,error=>"Error: Your OpenID requires setup."};
            print JSON::to_json(\@results);
            #my $setup_url = shift;
            # Redirect the user to $setup_url
        },
        cancelled => sub {
            push @results,{user=>$user,only=>$only,error=>"OpenID verification cancelled."};
            print JSON::to_json(\@results);
        },
        verified => sub {
            my $vident = shift;
            if($option eq "openid-add") {
                print JSON::to_json(do_add_openid_to_account($login,$userid,$user,$vident->url,$only));
            } else {
                print JSON::to_json(do_get_openid($login,$vident->url));
            }
        },
        error => sub {
            $error = $csr->err;
            push @results,{user=>$user,only=>$only,error=>"Error validating identity: $error."};
            print JSON::to_json(\@results);
        }
    );
    return;
}

sub do_get_openid {
    my ($login,$openid) = @_;
    my ($error,@results);

    my $select  = "SELECT A.username, A.userid,     ";
       $select .= "       A.remember, A.openid_only ";
       $select .= "  FROM users A, openid_users B   ";
       $select .= " WHERE A.userid     = B.userid   ";
       $select .= "   AND A.username   = B.username ";
       $select .= "   AND A.confirmed  = 1          ";
       $select .= "   AND B.openid_url = ?          ";

    my $query = $login->prepare($select);
    $query->execute($openid)
        or ($error = DBI->errstr and push @results,{error=>"Error: $error."}
        and return \@results);

    my $rows = $query->rows;
    if($rows != 1) {
        if($rows != 0) {
            $error  = "Error: $rows rows returned, please consult your service host.";
        } else {
            $error  = "The OpenID provided has not been used with GBrowse before. ";
            $error .= "Please create an account first before trying to edit your information.";
        }
        push @results,{error=>$error,openid=>$openid};
        return \@results;
    }

    my @info = $query->fetchrow_array;
    my $update = $login->prepare(
        "UPDATE users SET last_login=now() WHERE username=? AND userid=? AND confirmed=1");
    $update->execute($info[0],$info[1])
        or ($error = DBI->errstr and push @results,{error=>"Error: $error."}
        and return \@results);

    push @results,{user=>$info[0],session=>$info[1],remember=>$info[2],only=>$info[3]};
    return \@results;
}

sub do_change_openid {
    my ($login,$user,$pass,$openid,$option) = @_;
    my $unseqpass = $pass;
    $pass = sha1($pass);

    my ($sql,@bind);
    if($unseqpass eq "") {
        $sql  = "SELECT userid FROM users WHERE username=? AND openid_only=1";
        @bind = $user;
    } else {
        $sql  = "SELECT userid FROM users WHERE username=? AND pass=?";
        @bind = ($user,$pass);
    }

    my $select = $login->prepare($sql);
    $select->execute(@bind)
        or (print "Error: ",DBI->errstr,"." and die "Error: ",DBI->errstr);

    my $rows = $select->rows;
    if($rows != 1) {
        if($rows != 0) {
            print "Error: $rows rows returned, please consult your service host.";
        } else {
            print "Incorrect password provided, please check your spelling and try again.";
        }
        return;
    }

    if($option eq "add") {
        do_check_openid($openid,$select->fetchrow_array(),"openid-add");
        return;
    }

    my $query = $login->prepare(
        "DELETE FROM openid_users WHERE userid=? AND username=? AND openid_url=?");
    if($query->execute($select->fetchrow_array(),$user,$openid)) {
        print "Success";
    } else {
        if(DBI->errstr =~ m/for key 1$/) {
            print "The OpenID provided is already in use, please try another.";
        } else {
            print "Error: ",DBI->errstr,".";
        }
    }
    return;
}

sub do_add_openid_to_account {
    my ($login,$userid,$user,$openid,$only) = @_;
    my ($error,@results);

    my $query = $login->prepare("INSERT INTO openid_users VALUES (?,?,?)");
    if($query->execute($userid,$user,$openid)) {
        $error = "Success";
    } else {
        if(DBI->errstr =~ m/for key 1$/) {
            $error = "The OpenID provided is already in use, please try another.";
        } else {
            $error = "Error: ",DBI->errstr,".";
        }
    }
    push @results,{user=>$user,only=>$only,error=>$error};
    return \@results;
}

sub do_add_openid_user {
    my ($login,$user,$openid,$userid,$remember) = @_;
    if ($user =~ /(\s|\\)/) {print "Usernames cannot contain any backslashes or whitespace characters.";return;}
    my $confirm = sha1(create_key('32'));
    my $pass    = sha1(create_key('32'));
    my $email   = create_key('64');

    my $query = $login->prepare(
        "INSERT INTO users VALUES (?,?,?,?,?,1,1,?,now(),now())"
    );

    $pass = sha1($pass);
    if($query->execute($userid,$user,$email,$pass,$remember,$confirm)) {
        my $insert = $login->prepare("INSERT INTO openid_users VALUES (?,?,?)");
        if($insert->execute($userid,$user,$openid)) {
            print "Success";
        } else {
            if(DBI->errstr =~ m/for key 1$/) {
                print "The OpenID provided is already in use, please try another.";
            } else {
                print "Error: ",DBI->errstr,".";
            }
        }
    } else {
        if(DBI->errstr =~ m/for key 1$/ || DBI->errstr =~ m/for key 3$/) {
            #If the e-mail happens to match another, this will still be called.
            print "Username already in use, please try another.";
        } elsif(DBI->errstr =~ m/for key 2$/) {
            print "Session Error";
        } else {
            print "Error: ",DBI->errstr,".";
        }
    }
    return;
}

sub do_list_openid {
    my ($login,$user) = @_;
    my ($error,@openids);

    my $query = $login->prepare(
        "SELECT openid_url FROM openid_users WHERE username=?");
    $query->execute($user)
        or ($error = DBI->errstr and push @openids,{error=>"Error: $error."}
        and print JSON::to_json(\@openids) and die "Error: ",DBI->errstr);

    if($query->rows == 0) {
        push @openids,{error=>"There are no OpenIDs currently associated with this account."}
    }

    while (my $openid = $query->fetchrow_array) {
        push @openids,{name=>$openid};
    }
    my @results = sort {$a->{name} cmp $b->{name}} @openids;
    print JSON::to_json(\@results);
}

__END__



