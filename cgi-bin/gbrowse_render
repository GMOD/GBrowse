#!/usr/bin/perl

use strict;
use Data::Dumper;
use CGI qw(header param escape unescape);
use Storable qw(freeze thaw retrieve);
#use LWP::Parallel;
#use LWP::Parallel::UserAgent;

use lib '/Users/mokada/development/gsoc/head/Generic-Genome-Browser/libnew',
'/Users/mokada/development/gsoc/head/Generic-Genome-Browser/lib';
#use Bio::Graphics::Browser::Render;
#use Bio::Graphics::Browser::PluginSet;
use Bio::Graphics::Browser::RenderTracks;
use Bio::Graphics::Browser::DataSource;

use Bio::Graphics::Browser::Shellwords;



print header();

my %args;
foreach my $key (param()) {
 my $value = thaw(param($key));
  $args{$key} = $value;
}

#extract arguments
my $tracks	= $args{'tracks'};
my $settings	= $args{'settings'};
my $datasource	= $args{'datasource'};
my $language	= $args{'language'};
#my $session	= $args{'session'};
#my $paramargs	= $args{'paramargs'};

print fatal_error("Missing arguments") unless $tracks && $settings && $datasource && $language;

my @result_tracks;

# extract db
my $db = init_database($datasource, $settings);

# extract segments
my $segments = $db->segment(-name	=> $settings->{'ref'},
			    -start	=> $settings->{'start'},
			    -stop	=> $settings->{'stop'});

# generate the panels
my $renderer = Bio::Graphics::Browser::RenderTracks->new(-segment  => $segments,
							  -source   => $datasource,
							  -settings => $settings);

my $panels = $renderer->generate_panels(-db      => $db,
						     -tracks  => $tracks);

# create the gd object and maps
for my $track (keys %$panels) {
  my $panel = $panels->{$track};
  my $image_map = $track eq '__scale__' ? $renderer->make_centering_map($panel)
  	: $renderer->make_map($panel, $track, $language);
  
  push @result_tracks, [$track, $panel->gd, $image_map];
}


#for debugging, return still image and map
#my $var = retrieve ('/Users/mokada/development/testing/temp/triplets.dat');
#my ($track_name, $gd, $image_map) = @$var;
#push @result_tracks, [$track_name, $gd, $image_map];




#print freeze([[$track_name, $gd, $image_map]]);
print freeze(\@result_tracks);

exit;


###############################################################################################
########## SUB ROUTINES #######################################################################
###############################################################################################

sub init_database {
  my $datasource = shift;
  my $settings = shift;
  my $db  = $datasource->open_database();

  # I don't know what this is for, but it was there in gbrowse and looks like an important hack.
  eval {$db->biosql->version($settings->{version})};

  $db;
}

sub init_plugins {
  my $datasource = shift;
  my $settings = shift;
  my $language = shift;
  my $db = shift;
  my $session = shift;
  
  my @plugin_path = shellwords($datasource->globals->plugin_path);
  
  my $plugins = Bio::Graphics::Browser::PluginSet->new($datasource,$settings, $language, @plugin_path);
  fatal_error("Could not initialize plugins") unless $plugins;
  $plugins->configure($db, $settings, $language, $session);
  
  $plugins;
}

sub fatal_error {
  print shift;
  print "<br>\n";
  print_usage();
  exit;
}

sub print_usage {
  
  print <<'END';
<html>
<h1>gbrowse_render - Script to generate genome images and map objects for the Generic Genome Browser</h1>

<h2>SYNOPSIS</h2>

<pre>
  
  
  
  use strict;
  use Storable qw(freeze thaw);
  use LWP::Parallel::UserAgent;
  use HTTP::Request::Common qw(POST);
  
  use Bio::Graphics::Browser;
  use Bio::Graphics::Browser::Render;
  use Bio::Graphics::Browser::Render::HTML;
  use Bio::Graphics::Browser::DataSource;
  
  my $conf_dir = '/etc/httpd/gbrowse.conf/GBrowse.conf';
  my $url = 'http://localhost/cgi-bin.dev/gbrowse_render.pl';
  
  my $globals = Bio::Graphics::Browser->new($conf_dir);
  my $render = Bio::Graphics::Browser::Render::HTML->new($globals);
  
  
  #    ...     SET UP $render object
  
  
  my $session = $globals->session();
  $globals->update_data_source($session);
  
  my @tracks = ('ORFs','Genes','tRNAs');
  my $dsn = $globals->create_data_source($session->source);
  my $lang = $render->language->{lang};
  my $settings = $session->page_settings;



  #create LWP, a class for parallel User Agents
  my $ua = LWP::Parallel::UserAgent->new;
  $ua->in_order(0);
  $ua->nonblock(1);
  
  my $request = POST ($url,
    		       [tracks     => Storable::freeze(\@tracks),
			settings   => Storable::freeze($settings),
			datasource => Storable::freeze($dsn),
			language   => Storable::freeze($lang)
    ]);
  my $error = $ua->register($request);
  
  if ($error) { warn "Could not send request to $url: ",$error->as_string }

  my $results = $ua->wait(20);

  my %track_results;
  foreach (keys %$results) {
    my $response = $results->{$_}->response;
    unless ($response->is_success) {
      warn $results->request->uri,"; fetch failed: ",$response->status_line;
      next;
    }
    my $content = $response->content;

    my $tracks = Storable::thaw($content);
    for my $track_tuple (@$tracks) {
      my ($track_name,$gd,$imagemap) = @$track_tuple;
      $track_results{$track_name}{gd} = $gd;
      $track_results{$track_name}{map} = $imagemap;
    }
  }
  
</pre>


<h2>DESCRIPTION</h2>

<p>
This script is a small component of the Generic Genome Browser which will
extract the necessary data to create the images and their corresponding maps
remotely.  A central Genome Browser will call on multiple copies of this script
on remote servers to allow parallel processing of data.  Parameters and data
objects are passed in a specific manner as illustrated in the above synopsis.
When the remote scripts have completed running, it will return the GD and map
objects to the central caller.<p>

<h2>CGI arguments</h2>

<p>

The script recognizes the following CGI arguments, which must be passed as a
single POST argument wrapped around a hash containing the following
argument=value pairs.

<table border="1">
<tr><th>Argument</th><th>Description</th></tr>
<tr> <td>tracks</td>      <td>List of tracks to be rendered</td></tr>
<tr> <td>settings</td>    <td>Page settings of the portion of the genome to view</td></tr>
<tr> <td>datasource</td>  <td>Bio::Graphics::Browser::DataSource object containing configurations</td></tr>
<tr> <td>language</td>    <td>List of languages the current browser is being run in</td></tr>
</table>


<p>The arguments are explained in more detail here</p>

<dl>
  <dt><b>tracks</b>
  <dd>An array of the track names to be rendered by gbrowse_render.<br>
      Note that plugins must be rendered locally and cannot rely on this script
      to render the images.
      <p>
      
  <dt><b>settings</b> (also known as page settings, or state)
  <dd>This data structure contains the current page settings of the browser.
      It lives in the Bio::Graphics::Browser::Render object.
      <p>
      
  <dt><b>datasource</b>
  <dd>A Bio::Graphics::Browser::DataSource object containing the configurations
      set by the configuration files.
      <p>
      
  <dt><b>language</b>
  <dd>A list of languages the current browser is being run in.  It is a subset
      of the Bio::Graphics::Browser::Render object.  An example would be the
      array:
      <p>
      <pre>
      [
         'en-us',
         'en',
         'en',
         'posix'
      ],

</dl>


<h2>OBJECTS RETURNED</h2>

<p>

This script will return a hash containing the GD and map objects organized by
their track name.  This is done by printing out the frozen results (via
Storables) and thus must be thawed by the central browser script.
<p>
Using the UserAgent object, the data is to be extracted by th econtent method:

<pre>
    my $ua;   #set up UserAgent object
    my $results = $ua->wait(20);
    
    my $content = $response->content;
    my $tracks = Storable::thaw($content);
    for my $track_tuple (@$tracks) {
      my ($track_name,$gd,$imagemap) = @$track_tuple;
      
      #store or use the $gd, $imagemap objects for the track $track_name
      
    }

</pre>

<h2>NOTES</h2>

<p> Plugins are only to be rendered locally and thus are not to be used by this script.</p>

<h2>AUTHOR</h2>

<p>Lincoln Stein <a href="mailto:lstein@cshl.org">lstein@cshl.org</a>
<p> with acknowledgements to H. Mark Okada
<p>
Copyright (c) 2002-2004 Cold Spring Harbor Laboratory
<p>
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
<p>

For additional help, see <a href="http://www.gmod.org">The GMOD Project</a> pages.

END
;
}


