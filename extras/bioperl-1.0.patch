diff -Naur bioperl-1.0/Bio/Align/AlignI.pm bioperl-1.01/Bio/Align/AlignI.pm
--- bioperl-1.0/Bio/Align/AlignI.pm	Fri Mar  8 15:30:06 2002
+++ bioperl-1.01/Bio/Align/AlignI.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Align::AlignI
 #
@@ -16,9 +16,27 @@
 
 =head1 SYNOPSIS
 
-# get a Bio::Align::AlignI somehow - typically using Bio::AlignIO system
+  # get a Bio::Align::AlignI somehow - typically using Bio::AlignIO system
 
-    print "aln is ", $aln->length, "\n";
+  # some descriptors
+  print $aln->length, "\n";
+  print $aln->no_residues, "\n";
+  print $aln->is_flush, "\n";
+  print $aln->no_sequences, "\n";
+  print $aln->percentage_identity, "\n";
+  print $aln->consensus_string(50), "\n";
+
+  # find the position in the alignment for a sequence location
+  $pos = $aln->column_from_residue_number('1433_LYCES', 14); # = 6;
+
+  # extract sequences and check values for the alignment column $pos
+  foreach $seq ($aln->each_seq) {
+      $res = $seq->subseq($pos, $pos);
+      $count{$res}++;
+  }
+  foreach $res (keys %count) {
+      printf "Res: %s  Count: %2d\n", $res, $count{$res};
+  }
 
 
 =head1 DESCRIPTION
@@ -629,13 +647,14 @@
     $self->throw_not_implemented();
 }
 
+
 =head2 percentage_identity
 
  Title   : percentage_identity
  Usage   : $id = $align->percentage_identity
- Function: The function uses a fast method to calculate the average 
-           percentage identity of the alignment
- Returns : The average percentage identity of the alignment
+ Function: The function calculates the percentage identity of the alignment
+ Returns : The percentage identity of the alignment (as defined by the 
+						     implementation)
  Argument: None
 
 =cut
@@ -643,6 +662,39 @@
 sub percentage_identity{
     my ($self) = @_;
     $self->throw_not_implemeneted();
+}
+
+=head2 overall_percentage_identity
+
+ Title   : percentage_identity
+ Usage   : $id = $align->percentage_identity
+ Function: The function calculates the percentage identity of 
+           the conserved columns
+ Returns : The percentage identity of the conserved columns
+ Args    : None
+
+=cut
+
+sub overall_percentage_identity{
+    my ($self) = @_;
+    $self->throw_not_implemented();
+}
+
+
+=head2 average_percentage_identity
+
+ Title   : average_percentage_identity
+ Usage   : $id = $align->average_percentage_identity
+ Function: The function uses a fast method to calculate the average 
+           percentage identity of the alignment
+ Returns : The average percentage identity of the alignment
+ Args    : None
+
+=cut
+
+sub average_percentage_identity{
+    my ($self) = @_;
+    $self->throw_not_implemented();
 }
 
 =head1 Alignment positions
diff -Naur bioperl-1.0/Bio/AlignIO/bl2seq.pm bioperl-1.01/Bio/AlignIO/bl2seq.pm
--- bioperl-1.0/Bio/AlignIO/bl2seq.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/bl2seq.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::bl2seq
 
@@ -25,7 +25,7 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class, as in:
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class, as in:
 
     use Bio::AlignIO;
 
@@ -35,7 +35,7 @@
 
 =head1 DESCRIPTION
 
-This object can create Bio::SimpleAlign sequence alignment objects (of
+This object can create L<Bio::SimpleAlign> sequence alignment objects (of
 2 sequences) from bl2seq BLAST reports.
 
 A nice feature of this module is that- in combination with
@@ -106,7 +106,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : SimpleAlign object - returns 0 on end of file
+ Returns : L<Bio::Align::AlignI> object - returns 0 on end of file
 	    or on error
  Args    : NONE
 
@@ -162,7 +162,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in bl2seq format
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/clustalw.pm bioperl-1.01/Bio/AlignIO/clustalw.pm
--- bioperl-1.0/Bio/AlignIO/clustalw.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/clustalw.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::clustalw
 
@@ -107,7 +107,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream
- Returns : Bio::Align::AlignI object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -168,7 +168,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the clustalw-format object (.aln) into the stream
  Returns : 1 for success and 0 for error
- Args    : Bio::Align::AlignI object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/emboss.pm bioperl-1.01/Bio/AlignIO/emboss.pm
--- bioperl-1.0/Bio/AlignIO/emboss.pm	Sat Mar 16 20:27:20 2002
+++ bioperl-1.01/Bio/AlignIO/emboss.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::emboss
 #
@@ -96,7 +96,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : Bio::SimpleAlign object - returns 0 on end of file
+ Returns : L<Bio::Align::AlignI> object - returns 0 on end of file
 	    or on error
  Args    : NONE
 
@@ -229,7 +229,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in emboss format
  Returns : 1 for success and 0 for error
- Args    : Bio::Align::AlignI object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/fasta.pm bioperl-1.01/Bio/AlignIO/fasta.pm
--- bioperl-1.0/Bio/AlignIO/fasta.pm	Sat Jan 26 10:58:01 2002
+++ bioperl-1.01/Bio/AlignIO/fasta.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::fasta
 
@@ -21,11 +21,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from fasta flat
+This object can transform L<Bio::SimpleAlign> objects to and from fasta flat
 file databases.
 
 =head1 FEEDBACK
@@ -68,7 +68,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : Bio::Align::AlignI object - returns 0 on end of file
+ Returns : L<Bio::Align::AlignI> object - returns 0 on end of file
 	    or on error
  Args    : NONE
 
@@ -157,7 +157,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in fasta format
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/mase.pm bioperl-1.01/Bio/AlignIO/mase.pm
--- bioperl-1.0/Bio/AlignIO/mase.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/mase.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::mase
 
@@ -21,11 +21,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from mase flat
+This object can transform L<Bio::Align::AlignI> objects to and from mase flat
 file databases.
 
 =head1 FEEDBACK
@@ -67,7 +67,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -141,7 +141,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in mase format  ###Not yet implemented!###
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/mega.pm bioperl-1.01/Bio/AlignIO/mega.pm
--- bioperl-1.0/Bio/AlignIO/mega.pm	Sun Feb 17 21:07:43 2002
+++ bioperl-1.01/Bio/AlignIO/mega.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::mega
 #
@@ -100,7 +100,7 @@
              (anything after '!TITLE: ') .  
            - Reads in the format parameters datatype 
 
- Returns : Bio::SimpleAlign object - returns 0 on end of file
+ Returns : L<Bio::Align::AlignI> object - returns 0 on end of file
 	    or on error
  Args    : NONE
 
@@ -170,12 +170,10 @@
 =head2 write_aln
 
  Title   : write_aln
- Usage   : my 
- Function:
- Example :
- Returns : 
- Args    :
-
+ Usage   : $stream->write_aln(@aln)
+ Function: writes the $aln object into the stream in MEGA format
+ Returns : 1 for success and 0 for error
+ Args    : L<Bio::Align::AlignI> object
 
 =cut
 
diff -Naur bioperl-1.0/Bio/AlignIO/msf.pm bioperl-1.01/Bio/AlignIO/msf.pm
--- bioperl-1.0/Bio/AlignIO/msf.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/msf.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::msf
 
@@ -21,11 +21,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from msf flat
+This object can transform L<Bio::Align::AlignI> objects to and from msf flat
 file databases.
 
 =head1 FEEDBACK
@@ -75,7 +75,7 @@
           It reads all non whitespace characters in the alignment
           area. For MSFs with weird gaps (eg ~~~) map them by using
           $al->map_chars('~','-')
- Returns : Bio::Align::AlignI object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -158,7 +158,7 @@
  Function: writes the $aln object into the stream in MSF format
            Sequence type of the alignment is determined by the first sequence.
  Returns : 1 for success and 0 for error
- Args    : Bio::Align::AlignI object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/nexus.pm bioperl-1.01/Bio/AlignIO/nexus.pm
--- bioperl-1.0/Bio/AlignIO/nexus.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/nexus.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::nexus
 #
@@ -11,11 +11,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from NEXUS
+This object can transform L<Bio::Align::AlignI> objects to and from NEXUS
 data blocks. See method documentation for supported NEXUS features.
 
 =head1 ACKNOWLEDGEMENTS
@@ -79,7 +79,7 @@
            - Sequence names of type 'Homo sapiens' and 
              Homo_sapiens are treated identically.
 
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : 
 
 =cut
@@ -251,7 +251,7 @@
            SimpleAlign methods match_char, missing_char and gap_char must be set 
            if you want to see them in the output.
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 =cut
 
diff -Naur bioperl-1.0/Bio/AlignIO/pfam.pm bioperl-1.01/Bio/AlignIO/pfam.pm
--- bioperl-1.0/Bio/AlignIO/pfam.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/pfam.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::pfam
 
@@ -21,7 +21,7 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
@@ -58,7 +58,7 @@
 use strict;
 
 use Bio::AlignIO;
-
+use Bio::SimpleAlign;
 @ISA = qw(Bio::AlignIO);
 
 =head2 next_aln
@@ -66,7 +66,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -124,7 +124,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
@@ -132,7 +132,10 @@
 sub write_aln {
    my ($self,@aln) = @_;
    foreach my $aln (@aln) {
-
+       if( ! $aln || ! $aln->isa('Bio::Align::AlignI')  ) { 
+	   $self->warn("Must provide a Bio::Align::AlignI object when calling write_aln");
+	   next;
+       }
       my ($namestr,$seq,$add);
       my ($maxn);
       $maxn = $aln->maxdisplayname_length();
diff -Naur bioperl-1.0/Bio/AlignIO/phylip.pm bioperl-1.01/Bio/AlignIO/phylip.pm
--- bioperl-1.0/Bio/AlignIO/phylip.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/phylip.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::phylip
 #
@@ -15,8 +15,11 @@
 
     use Bio::AlignIO;
     use Bio::SimpleAlign;
+	#you can set the name length to something other than the default 10
+	#if you use a version of phylip (hacked) that accepts ids > 10
     my $phylipstream = new Bio::AlignIO(-format => 'phylip',
-					-fh   => \*STDOUT);
+					-fh   => \*STDOUT,
+					-idlength=>30);
     # convert data from one format to another
     my $gcgstream     =  new Bio::AlignIO(-format => 'msf',
 					  -file   => 't/data/cysprot1a.msf');    
@@ -30,7 +33,8 @@
     # can also initialize the object like this
     $phylipstream = new Bio::AlignIO(-interleaved => 0,
 				     -format => 'phylip',
-				     -fh   => \*STDOUT);
+				     -fh   => \*STDOUT,
+					 -idlength=>10);
     $gcgstream     =  new Bio::AlignIO(-format => 'msf',
 				       -file   => 't/data/cysprot1a.msf');    
 
@@ -76,6 +80,7 @@
 use vars qw(@ISA);
 use strict;
 
+use Bio::SimpleAlign;
 use Bio::AlignIO;
 
 @ISA = qw(Bio::AlignIO);
@@ -85,9 +90,12 @@
   my($self,@args) = @_;
   $self->SUPER::_initialize(@args);
 
-  my ($interleave) = $self->_rearrange([qw(INTERLEAVED)],@args);
+  my ($interleave,$idlength) = $self->_rearrange([qw(INTERLEAVED IDLENGTH)],@args);
   if( ! defined $interleave ) { $interleave = 1 }  # this is the default
   $self->interleaved(1) if( $interleave);
+  if (!defined $idlength) {$idlength = 10}
+  $self->idlength($idlength);
+
 
   1;
 }
@@ -99,7 +107,7 @@
  Function: returns the next alignment in the stream.
            Throws an exception if trying to read in PHYLIP
            sequential format.
- Returns : SimpleAlign object
+ Returns : L<Bio::SimpleAlign> object
  Args    : 
 
 =cut
@@ -185,7 +193,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in MSF format
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 =cut
 
@@ -194,20 +202,25 @@
     my $count = 0;
     my $wrapped = 0;
     my $maxname;
-    my ($length,$date,$name,$seq,$miss,$pad,%hash,@arr,$tempcount,$index);
+    my ($length,$date,$name,$seq,$miss,$pad,%hash,@arr,$tempcount,$index,$idlength);
     
     foreach my $aln (@aln) {
+	if( ! $aln || ! $aln->isa('Bio::Align::AlignI')  ) { 
+	    $self->warn("Must provide a Bio::Align::AlignI object when calling write_aln");
+	    next;
+	}
 	$self->throw("All sequences in the alignment must be the same length") 
 	    unless $aln->is_flush(1) ;
 
 	$aln->set_displayname_flat(); # plain
 	$length  = $aln->length();
 	$self->_print (sprintf(" %s %s\n", $aln->no_sequences, $aln->length));
-	
+
+	$idlength = $self->idlength();	
 	foreach $seq ( $aln->each_seq() ) {
 	    $name = $aln->displayname($seq->get_nse);
-	    $name = substr($name, 0, 10) if length($name) > 10;
-	    $name = sprintf("%-10s",$name);
+	    $name = substr($name, 0, $idlength) if length($name) > $idlength;
+	    $name = sprintf("%-".$idlength."s",$name);
 	    $name .= '   ' if( $self->interleaved());
 	    $hash{$name} = $seq->seq();
 	    push(@arr,$name);
@@ -220,7 +233,7 @@
 		foreach $name ( @arr ) {
 		    my $dispname = $name;
 		    $dispname = '' if $wrapped;
-		    $self->_print (sprintf("%13s  ",$dispname));
+		    $self->_print (sprintf("%".($idlength+3)."s",$dispname));
 		    $tempcount = $count;
 		    $index = 0;
 		    while( ($tempcount + 10 < $length) && ($index < 5)  ) {
@@ -271,4 +284,22 @@
    return $previous;
 }
 
+=head2 idlength
+
+ Title   : idlength
+ Usage   : my $idlength = $obj->interleaved
+ Function: Get/Set value of id length 
+ Returns : string 
+ Args    : string 
+
+
+=cut
+
+sub idlength {
+	my($self,$value) = @_;
+	if (defined $value){
+	   $self->{'_idlength'} = $value;
+	}
+	return $self->{'_idlength'};
+}
 1;
diff -Naur bioperl-1.0/Bio/AlignIO/prodom.pm bioperl-1.01/Bio/AlignIO/prodom.pm
--- bioperl-1.0/Bio/AlignIO/prodom.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/prodom.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::prodom
 
@@ -21,11 +21,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from prodom flat
+This object can transform L<Bio::Align::AlignI> objects to and from prodom flat
 file databases.
 
 =head1 FEEDBACK
@@ -66,7 +66,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -123,7 +123,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in prodom format  ###Not yet implemented!###
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/psi.pm bioperl-1.01/Bio/AlignIO/psi.pm
--- bioperl-1.0/Bio/AlignIO/psi.pm	Thu Mar 14 13:06:35 2002
+++ bioperl-1.01/Bio/AlignIO/psi.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::psi
 #
@@ -92,7 +92,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream
- Returns : Bio::Align::AlignI object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -127,7 +127,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the NCBI psi-format object (.aln) into the stream
  Returns : 1 for success and 0 for error
- Args    : Bio::Align::AlignI object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/selex.pm bioperl-1.01/Bio/AlignIO/selex.pm
--- bioperl-1.0/Bio/AlignIO/selex.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/selex.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::selex
 
@@ -21,11 +21,11 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from selex flat
+This object can transform L<Bio::Align::AlignI> objects to and from selex flat
 file databases.
 
 =head1 FEEDBACK
@@ -68,7 +68,7 @@
           It reads all non whitespace characters in the alignment
           area. For selexs with weird gaps (eg ~~~) map them by using
           $al->map_chars('~','-')
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -144,7 +144,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in selex format
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO/stockholm.pm bioperl-1.01/Bio/AlignIO/stockholm.pm
--- bioperl-1.0/Bio/AlignIO/stockholm.pm	Wed Feb 13 10:32:54 2002
+++ bioperl-1.01/Bio/AlignIO/stockholm.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO::stockholm
 
@@ -21,12 +21,12 @@
 
 =head1 SYNOPSIS
 
-Do not use this module directly.  Use it via the Bio::AlignIO class.
+Do not use this module directly.  Use it via the L<Bio::AlignIO> class.
 
 =head1 DESCRIPTION
 
-This object can transform Bio::SimpleAlign objects to and from stockholm flat
-file databases.
+This object can transform L<Bio::Align::AlignI> objects to and from
+stockholm flat file databases.
 
 =head1 FEEDBACK
 
@@ -66,7 +66,7 @@
  Title   : next_aln
  Usage   : $aln = $stream->next_aln()
  Function: returns the next alignment in the stream.
- Returns : SimpleAlign object
+ Returns : L<Bio::Align::AlignI> object
  Args    : NONE
 
 =cut
@@ -158,7 +158,7 @@
  Usage   : $stream->write_aln(@aln)
  Function: writes the $aln object into the stream in stockholm format  ###Not yet implemented!###
  Returns : 1 for success and 0 for error
- Args    : Bio::SimpleAlign object
+ Args    : L<Bio::Align::AlignI> object
 
 
 =cut
diff -Naur bioperl-1.0/Bio/AlignIO.pm bioperl-1.01/Bio/AlignIO.pm
--- bioperl-1.0/Bio/AlignIO.pm	Mon Feb 18 12:17:23 2002
+++ bioperl-1.01/Bio/AlignIO.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::AlignIO
 #
@@ -175,7 +175,7 @@
    pfam        Pfam sequence alignment format
    phylip      Felsenstein's PHYLIP format
 
-Currently only those formats which were implemented in SimpleAlign.pm
+Currently only those formats which were implemented in L<Bio::SimpleAlign>
 have been incorporated in AlignIO.pm.  Specifically, mase, stockholm
 and prodom have only been implemented for input.
 
diff -Naur bioperl-1.0/Bio/Biblio/BiblioBase.pm bioperl-1.01/Bio/Biblio/BiblioBase.pm
--- bioperl-1.0/Bio/Biblio/BiblioBase.pm	Mon Mar 11 11:02:34 2002
+++ bioperl-1.01/Bio/Biblio/BiblioBase.pm	Sat May  4 16:28:09 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Biblio::BiblioBase
 #
@@ -92,21 +92,10 @@
 
 @ISA = qw(Bio::Root::Root);
 
-sub _abstractDeath {
-  my $self = shift;
-  my $package = ref $self;
-  my $caller = (caller(1))[3];
-
-  $self->throw ("Abstract method '$caller' should not been called.\n" .
-		"Not your fault - author of $package should be blamed!");
-
-}
-
 # these methods should not be called here;
 # they should be implemented by a subclass
-sub _accessible { shift->_abstractDeath; }
-sub _attr_type { shift->_abstractDeath; }
-
+sub _accessible { shift->throw_not_implemented(); }
+sub _attr_type { shift->throw_not_implemented(); }
 
 #
 # deal with 'set_' and 'get_' methods
diff -Naur bioperl-1.0/Bio/Biblio.pm bioperl-1.01/Bio/Biblio.pm
--- bioperl-1.0/Bio/Biblio.pm	Fri Mar  8 05:55:18 2002
+++ bioperl-1.01/Bio/Biblio.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module Bio::Biblio
 #
@@ -70,10 +70,11 @@
 
 =item B<Bio::Biblio>
 
-This is the main (and the only) class to be used by the end users. It
+This is the main class to be used by the end users. It
 loads a real implementation for a particular access protocol according
 to the argument I<-access>. At the time of writing this documentation
-there is only one available access method:
+there is only one available access module implementing all query and
+retrieval methods:
 
    -access => soap
 
@@ -82,28 +83,40 @@
 calls to a loaded low-level module (e.g. see
 L<Bio::DB::Biblio::soap>).
 
-=item B<Bio::DB::BiblioI>
+Note that there is also another module (and perhaps more) which does
+not use SOAP protocol and do not implement all query methods -
+nevertheless it has retrieval methods and it can be used in the same
+way:
+
+   -access => biofetch
+
+
+=item Bio::DB::BiblioI
 
 This is an interface defining all methods that can be called on
 I<Bio::Biblio> instances.
 
-=item B<Bio::DB::Biblio::soap>
+=item Bio::DB::Biblio::soap
 
 This is a real implementation of all methods defined in
 Bio::DB::BiblioI using SOAP protocol (calling a WebService
 based on SOAP). This class should not be instantiated directly (use
 I<Bio::Biblio> instead). See L<Bio::DB::BiblioI> for details.
 
-=item Bio::Biblio::IO   I<(not yet written)>
+=item Bio::Biblio::IO
 
-This module instantiates and uses a lower-level converter
-(e.g. I<Bio::Biblio::IO::medlinexml>) in order to transform citations
-from an XML format to Perl objects.
+This module instantiates and uses a converter of the citations read by
+any of the access methods mentioned above. See L<Bio::Biblio::IO> for
+details.
 
-=item Bio::Biblio::IO::medlinexml  I<(not yet written)>
+=item Bio::Biblio::IO::medlinexml and Bio::Biblio::IO::medline2ref
 
 A converter of MEDLINE citations in XML into Perl objects.
 
+=item Bio::Biblio::IO::pubmedxml and Bio::Biblio::IO::pubmed2ref
+
+A converter of PUBMED citations in XML into Perl objects.
+
 =back
 
 =head1 FEEDBACK
@@ -180,8 +193,8 @@
 
 
 BEGIN { 
-    $VERSION = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d.%-02d", @r };
-    $Revision = q$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $;
+    $VERSION = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d.%-02d", @r };
+    $Revision = q$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $;
 }
 
 # -----------------------------------------------------------------------------
@@ -194,8 +207,7 @@
 
              -access => 'soap'
                It indicates what lower-level module to load.
-               Default is 'soap' - and it is at the moment the only
-               available and recognised value. 
+               Default is 'soap'.
 
              -location => 'http://...'
                 It says where to find a bibliographic query service.
diff -Naur bioperl-1.0/Bio/DB/Biblio/soap.pm bioperl-1.01/Bio/DB/Biblio/soap.pm
--- bioperl-1.0/Bio/DB/Biblio/soap.pm	Thu Feb 28 04:22:23 2002
+++ bioperl-1.01/Bio/DB/Biblio/soap.pm	Fri Apr 12 00:10:14 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module Bio::DB::Biblio::soap.pm
 #
@@ -124,8 +124,8 @@
 
 BEGIN { 
     # set the version for version checking
-    $VERSION = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d.%-02d", @r };
-    $Revision = q$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $;
+    $VERSION = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d.%-02d", @r };
+    $Revision = q$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $;
 
     # where to go...
     $DEFAULT_SERVICE = 'http://industry.ebi.ac.uk/soap/openBQS';
@@ -187,6 +187,11 @@
                 See the code for attributes of the default SOAP::Lite
                 object.
 
+              -httpproxy => 'http://server:port'
+                 In addition to the 'location' parameter, you may need
+                 to specify also a location/URL of a HTTP proxy server
+                 (if your site requires one).
+
 	   Additionally, the main module Bio::Biblio recognises
 	   also:
              -access => '...'
@@ -228,10 +233,18 @@
     $self->{'_location'} = $DEFAULT_SERVICE unless $self->{'_location'};
     $self->{'_namespace'} = $DEFAULT_NAMESPACE unless $self->{'_namespace'};
     $self->{'_destroy_on_exit'} = 1 unless defined $self->{'_destroy_on_exit'};
-    $self->{'_soap'} = SOAP::Lite
-	                  -> uri ($self->{'_namespace'})
-	                  -> proxy ($self->{'_location'}) unless $self->{'_soap'};
-
+    unless ($self->{'_soap'}) {
+	if (defined $self->{'_httpproxy'}) {
+	    $self->{'_soap'} = SOAP::Lite
+	                          -> uri ($self->{'_namespace'})
+		                  -> proxy ($self->{'_location'},
+				            proxy => ['http' => $self->{'_httpproxy'}]);
+	} else {
+	    $self->{'_soap'} = SOAP::Lite
+	                          -> uri ($self->{'_namespace'})
+				  -> proxy ($self->{'_location'});
+	}
+    }
 }
 
 # -----------------------------------------------------------------------------
@@ -420,7 +433,9 @@
    my $soap = $self->{'_soap'};
    my ($collection_id) = $self->{'_collection_id'};
    $self->throw ($self->_no_id_msg) unless $collection_id;
-   $soap->getNext (SOAP::Data->type (string => $collection_id))->result;
+   my $ra = $soap->getNext (SOAP::Data->type (string => $collection_id))->result;
+   $self->{'_collection_id'} = shift @{ $ra };
+   shift @{ $ra };
 }
 
 sub get_more {
@@ -438,8 +453,10 @@
        $how_many = 1;
    }
 
-   $soap->getMore (SOAP::Data->type (string => $collection_id),
-		   SOAP::Data->type (int    => $how_many))->result;
+   my $ra = $soap->getMore (SOAP::Data->type (string => $collection_id),
+			    SOAP::Data->type (int    => $how_many))->result;
+   $self->{'_collection_id'} = shift @{ $ra };
+   $ra;
 }
 
 sub reset_retrieval {
@@ -447,7 +464,7 @@
    my $soap = $self->{'_soap'};
    my ($collection_id) = $self->{'_collection_id'};
    $self->throw ($self->_no_id_msg) unless $collection_id;
-   $soap->resetRetrieval (SOAP::Data->type (string => $collection_id));
+   $self->{'_collection_id'} = $soap->resetRetrieval (SOAP::Data->type (string => $collection_id))->result;
 }
 
 sub exists {
diff -Naur bioperl-1.0/Bio/DB/GFF/Adaptor/dbi/mysql.pm bioperl-1.01/Bio/DB/GFF/Adaptor/dbi/mysql.pm
--- bioperl-1.0/Bio/DB/GFF/Adaptor/dbi/mysql.pm	Sat Feb 16 04:42:28 2002
+++ bioperl-1.01/Bio/DB/GFF/Adaptor/dbi/mysql.pm	Sun Mar 31 16:27:36 2002
@@ -16,7 +16,7 @@
 use Bio::DB::GFF::Util::Rearrange; # for rearrange()
 use vars qw($VERSION @ISA);
 @ISA = qw(Bio::DB::GFF::Adaptor::dbi);
-$VERSION = '0.30';
+$VERSION = '0.50';
 
 use constant MAX_SEGMENT => 100_000_000;  # the largest a segment can get
 use constant DEFAULT_CHUNK => 2000;
@@ -334,8 +334,13 @@
 sub make_abscoord_query {
   my $self = shift;
   my ($name,$class,$refseq) = @_;
+  my $query = GETSEQCOORDS;
+  if ($name =~ /\*/) {
+    $name =~ tr/*/%/;
+    $query =~ s/gname=\?/gname LIKE ?/;
+  }
   defined $refseq ? $self->dbh->do_query(GETFORCEDSEQCOORDS,$name,$class,$refseq) 
-    : $self->dbh->do_query(GETSEQCOORDS,$name,$class);
+    : $self->dbh->do_query($query,$name,$class);
 }
 
 # override parent
@@ -374,7 +379,12 @@
 sub make_features_by_name_where_part {
   my $self = shift;
   my ($class,$name) = @_;
-  return ("fgroup.gclass=? AND fgroup.gname=?",$class,$name);
+  if ($name =~ /\*/) {
+    $name =~ s/\*/%/g;
+    return ("fgroup.gclass=? AND fgroup.gname LIKE ?",$class,$name);
+  } else {
+    return ("fgroup.gclass=? AND fgroup.gname=?",$class,$name);
+  }
 }
 
 sub make_features_by_attribute_where_part {
@@ -940,6 +950,24 @@
 }
 
 
+=head2 make_classes_query
+
+ Title   : make_classes_query
+ Usage   : ($query,@args) = $db->make_classes_query
+ Function: return query fragment for generating list of reference classes
+ Returns : a query and args
+ Args    : none
+ Status  : public
+
+=cut
+
+sub make_classes_query {
+  my $self = shift;
+  return 'SELECT DISTINCT gclass FROM fgroup WHERE NOT ISNULL(gclass)';
+}
+
+
+# why is this here?
 sub get_features_iterator {
   my $self = shift;
   $self->SUPER::get_features_iterator(@_);
diff -Naur bioperl-1.0/Bio/DB/GFF/Adaptor/dbi.pm bioperl-1.01/Bio/DB/GFF/Adaptor/dbi.pm
--- bioperl-1.0/Bio/DB/GFF/Adaptor/dbi.pm	Mon Feb 25 07:18:07 2002
+++ bioperl-1.01/Bio/DB/GFF/Adaptor/dbi.pm	Sun Mar 31 16:27:29 2002
@@ -238,6 +238,52 @@
   return $count;
 }
 
+=head2 classes
+
+ Title   : classes
+ Usage   : $db->classes
+ Function: return list of landmark classes in database
+ Returns : a list of classes
+ Args    : none
+ Status  : public
+
+This routine returns the list of reference classes known to the
+database, or empty if classes are not used by the database.  Classes
+are distinct from types, being essentially qualifiers on the reference
+namespaces.
+
+NOTE: In the current mysql-based schema, this query takes a while to
+run due to the classes not being normalized.
+
+=cut
+
+sub classes {
+  my $self = shift;
+  my ($query,@args) = $self->make_classes_query or return;
+  my $sth           = $self->dbh->do_query($query,@args);
+  my @classes;
+  while (my ($c) = $sth->fetchrow_array) {
+     push @classes,$c;
+  }
+  @classes;
+}
+
+=head2 make_classes_query
+
+ Title   : make_classes_query
+ Usage   : ($query,@args) = $db->make_classes_query
+ Function: return query fragment for generating list of reference classes
+ Returns : a query and args
+ Args    : none
+ Status  : public
+
+=cut
+
+sub make_classes_query {
+  my $self = shift;
+  return;
+}
+
 =head2 _feature_by_name
 
  Title   : _feature_by_name
@@ -915,8 +961,8 @@
 
 =head2 make_features_by_name_where_part
 
- Title   : make_features_byname_where_part
- Usage   : $db->make_features_byname_where_part($class,$name)
+ Title   : make_features_by_name_where_part
+ Usage   : $db->make_features_by_name_where_part($class,$name)
  Function: create the SQL fragment needed to select a feature by its group name & class
  Returns : a SQL fragment and bind arguments
  Args    : class and name of the feature group
diff -Naur bioperl-1.0/Bio/DB/GFF/Adaptor/memory.pm bioperl-1.01/Bio/DB/GFF/Adaptor/memory.pm
--- bioperl-1.0/Bio/DB/GFF/Adaptor/memory.pm	Wed Jan 23 14:06:12 2002
+++ bioperl-1.01/Bio/DB/GFF/Adaptor/memory.pm	Sun Mar 31 16:25:03 2002
@@ -1,14 +1,27 @@
 package Bio::DB::GFF::Adaptor::memory;
 use strict;
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# AUTHOR: Shulamit Avraham
+# This module needs to be cleaned up and documented
+
+# Bio::DB::GFF::Adaptor::memory --  in-memory db adaptor
+# implements the low level handling of data which stored in memory.
+# This adaptor implements a specific in memory schema that is compatible with Bio::DB::GFF.
+# Inherits from Bio::DB::GFF.
 
+
+#use lib './blib/lib';
+#use lib '/u/swiss/shuly/bioperl-live';
+# use lib '/a/swiss/export/home/shuly/bioperl-live';
 use Bio::DB::GFF;
 use Bio::DB::GFF::Util::Rearrange; # for rearrange()
+use Bio::DB::GFF::Adaptor::memory_iterator;
 use vars qw($VERSION @ISA);
 
 use constant MAX_SEGMENT => 100_000_000;  # the largest a segment can get
 
 @ISA =  qw(Bio::DB::GFF);
-$VERSION = '0.01';
+$VERSION = '0.02';
 
 sub new {
   my $class = shift ;
@@ -22,12 +35,18 @@
   return $self;
 }
 
+
+
 sub insert_sequence {
   my $self = shift;
   my($id,$offset,$seq) = @_;
   $self->{dna}{$id} .= $seq;
 }
 
+
+
+# low-level fetch of a DNA substring given its
+# name, class and the desired range.
 sub get_dna {
   my $self = shift;
   my ($id,$start,$stop,$class) = @_;
@@ -45,34 +64,76 @@
   $dna;
 }
 
+
+# this method loads the feature as a hash into memory -
+# keeps an array of features-hashes as an in-memory db
 sub load_gff_line {
   my $self = shift;
   my $feature_hash  = shift;
-  $feature_hash->{strand} = '+' if $feature_hash->{strand} eq '.'; 
-  $feature_hash->{phase} = '+' if $feature_hash->{phase} eq '.';
+  $feature_hash->{strand} = '' if $feature_hash->{strand} eq '.'; 
+  $feature_hash->{phase} = '' if $feature_hash->{phase} eq '.';
+  #$feature_hash->{strand} = '+' if $feature_hash->{strand} eq '.'; 
+  #$feature_hash->{phase} = '+' if $feature_hash->{phase} eq '.';
   push @{$self->{data}},$feature_hash;
 }
 
+
+# given sequence name, return (reference,start,stop,strand)
 sub get_abscoords {
   my $self = shift;
   my ($name,$class,$refseq) = @_;
   my %refs;
 
   # Find all features that have the requested name and class.
-  #for my $type (@$typelist) {
-  #	my ($method,$source) = @$type;
-  #	if defined $method && length $method {
-  #	  next unless $feature_method ;
-  #	}
-  #} 
   # Sort them by reference point.
   for my $feature (@{$self->{data}}) {
-    next unless $feature->{gname} eq $name;
-    next unless $feature->{gclass} eq $class;
+    #next unless $feature->{gname} eq $name;
+    #next unless $feature->{gclass} eq $class;
+    
+    my $no_match_class_name;
+    my $empty_class_name;
+    if ($feature->{gname} and $feature->{gclass}){
+      $no_match_class_name = 1 
+	if ($feature->{gname} ne $name || $feature->{gclass} ne $class);
+    }
+    else{
+      $empty_class_name = 1;
+    }
+
+    if ($no_match_class_name || $empty_class_name){
+    #if ($feature->{gname} ne $name || $feature->{gclass} ne $class){
+
+      my $feature_attributes = $feature->{attributes};
+      my $attributes = {Alias => $name};
+      if (!_matching_attributes($feature_attributes,$attributes)){
+         next;
+      }
+    
+    }
+    
     push @{$refs{$feature->{ref}}},$feature;
   }
 
   # find out how many reference points we recovered
+
+  if (! %refs) {
+    $self->error("$name not found in database");
+    return;
+  } elsif (keys %refs > 1) {
+    $self->error("$name has more than one reference sequence in database");
+    return;
+  }
+
+  # compute min and max
+  my ($ref) = keys %refs;
+  my @found = @{$refs{$ref}};
+  my ($strand,$start,$stop);
+  foreach (@found) {
+    $strand ||= $_->{strand};
+    $strand = '+' if $strand eq '.'; 
+    $start  = $_->{start} if !defined($start) || $start > $_->{start};
+    $stop   = $_->{stop}  if !defined($stop)  || $stop  < $_->{stop};
+
   my @found_segments;
   foreach my $ref (keys %refs) {
     next if defined($refseq) and $ref ne $refseq;
@@ -85,146 +146,229 @@
       $stop   = $_->{stop}  if !defined($stop)  || $stop  < $_->{stop};
     }
     push @found_segments,[$ref,$class,$start,$stop,$strand];
+
   }
   return \@found_segments;
 }
 
 
-#sub get_features{
-#  my $self = shift;
-#  my ($search,$options,$callback) = @_;
-#  my @found_features;
-#  my (%result,%obj);
-
-#  for my $feature (@{$self->{data}}) {
-#    my $feature_start = $feature->{start};
-#    my $feature_stop  = $feature->{stop};
-#    my $feature_ref   = $feature->{ref};
-#    next unless $feature_ref eq $search->{refseq};
-
-#    my $rangetype = $search->{rangetype};
-#    if ($rangetype eq 'overlap') {
-#      next unless $feature_stop >= $search->{start} && $feature_start <= $search->{stop};
-#    } elsif ($rangetype eq 'contains') {
-#      next unless $feature_start >= $search->{start} && $feature_stop <= $search->{stop};
-#    } elsif ($rangetype eq 'contained_in') {
-#      next unless $feature_start <= $search->{start} && $feature_stop >= $search->{stop};
-#    } else {
-#      next unless $feature_start == $search->{start} && $feature_stop == $search->{stop};
-#    }
-
-#    my $feature_source = $feature->{source};
-#    my $feature_method = $feature->{method};
-    
-#    foreach (@{$search->{types}}) {
-#      my ($search_method,$search_source) = @$_;
-#      next if $search_method ne $feature_method;
-#      next if defined($search_source) && $search_source ne $feature_source;
-#    }
+# attributes -
 
-    # if we get here, then we have a feature that meets the criteria.
-    # If we were asked to sort by group, then we just push onto an array
-    # of found features and continue.  Otherwise we call the callback
-    # immediately.
-#    if ($options->{sort_by_group}) {
-#      push @found_features,$feature;
-#      next;
-#    } else {
-#      $callback->($feature_ref,
-#		  $feature_start,
-#		  $feature_stop,
-#		  $feature_source,
-#		  $feature_method,
-#		  $feature->{score},
-#		  $feature->{strand},
-#		  $feature->{phase},
-#		  $feature->{gclass},
-#		  $feature->{gname},
-#		  $feature->{tstart},
-#		  $feature->{tstop}
-#		 );
-#    }
-#  }
-
-#  for my $feature (sort
-#		   {"$a->{gclass}:$a->{gname}" cmp "$b->{gclass}:$b->{gname}"
-#		  } @found_features) {  # only true if the sort by group option was specified
- #   $callback->(
-#		@{$feature}{qw(ref start stop source method score strand phase gclass gname tstart tstop)}
-#	       );
-#  }
-#}
- 
+# Some GFF version 2 files use the groups column to store a series of
+# attribute/value pairs.  In this interpretation of GFF, the first such
+# pair is treated as the primary group for the feature; subsequent pairs
+# are treated as attributes.  Two attributes have special meaning:
+# "Note" is for backward compatibility and is used for unstructured text
+# remarks.  "Alias" is considered as a synonym for the feature name.
+# If no name is provided, then attributes() returns a flattened hash, of
+# attribute=>value pairs.
 
-sub get_features{
+sub do_attributes{
   my $self = shift;
-  my ($rangetype,$refseq,$class,$start,$stop,$types,$sparse,$callback,$order_by_group) = @_;
-  my @found_features;
-  my (%result,%obj);
+  my ($feature_id,$tag) = @_;
+  my $attr ;
 
-  for my $feature (@{$self->{data}}) {
-    my $feature_start = $feature->{start};
-    my $feature_stop  = $feature->{stop};
-    my $feature_ref   = $feature->{ref};
-    next unless $feature_ref eq $refseq;
+  my $feature = ${$self->{data}}[$feature_id];
+  
+  my @result;
+  for my $attr (@{$feature->{attributes}}) {
+    my ($attr_name,$attr_value) = @$attr ;
+    if (defined($tag) && $attr_name eq $tag){push @result,$attr_value;}
+    elsif (!defined($tag)) {push @result,($attr_name,$attr_value);}
+  }
+  return @result;
+}
 
 
-     if (defined $start or defined $stop) {
-      $start = 0               unless defined($start);
-      $stop  = MAX_SEGMENT     unless defined($stop);
-    
-      if ($rangetype eq 'overlaps') {
-	next unless $feature_stop >= $start && $feature_start <= $stop;
-      } elsif ($rangetype eq 'contains') {
-	next unless $feature_start >= $start && $feature_stop <= $stop;
-      } elsif ($rangetype eq 'contained_in') {
-	next unless $feature_start <= $start && $feature_stop >= $stop;
-      } else {
-	next unless $feature_start == $start && $feature_stop == $stop;
-      }
-
-    }
-    
-    my $feature_source = $feature->{source};
-    my $feature_method = $feature->{method};
+#sub get_feature_by_attribute{
+sub _feature_by_attribute{
+  my $self = shift;
+  my ($attributes,$callback) = @_;
+  $callback || $self->throw('must provide a callback argument');
+  
+  my $count = 0;
+  my $feature_id = -1;
+  my $feature_group_id = undef;
 
-    if (defined $types && @$types){
-      next unless _matching_typelist($feature_method,$feature_source,$types);
-    } 
+  for my $feature (@{$self->{data}}) {
 
-    # if we get here, then we have a feature that meets the criteria.
-    # If we were asked to sort by group, then we just push onto an array
-    # of found features and continue.  Otherwise we call the callback
-    # immediately.
-    if ($order_by_group) {
-      push @found_features,$feature;
-      next;
-    } else {
-      $callback->($feature_ref,
-		  $feature_start,
-		  $feature_stop,
-		  $feature_source,
-		  $feature_method,
-		  $feature->{score},
-		  $feature->{strand},
-		  $feature->{phase},
-		  $feature->{gclass},
-		  $feature->{gname},
-		  $feature->{tstart},
-		  $feature->{tstop}
-		 );
+    $feature_id++;
+    for my $attr (@{$feature->{attributes}}) {
+      my ($attr_name,$attr_value) = @$attr ;
+      
+      #there could be more than one set of attributes......
+      foreach (keys %$attributes) {
+	if ($_ eq $attr_name && $attributes->{$_} eq $attr_value){
+	   
+           $callback->($feature->{ref},
+	        $feature->{start},
+	        $feature->{stop},
+	        $feature->{source},
+	        $feature->{method},
+	        $feature->{score},
+	        $feature->{strand},
+	        $feature->{phase},
+	        $feature->{gclass},
+	        $feature->{gname},
+		$feature->{tstart},
+		$feature->{tstop},
+	        $feature_id,
+		$feature_group_id);
+	   $count++;						    
+        }						       
+      }
     }
   }
 
-  for my $feature (sort
-		   {"$a->{gclass}:$a->{gname}" cmp "$b->{gclass}:$b->{gname}"
-		  } @found_features) {  # only true if the sort by group option was specified
+}
+
+
+
+# This is the low-level method that is called to retrieve GFF lines from
+# the database.  It is responsible for retrieving features that satisfy
+# range and feature type criteria, and passing the GFF fields to a
+# callback subroutine.
+
+sub get_features{
+  my $self = shift;
+  my $count = 0;
+  
+  my ($search,$options,$callback) = @_;				       
+  my $data = \@{$self->{data}};
+
+  my $found_features;
+
+  $found_features = _get_features_by_search_options($data,$search,$options);
+  
+  # only true if the sort by group option was specified
+  @{$found_features} = sort {"$a->{gclass}:$a->{gname}" cmp "$b->{gclass}:$b->{gname}"} 
+    @{$found_features} if $options->{sort_by_group} ;
+  
+  for my $feature (@{$found_features}) {  # only true if the sort by group option was specified
+    $count++;
     $callback->(
-		@{$feature}{qw(ref start stop source method score strand phase gclass gname tstart tstop)}
+		@{$feature}{qw(ref start stop source method score strand phase gclass gname tstart tstop feature_id feature_group_id)}
+	       );
+  }
+
+  return $count;
+}
+
+
+# Low level implementation of fetching a named feature.
+# GFF annotations are named using the group class and name fields.
+# May return zero, one, or several Bio::DB::GFF::Feature objects.
+
+=head2 _feature_by_name
+
+ Title   : _feature_by_name
+ Usage   : $db->get_features_by_name($name,$class,$callback)
+ Function: get a list of features by name and class
+ Returns : count of number of features retrieved
+ Args    : name of feature, class of feature, and a callback
+ Status  : protected
+
+This method is used internally.  The callback arguments are those used
+by make_feature().
+
+=cut
+
+sub _feature_by_name {
+  my $self = shift;
+  my ($class,$name,$callback) = @_;
+  $callback || $self->throw('must provide a callback argument');
+  my $count = 0;
+  my $id    = -1;
+
+  for my $feature (@{$self->{data}}) {
+    $id++;
+    next unless $feature->{gname} eq $name;
+    next unless $feature->{gclass} eq $class;
+    $count++;
+    $callback->(@{$feature}{qw(
+			       ref
+			       start
+			       stop
+			       source
+			       method
+			       score
+			       strand
+			       phase
+			       gclass
+			       gname
+			       tstart
+			       tstop
+			      )},$id,0
 	       );
   }
+  return $count;
 }
 
+# Low level implementation of fetching a feature by it's id. 
+# The id of the feature as implemented in the in-memory db, is the location of the 
+# feature in the features hash array.
+sub _feature_by_id{
+  my $self = shift;
+  my ($ids,$type,$callback) = @_;
+  $callback || $self->throw('must provide a callback argument');
+
+  my $feature_group_id = undef;
+
+  my $count = 0;
+  if ($type eq 'feature'){
+    for my $feature_id (@$ids){
+       my $feature = ${$self->{data}}[$feature_id];
+       
+       $callback->($feature->{ref},
+	        $feature->{start},
+	        $feature->{stop},
+	        $feature->{source},
+	        $feature->{method},
+	        $feature->{score},
+	        $feature->{strand},
+	        $feature->{phase},
+	        $feature->{gclass},
+	        $feature->{gname},
+		$feature->{tstart},
+		$feature->{tstop},
+	        $feature_id,
+		$feature_group_id);
+	   $count++;			
+    
+    }
+  }
+}
+
+
+# This method is similar to get_features(), except that it returns an
+# iterator across the query.  
+# See Bio::DB::GFF::Adaptor::memory_iterator.
+
+sub get_features_iterator {
+  my $self = shift;
+  my ($search,$options,$callback) = @_;
+  $callback || $self->throw('must provide a callback argument');
+
+  my $data = \@{$self->{data}};
+  my $results = _get_features_by_search_options($data,$search,$options);
+  my $results_array = _convert_feature_hash_to_array($results);
+
+  return Bio::DB::GFF::Adaptor::memory_iterator->new($results_array,$callback);
+}
+
+
+
+
+# This method is responsible for fetching the list of feature type names.
+# The query may be limited to a particular range, in
+# which case the range is indicated by a landmark sequence name and
+# class and its subrange, if any.  These arguments may be undef if it is
+# desired to retrieve all feature types.
+
+# If the count flag is false, the method returns a simple list of
+# Bio::DB::GFF::Typename objects.  If $count is true, the method returns
+# a list of $name=>$count pairs, where $count indicates the number of
+# times this feature occurs in the range.
 
 sub get_types {
   my $self = shift;
@@ -268,23 +412,172 @@
  
 }
 
-sub _matching_typelist{
+
+
+
+# Internal method that performs a search on the features array, 
+# sequentialy retrieves the features, and performs a check on each feature
+# according to the search options.
+ 
+sub _get_features_by_search_options{
+ 
+  my $count = 0;
   
-  my ($feature_method,$feature_source,$typelist) = @_; 
+  my ($data,$search,$options) = @_;
+  my ($rangetype,$refseq,$class,$start,$stop,$types,$sparse,$order_by_group,$attributes) = 
+    (@{$search}{qw(rangetype refseq refclass start stop types)},
+    @{$options}{qw(sparse sort_by_group ATTRIBUTES)}) ;
+					       
+  my @found_features;
+
+  my $feature_id = -1 ;
+  my $feature_group_id = undef;
+
+  for my $feature (@{$data}) {
+
+    $feature_id++;
+    
+    my $feature_start = $feature->{start};
+    my $feature_stop  = $feature->{stop};
+    my $feature_ref   = $feature->{ref};
+    
+    if (defined $refseq){
+      next unless $feature_ref eq $refseq;
+    }
+
+     if (defined $start or defined $stop) {
+      $start = 0               unless defined($start);
+      $stop  = MAX_SEGMENT     unless defined($stop);
+    
+      if ($rangetype eq 'overlaps') {
+	next unless $feature_stop >= $start && $feature_start <= $stop;
+      } elsif ($rangetype eq 'contains') {
+	next unless $feature_start >= $start && $feature_stop <= $stop;
+      } elsif ($rangetype eq 'contained_in') {
+	next unless $feature_start <= $start && $feature_stop >= $stop;
+      } else {
+	next unless $feature_start == $start && $feature_stop == $stop;
+      }
 
+    }
+    
+    my $feature_source = $feature->{source};
+    my $feature_method = $feature->{method};
+
+    if (defined $types && @$types){
+      next unless _matching_typelist($feature_method,$feature_source,$types);
+    } 
+
+    my $feature_attributes = $feature->{attributes};
+    if (defined $attributes){
+      next unless _matching_attributes($feature_attributes,$attributes);
+    } 
+    
+    # if we get here, then we have a feature that meets the criteria.
+    # Then we just push onto an array
+    # of found features and continue. 
+   
+    my $found_feature = $feature ;
+    $found_feature->{feature_id} = $feature_id;
+    $found_feature->{group_id} = $feature_group_id;
+    push @found_features,$found_feature;
+   
+  }
+
+  return \@found_features; 
+}
+
+
+
+
+
+# this subroutine is needed for convertion of the feature from hash to array in order to 
+# pass it to the callback subroutine
+sub _convert_feature_hash_to_array{
+  my @features_hash_array = @_;
+
+  use constant FREF    => 0;
+  use constant FSTART  => 1;
+  use constant FSTOP   => 2;
+  use constant FSOURCE => 3;
+  use constant FMETHOD => 4;
+  use constant FSCORE  => 5;
+  use constant FSTRAND => 6;
+  use constant FPHASE  => 7;
+  use constant GCLASS  => 8;
+  use constant GNAME   => 9;
+  use constant TSTART  => 10;
+  use constant TSTOP   => 11;
+  use constant FID     => 12;
+  use constant GID     => 13;
+
+  my @features_array_array;
+  my $feature_count = 0;
+   
+  for my $feature_hash (@{$features_hash_array[0]}){
+    my @feature_array;
+
+    $feature_array[FREF]    = $feature_hash->{ref};
+    $feature_array[FSTART]  = $feature_hash->{start};
+    $feature_array[FSTOP]   = $feature_hash->{stop};  
+    $feature_array[FSOURCE] = $feature_hash->{source};
+    $feature_array[FMETHOD] = $feature_hash->{method};
+    $feature_array[FSCORE]  = $feature_hash->{score};
+    $feature_array[FSTRAND] = $feature_hash->{strand};  
+    $feature_array[FPHASE ] = $feature_hash->{phase};
+    $feature_array[GCLASS]  = $feature_hash->{gclass};  
+    $feature_array[GNAME]   = $feature_hash->{gname};
+    $feature_array[TSTART]  = $feature_hash->{tstart};
+    $feature_array[TSTOP]   = $feature_hash->{tstop};
+    $feature_array[FID]     = $feature_hash->{feature_id};  
+    $feature_array[GID]     = $feature_hash->{group_id};
+
+    $features_array_array[$feature_count] = \@feature_array;
+    $feature_count++;
+  }
+  return \@features_array_array;
+}
+
+
+
+
+
+sub _matching_typelist{ 
+  my ($feature_method,$feature_source,$typelist) = @_; 
   foreach (@$typelist) {
 	 my ($search_method,$search_source) = @$_;
 	 next if $search_method ne $feature_method;
 	 next if defined($search_source) && $search_source ne $feature_source;
 	 return 1;
   }
- 
   return 0;
 }
 
+sub _matching_attributes{
+  my ($feature_attributes,$attributes) = @_ ;
+  foreach (keys %$attributes) {
+    return 0 if !_match_all_attr_in_feature($_,$attributes->{$_},$feature_attributes)
+   
+  }
+  return 1;
+}
+
+sub _match_all_attr_in_feature{
+  my ($attr_name,$attr_value,$feature_attributes) = @_;
+  for my $attr (@$feature_attributes) {
+      my ($feature_attr_name,$feature_attr_value) = @$attr ;
+      next if ($attr_name ne $feature_attr_name || $attr_value ne $feature_attr_value);
+      return 1;
+  }
+  return 0;
+}
+
+
 sub do_initialize { 1; }
 sub setup_load { }
 sub finish_load { 1; }
+sub get_feature_by_group_id{ 1; }
 
 1;
 
+}
diff -Naur bioperl-1.0/Bio/DB/GFF/Adaptor/memory_iterator.pm bioperl-1.01/Bio/DB/GFF/Adaptor/memory_iterator.pm
--- bioperl-1.0/Bio/DB/GFF/Adaptor/memory_iterator.pm	Wed Dec 31 19:00:00 1969
+++ bioperl-1.01/Bio/DB/GFF/Adaptor/memory_iterator.pm	Sun Mar 31 16:25:03 2002
@@ -0,0 +1,51 @@
+package Bio::DB::GFF::Adaptor::memory_iterator;
+use strict;
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# this module needs to be cleaned up and documented
+
+#use constant STH         => 0;
+#use constant CALLBACK    => 1;
+#use constant CACHE       => 2;
+
+*next_seq = \&next_feature;
+
+sub new {
+  my $class = shift;
+  my ($data,$callback) = @_;
+  my $pos = 0;
+  return bless {data     => $data,
+		pos      => $pos,
+		callback => $callback,
+                cache    => []},$class;
+  #return bless [$sth,$callback,[]],$class;
+}
+
+sub next_feature {
+  my $self = shift;
+  return shift @{$self->{cache}} if @{$self->{cache}};
+  my $data = $self->{data} or return;
+  my $next_feature_pos = $self->{pos}; 
+  my $callback = $self->{callback};
+
+  my $features;
+  while (1) {
+    #if (my $feature = $self->{data}[$next_feature_pos]) {
+    if ($next_feature_pos < @{$self->{data}}){
+      my $feature = $self->{data}[$next_feature_pos];
+      $features = $callback->(@{$feature});
+      $self->{pos}++;
+      last if $features;
+    } else {
+      undef $self->{pos};
+      undef $self->{data};
+      $features = $callback->();
+      #last;
+      return;
+    }
+  }
+  #return $features;
+  $self->{cache} = $features or return;
+  shift @{$self->{cache}}; 
+}
+
+1;
diff -Naur bioperl-1.0/Bio/DB/GFF/Aggregator/alignment.pm bioperl-1.01/Bio/DB/GFF/Aggregator/alignment.pm
--- bioperl-1.0/Bio/DB/GFF/Aggregator/alignment.pm	Mon Nov  5 08:19:04 2001
+++ bioperl-1.01/Bio/DB/GFF/Aggregator/alignment.pm	Fri Apr 12 07:54:32 2002
@@ -88,6 +88,7 @@
   warn "running aligner adjuster" if $factory->debug;
   for my $alignment (values %alignments) {
     $alignment->adjust_bounds;
+    $alignment->compound(1);
     push @result,$alignment;
   }
   warn "aligner done" if $factory->debug;
diff -Naur bioperl-1.0/Bio/DB/GFF/Aggregator/wormbase_gene.pm bioperl-1.01/Bio/DB/GFF/Aggregator/wormbase_gene.pm
--- bioperl-1.0/Bio/DB/GFF/Aggregator/wormbase_gene.pm	Fri Jan 11 13:00:41 2002
+++ bioperl-1.01/Bio/DB/GFF/Aggregator/wormbase_gene.pm	Wed Dec 31 19:00:00 1969
@@ -1,105 +0,0 @@
-=head1 NAME
-
-Bio::DB::GFF::Aggregator::wormbase_gene -- Wormbase gene aggregator
-
-=head1 SYNOPSIS
-
-  use Bio::DB::GFF;
-
-  # Open the sequence database
-  my $db      = Bio::DB::GFF->new( -adaptor => 'dbi:mysql',
-                                   -dsn     => 'dbi:mysql:elegans42',
-				   -aggregator => ['wormbase_gene','clone'],
-				 );
-
-
-=head1 DESCRIPTION
-
-Bio::DB::GFF::Aggregator::wormbase_gene is one of the default
-aggregators, and was written to be compatible with the C elegans GFF
-files.  It aggregates raw ""exon", "CDS", "5'UTR", "3'UTR", "polyA"
-and "TSS" features into "transcript" features.  For compatibility with
-the idiosyncrasies of the Sanger GFF format, it expects that the full
-range of the transcript is contained in a main feature of type
-"Sequence".
-
-=cut
-
-package Bio::DB::GFF::Aggregator::wormbase_gene;
-
-use strict;
-use Bio::DB::GFF::Aggregator;
-
-use vars qw($VERSION @ISA);
-@ISA = qw(Bio::DB::GFF::Aggregator);
-
-$VERSION = '0.10';
-
-=head2 method
-
- Title   : method
- Usage   : $aggregator->method
- Function: return the method for the composite object
- Returns : the string "transcript"
- Args    : none
- Status  : Public
-
-=cut
-
-sub method { 'transcript' }
-
-sub require_whole_object { 1; }
-
-=head2 part_names
-
- Title   : part_names
- Usage   : $aggregator->part_names
- Function: return the methods for the sub-parts
- Returns : the list "exon", "CDS", "5'UTR", "3'UTR", "TSS", "PolyA"
- Args    : none
- Status  : Public
-
-=cut
-
-sub part_names {
-  return qw(exon CDS 5'UTR 3'UTR TSS PolyA);
-}
-
-=head2 main_name
-
- Title   : main_name
- Usage   : $aggregator->main_name
- Function: return the method for the main component
- Returns : the string "Sequence"
- Args    : none
- Status  : Public
-
-=cut
-
-sub main_name {
-  return 'Sequence';
-}
-
-1;
-__END__
-
-=head1 BUGS
-
-None reported.
-
-
-=head1 SEE ALSO
-
-L<Bio::DB::GFF>, L<Bio::DB::GFF::Aggregator>
-
-=head1 AUTHOR
-
-Lincoln Stein E<lt>lstein@cshl.orgE<gt>.
-
-Copyright (c) 2001 Cold Spring Harbor Laboratory.
-
-This library is free software; you can redistribute it and/or modify
-it under the same terms as Perl itself.
-
-=cut
-
diff -Naur bioperl-1.0/Bio/DB/GFF/Aggregator.pm bioperl-1.01/Bio/DB/GFF/Aggregator.pm
--- bioperl-1.0/Bio/DB/GFF/Aggregator.pm	Wed Feb 13 06:02:45 2002
+++ bioperl-1.01/Bio/DB/GFF/Aggregator.pm	Fri Apr 12 07:54:03 2002
@@ -325,6 +325,7 @@
     $base->method($pseudo_method);
     $base->add_subfeature($_) foreach @{$aggregates{$_}{subparts}};
     $base->adjust_bounds;
+    $base->compound(1);  # set the compound flag
     push @result,$base;
   }
   @$features = @result;
diff -Naur bioperl-1.0/Bio/DB/GFF/Feature.pm bioperl-1.01/Bio/DB/GFF/Feature.pm
--- bioperl-1.0/Bio/DB/GFF/Feature.pm	Mon Feb 25 07:18:07 2002
+++ bioperl-1.01/Bio/DB/GFF/Feature.pm	Fri Apr 12 08:00:17 2002
@@ -12,8 +12,9 @@
 single annotation in a GFF database.  It inherits from
 Bio::DB::GFF::RelSegment, and so has all the support for relative
 addressing of this class and its ancestors.  It also inherits from
-Bio::SeqFeatureI, and so has the familiar start(), stop(),
-and primary_tag() methods.
+Bio::SeqFeatureI and so has the familiar start(), stop(),
+primary_tag() and location() methods (it implements Bio::LocationI
+too, if needed).
 
 Bio::DB::GFF::Feature adds new methods to retrieve the annotation's
 type, group, and other GFF attributes.  Annotation types are
@@ -71,11 +72,12 @@
 use Bio::DB::GFF::Homol;
 use Bio::SeqFeatureI;
 use Bio::Root::Root;
+use Bio::LocationI;
 
 use vars qw($VERSION @ISA $AUTOLOAD);
-@ISA = qw(Bio::DB::GFF::RelSegment Bio::SeqFeatureI Bio::Root::Root);
+@ISA = qw(Bio::DB::GFF::RelSegment Bio::SeqFeatureI Bio::LocationI Bio::Root::Root);
 
-$VERSION = '0.40';
+$VERSION = '0.60';
 #' 
 
 *segments = \&sub_SeqFeature;
@@ -488,6 +490,26 @@
   $clone;
 }
 
+=head2 compound
+
+ Title   : compound
+ Usage   : $flag = $f->compound([$newflag])
+ Function: get or set the compound flag
+ Returns : a boolean
+ Args    : a new flag (optional)
+ Status  : Public
+
+This method gets or sets a flag indicated that the feature is not a
+primary one from the database, but the result of aggregation.
+
+=cut
+
+sub compound  {
+  my $self = shift;
+  my $d    = $self->{compound};
+  $self->{compound} = shift if @_;
+  $d;
+}
 
 =head2 sub_SeqFeature
 
@@ -543,6 +565,50 @@
   push @{$subfeat},$feature;
 }
 
+=head2 location
+
+ Title   : location
+ Usage   : my $location = $seqfeature->location()
+ Function: returns a location object suitable for identifying location 
+	   of feature on sequence or parent feature  
+ Returns : Bio::LocationI object
+ Args    : none
+
+=cut
+
+sub location {
+   my $self = shift;
+   require Bio::Location::Split unless Bio::Location::Split->can('new');
+   my $location;
+   if (my @segments = $self->segments) {
+       $location = Bio::Location::Split->new();
+       foreach (@segments) {
+          $location->add_sub_Location($_);
+       }
+   } else {
+       $location = $self;
+   }
+   $location;
+}
+
+sub coordinate_policy {
+   require Bio::Location::WidestCoordPolicy unless Bio::Location::WidestCoordPolicy->can('new');
+   return Bio::Location::WidestCoordPolicy->new();
+}
+
+sub min_start { shift->low }
+sub max_start { shift->low }
+sub min_end   { shift->high }
+sub max_end   { shift->high}
+sub start_pos_type { 'EXACT' }
+sub end_pos_type   { 'EXACT' }
+sub to_FTstring {
+  my $self = shift;
+  my $low  = $self->min_start;
+  my $high = $self->max_end;
+  return "$low..$high";
+}
+
 =head2 merged_segments
 
  Title   : merged_segments
@@ -823,13 +889,6 @@
   ($self->{start},$self->{stop},$self->strand);
 }
 
-sub aggregated {
-  my $self = shift;
-  my $d = $self->{aggregated};
-  $self->{aggregated} = shift if @_;
-  $d;
-}
-
 =head2 sort_features
 
  Title   : sort_features
@@ -888,7 +947,6 @@
 sub name {
   my $self =shift;
   return $self->group || $self->SUPER::name;
-  
 }
 
 sub gff_string {
diff -Naur bioperl-1.0/Bio/DB/GFF/Segment.pm bioperl-1.01/Bio/DB/GFF/Segment.pm
--- bioperl-1.0/Bio/DB/GFF/Segment.pm	Wed Feb 20 23:02:27 2002
+++ bioperl-1.01/Bio/DB/GFF/Segment.pm	Sun Mar 31 16:27:19 2002
@@ -505,6 +505,21 @@
 
 sub ref { shift->refseq(@_) }
 
+=head2 seq_id
+
+ Title   : seq_id
+ Usage   : $ref = $s->seq_id
+ Function: get the reference sequence in a LocationI-compatible way
+ Returns : a string
+ Args    : none
+ Status  : Public
+
+An alias for refseq() but only allows reading.
+
+=cut
+
+sub seq_id { shift->ref }
+
 =head2 truncated
 
  Title   : truncated
diff -Naur bioperl-1.0/Bio/DB/GFF.pm bioperl-1.01/Bio/DB/GFF.pm
--- bioperl-1.0/Bio/DB/GFF.pm	Mon Feb 25 07:18:07 2002
+++ bioperl-1.01/Bio/DB/GFF.pm	Sun Mar 31 16:25:03 2002
@@ -1,6 +1,4 @@
-package Bio::DB::GFF;
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
-
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 =head1 NAME
 
 Bio::DB::GFF -- Storage and retrieval of sequence annotation data
@@ -440,6 +438,8 @@
 
 =cut
 
+package Bio::DB::GFF;
+
 use strict;
 
 use Bio::DB::GFF::Util::Rearrange;
@@ -451,7 +451,7 @@
 use vars qw($VERSION @ISA);
 @ISA = qw(Bio::Root::Root);
 
-$VERSION = '1.02';
+$VERSION = '1.03';
 my %valid_range_types = (overlaps     => 1,
 			 contains     => 1,
 			 contained_in => 1);
@@ -622,6 +622,27 @@
   $self->get_types($refseq,$refclass,$start,$stop,$enumerate,$types);
 }
 
+=head2 classes
+
+ Title   : classes
+ Usage   : $db->classes
+ Function: return list of landmark classes in database
+ Returns : a list of classes
+ Args    : none
+ Status  : public
+
+This routine returns the list of reference classes known to the
+database, or empty if classes are not used by the database.  Classes
+are distinct from types, being essentially qualifiers on the reference
+namespaces.
+
+=cut
+
+sub classes {
+  my $self = shift;
+  return ();
+}
+
 =head2 segment
 
  Title   : segment
@@ -755,8 +776,9 @@
   } elsif (wantarray) { # more than one reference sequence
     return @segments;
   } else {
-    $self->error($segments[0]->name," has more than one reference sequence in database.  Please call in a list context to retrieve them all.");
-    croak('multiple segment exception');
+    $self->error($segments[0]->name,
+		 " has more than one reference sequence in database.  Please call in a list context to retrieve them all.");
+    $self->throw('multiple segment exception');
     return;
   }
 }
@@ -1847,8 +1869,10 @@
     next unless defined($ref) && defined($method) && defined($start) && defined($stop);
 
     # handle group parsing
-    $group =~ s/\\;/$;/g;  # protect embedded semicolons in the group; this probably breaks
-    $group =~ s/( \"[^\"]*);([^\"]*\")/$1$;$2/g;
+    # protect embedded semicolons in the group; there must be faster/more elegant way
+    # to do this.
+    $group =~ s/\\;/$;/g;
+    while ($group =~ s/( \"[^\"]*);([^\"]*\")/$1$;$2/) { 1 }
     my @groups = split(/\s*;\s*/,$group);
     foreach (@groups) { s/$;/;/g }
 
@@ -2711,10 +2735,9 @@
 sub _features {
   my $self = shift;
   my ($search,$options,$parent) = @_;
-
   (@{$search}{qw(start stop)}) = (@{$search}{qw(stop start)})
     if defined($search->{start}) && $search->{start} > $search->{stop};
-
+  
   my $types = $self->parse_types($search->{types});  # parse out list of types
   my @aggregated_types = @$types;         # keep a copy
 
diff -Naur bioperl-1.0/Bio/DB/Makefile.PL bioperl-1.01/Bio/DB/Makefile.PL
--- bioperl-1.0/Bio/DB/Makefile.PL	Tue Jul 17 18:35:11 2001
+++ bioperl-1.01/Bio/DB/Makefile.PL	Wed Dec 31 19:00:00 1969
@@ -1,13 +0,0 @@
-use ExtUtils::MakeMaker;
-# See lib/ExtUtils/MakeMaker.pm for details of how to influence
-# the contents of the Makefile that is written.
-WriteMakefile(
-    'NAME'		=> 'Bio::DB::GFF',
-    'VERSION_FROM'	=> 'GFF.pm', # finds $VERSION
-    'PREREQ_PM'		=> { 'DBI'            => 1.0,
-			     'Bio::DB::Fasta' => 1.0,
-			   }, # e.g., Module::Name => 1.1
-    'LIBS'		=> [''], # e.g., '-lm'
-    'DEFINE'		=> '', # e.g., '-DHAVE_SOMETHING'
-    'INC'		=> '', # e.g., '-I/usr/include/other'
-);
diff -Naur bioperl-1.0/Bio/DB/WebDBSeqI.pm bioperl-1.01/Bio/DB/WebDBSeqI.pm
--- bioperl-1.0/Bio/DB/WebDBSeqI.pm	Wed Mar 13 11:37:05 2002
+++ bioperl-1.01/Bio/DB/WebDBSeqI.pm	Sat May  4 16:28:10 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::DB::WebDBSeqI
 #
@@ -369,7 +369,8 @@
 	    open(ERR, "<$tmpfile");
 	    while(<ERR>) { $self->debug($_);}
 	} 
-	$stream = new Bio::SeqIO('-format' => $ioformat,
+	$stream = new Bio::SeqIO('-verbose' => $self->verbose,
+				 '-format' => $ioformat,
 				 '-file'   => $tmpfile);
     } elsif( $self->retrieval_type =~ /io_string/i ) {
 	my ($resp) = $self->_request($request);
@@ -382,7 +383,8 @@
 	$self->postprocess_data('type'=> 'string',
 				'location' => $content);
         print STDERR "str is $$content\n" if ( $self->verbose > 0);
-	$stream = new Bio::SeqIO('-format' => $ioformat,
+	$stream = new Bio::SeqIO('-verbose' => $self->verbose,
+				 '-format' => $ioformat,
 				 '-fh'   => new IO::String($$content));
     } else { 
 	$self->throw("retrieval type " . $self->retrieval_type . 
diff -Naur bioperl-1.0/Bio/DasI.pm bioperl-1.01/Bio/DasI.pm
--- bioperl-1.0/Bio/DasI.pm	Mon Mar  4 17:16:22 2002
+++ bioperl-1.01/Bio/DasI.pm	Fri Apr 12 00:10:13 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::DasI
 #
@@ -104,11 +104,10 @@
 use strict;
 
 use vars qw(@ISA);
-use Bio::Root;
-use Carp;
+use Bio::Root::RootI;
 
 # Object preamble - inherits from Bio::Root;
-@ISA = qw(Bio::Root);
+@ISA = qw(Bio::Root::RootI);
 
 =head2 types
 
diff -Naur bioperl-1.0/Bio/Factory/MapFactoryI.pm bioperl-1.01/Bio/Factory/MapFactoryI.pm
--- bioperl-1.0/Bio/Factory/MapFactoryI.pm	Fri Dec 14 12:20:17 2001
+++ bioperl-1.01/Bio/Factory/MapFactoryI.pm	Sat May  4 16:28:11 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Factory::MapFactoryI
 #
@@ -83,14 +83,14 @@
  Title   : next_map
  Usage   : my $map = $factory->next_map;
  Function: Get a map from the factory
- Returns : Bio::Map::MapI
+ Returns : L<Bio::Map::MapI>
  Args    : none
 
 =cut
 
 sub next_map{
    my ($self,@args) = @_;
-   $self->_abstractDeath('next_map');
+   $self->throw_not_implemented();
 }
 
 =head2 write_map
@@ -99,13 +99,13 @@
  Usage   : $factory->write_map($map);
  Function: Write a map out through the factory
  Returns : none
- Args    : Bio::Map::MapI
+ Args    : L<Bio::Map::MapI>
 
 =cut
 
 sub write_map{
    my ($self,@args) = @_;
-   $self->_abstractDeath('write_map');
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Factory/SeqAnalysisParserFactory.pm bioperl-1.01/Bio/Factory/SeqAnalysisParserFactory.pm
--- bioperl-1.0/Bio/Factory/SeqAnalysisParserFactory.pm	Fri Jul 27 11:28:36 2001
+++ bioperl-1.01/Bio/Factory/SeqAnalysisParserFactory.pm	Sat May  4 16:28:11 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Factory::SeqAnalysisParserFactory
 #
@@ -71,7 +71,7 @@
 
 =head1 AUTHOR - Hilmar Lapp, Jason Stajich
 
-Email Hilmar Lapp E<lt>hlapp@gmx.netE<gt>, Jason Stajich E<lt>jason@chg.mc.duke.eduE<gt>
+Email Hilmar Lapp E<lt>hlapp@gmx.netE<gt>, Jason Stajich E<lt>jason@bioperl.orgE<gt>
 
 =head1 APPENDIX
 
diff -Naur bioperl-1.0/Bio/Factory/SeqAnalysisParserFactoryI.pm bioperl-1.01/Bio/Factory/SeqAnalysisParserFactoryI.pm
--- bioperl-1.0/Bio/Factory/SeqAnalysisParserFactoryI.pm	Sat Nov 24 16:49:27 2001
+++ bioperl-1.01/Bio/Factory/SeqAnalysisParserFactoryI.pm	Sat May  4 16:28:11 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Factory::SeqAnalysisParserFactoryI
 #
@@ -37,7 +37,7 @@
 
 The concept behind the interface is a generic analysis result parsing
 in high-throughput automated sequence annotation pipelines. See
-Bio::SeqAnalysisParserI for more documentation of this concept.
+L<Bio::SeqAnalysisParserI> for more documentation of this concept.
 
 =head1 FEEDBACK
 
@@ -62,7 +62,7 @@
 
 =head1 AUTHOR - Hilmar Lapp, Jason Stajich
 
-Email Hilmar Lapp E<lt>hlapp@gmx.netE<gt>, Jason Stajich E<lt>jason@chg.mc.duke.eduE<gt>
+Email Hilmar Lapp E<lt>hlapp@gmx.netE<gt>, Jason Stajich E<lt>jason@bioperl.orgE<gt>
 
 =head1 APPENDIX
 
@@ -107,7 +107,7 @@
 
 sub get_parser {
     my ( $self, @args) = @_;
-    $self->_abstractDeath('get_parser');
+    $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Factory/TreeFactoryI.pm bioperl-1.01/Bio/Factory/TreeFactoryI.pm
--- bioperl-1.0/Bio/Factory/TreeFactoryI.pm	Mon Dec 10 11:10:19 2001
+++ bioperl-1.01/Bio/Factory/TreeFactoryI.pm	Sat May  4 16:28:11 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Factory::TreeFactoryI
 #
@@ -31,7 +31,7 @@
 =head1 DESCRIPTION
 
 This interface describes the minimal functions needed to get and write
-trees from a data stream.  It is implemented by the Bio::TreeIO factory.
+trees from a data stream.  It is implemented by the L<Bio::TreeIO> factory.
 
 =head1 FEEDBACK
 
@@ -86,14 +86,14 @@
  Title   : next_tree
  Usage   : my $tree = $factory->next_tree;
  Function: Get a tree from the factory
- Returns : Bio::Tree::TreeI
+ Returns : L<Bio::Tree::TreeI>
  Args    : none
 
 =cut
 
 sub next_tree{
    my ($self,@args) = @_;
-   $self->_abstractDeath('next_tree');
+   $self->throw_not_implemented();
 }
 
 =head2 write_tree
@@ -102,14 +102,14 @@
  Usage   : $treeio->write_tree($tree);
  Function: Writes a tree onto the stream
  Returns : none
- Args    : Bio::Tree::TreeI
+ Args    : L<Bio::Tree::TreeI>
 
 
 =cut
 
 sub write_tree{
    my ($self,@args) = @_;
-   $self->_abstractDeath('write_tree');
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Graphics/Feature.pm bioperl-1.01/Bio/Graphics/Feature.pm
--- bioperl-1.0/Bio/Graphics/Feature.pm	Fri Mar 15 09:40:02 2002
+++ bioperl-1.01/Bio/Graphics/Feature.pm	Sat May  4 16:27:49 2002
@@ -1,15 +1,18 @@
 package Bio::Graphics::Feature;
 use strict;
+use Bio::SeqFeatureI;
+use Bio::LocationI;
 
-use vars '$VERSION';
-$VERSION = 1.2;
+use vars '$VERSION','@ISA';
+$VERSION = '1.40';
+@ISA  = qw(Bio::SeqFeatureI Bio::LocationI);
 
 *stop        = \&end;
 *info        = \&name;
 *seqname     = \&name;
 *type        = \&primary_tag;
 *exons       = *sub_SeqFeature = *merged_segments = \&segments;
-*class       = *method = \&type;
+*method      = \&type;
 *source      = \&source_tag;
 
 # usage:
@@ -29,16 +32,17 @@
   my $self = bless {},$class;
 
   $arg{-strand} ||= 0;
-  $self->{strand}  = $arg{-strand} >= 0 ? +1 : -1;
+  $self->{strand}  = $arg{-strand} ? ($arg{-strand} >= 0 ? +1 : -1) : 0;
   $self->{name}    = $arg{-name};
   $self->{type}    = $arg{-type}   || 'feature';
   $self->{subtype} = $arg{-subtype} if exists $arg{-subtype};
   $self->{source}  = $arg{-source} || $arg{-source_tag} || '';
-  $self->{score}   = $arg{-score}  || 0;
+  $self->{score}   = $arg{-score}   if exists $arg{-score};
   $self->{start}   = $arg{-start};
   $self->{stop}    = $arg{-end} || $arg{-stop};
   $self->{ref}     = $arg{-ref};
-  $self->{url}     = $arg{-url} if $arg{-url};
+  $self->{class}   = $arg{-class} if exists $arg{-class};
+  $self->{url}     = $arg{-url}   if exists $arg{-url};
 
   # fix start, stop
   if (defined $self->{stop} && defined $self->{start}
@@ -71,41 +75,22 @@
 	($start,$stop) = ($stop,$start);
 	$strand *= -1;
       }
-      push @segments,$self->new(-start=>$start,
-				-stop=>$stop,
-				-strand=>$strand,
-				-type  => $type);
+      push @segments,$self->new(-start  => $start,
+				-stop   => $stop,
+				-strand => $strand,
+				-type   => $type);
     } else {
       push @segments,$seg;
     }
   }
   if (@segments) {
+    local $^W = 0;  # some warning of an uninitialized variable...
     $self->{segments} = [ sort {$a->start <=> $b->start } @segments ];
     $self->{start}    = $self->{segments}[0]->start;
     ($self->{stop})   = sort { $b <=> $a } map { $_->end } @segments;
   }
 }
 
-sub location {
-  my $self = shift;
-
-  require Bio::Location::Split;
-  my @segments = $self->segments;
-  if (@segments) {
-    my $split = Bio::Location::Split->new;
-    foreach (@segments) {
-      $split->add_sub_Location(Bio::Location::Simple->new(-start  => $_->start,
-							  -end    => $_->end,
-							  -strand => $_->strand
-							 ));
-    }
-    return $split;
-  }
-  return Bio::Location::Simple->new(-start  => $self->start,
-				    -end    => $self->end,
-				    -strand => $self->strand);
-}
-
 sub segments {
   my $self = shift;
   my $s = $self->{segments} or return wantarray ? () : 0;
@@ -118,7 +103,13 @@
   $d;
 }
 sub primary_tag     { shift->{type}        }
-sub name            { shift->{name}        }
+sub name            {
+  my $self = shift;
+  my $d    = $self->{name};
+  $self->{name} = shift if @_;
+  $d;
+}
+sub seq_id          { shift->ref()         }
 sub ref {
   my $self = shift;
   my $d = $self->{ref};
@@ -137,7 +128,7 @@
   $self->{stop} = shift if @_;
   $d;
 }
-sub strand { 
+sub strand {
   my $self = shift;
   my $d = $self->{strand};
   $self->{strand} = shift if @_;
@@ -154,7 +145,92 @@
 }
 *dna = \&seq;
 
-sub source_tag { 
+sub low {
+  my $self = shift;
+  return $self->start < $self->end ? $self->start : $self->end;
+}
+
+sub high {
+  my $self = shift;
+  return $self->start > $self->end ? $self->start : $self->end;
+}
+
+=head2 location
+
+ Title   : location
+ Usage   : my $location = $seqfeature->location()
+ Function: returns a location object suitable for identifying location
+	   of feature on sequence or parent feature
+ Returns : Bio::LocationI object
+ Args    : none
+
+=cut
+
+sub location {
+   my $self = shift;
+   require Bio::Location::Split unless Bio::Location::Split->can('new');
+   my $location;
+   if (my @segments = $self->segments) {
+       $location = Bio::Location::Split->new();
+       foreach (@segments) {
+	 $location->add_sub_Location($_);
+       }
+   } else {
+       $location = $self;
+   }
+   $location;
+}
+
+sub coordinate_policy {
+   require Bio::Location::WidestCoordPolicy unless Bio::Location::WidestCoordPolicy->can('new');
+   return Bio::Location::WidestCoordPolicy->new();
+}
+
+sub min_start { shift->low }
+sub max_start { shift->low }
+sub min_end   { shift->high }
+sub max_end   { shift->high}
+sub start_pos_type { 'EXACT' }
+sub end_pos_type   { 'EXACT' }
+sub to_FTstring {
+  my $self = shift;
+  my $low  = $self->min_start;
+  my $high = $self->max_end;
+  return "$low..$high";
+}
+sub phase { undef }
+sub class {
+  my $self = shift;
+  my $d = $self->{class};
+  $self->{class} = shift if @_;
+  return defined($d) ? $d : ucfirst $self->method;
+}
+
+sub gff_string {
+  my $self = shift;
+  my $name  = $self->name;
+  my $class = $self->class;
+  my $group = "$class $name" if $name;
+  my $string;
+  $string .= join("\t",$self->ref,$self->source||'.',$self->method||'.',
+                       $self->start,$self->stop,
+                       $self->score||'.',$self->strand||'.',$self->phase||'.',
+                       $group);
+  $string .= "\n";
+  foreach ($self->sub_SeqFeature) {
+    # add missing data if we need it
+    $_->ref($self->ref)     unless defined $_->ref;
+    $_->name($self->name);
+    $_->class($self->class);
+    $string .= $_->gff_string;
+  }
+  $string;
+}
+
+
+sub db { return }
+
+sub source_tag {
   my $self = shift;
   my $d = $self->{source};
   $self->{source} = shift if @_;
@@ -168,6 +244,8 @@
   return;
 }
 
+sub has_tag { }
+
 # get/set the configurator (Bio::Graphics::FeatureFile) for this feature
 sub configurator {
   my $self = shift;
@@ -200,6 +278,7 @@
   }
 }
 
+sub DESTROY { }
 
 1;
 
@@ -281,11 +360,11 @@
 
 =item segments()
 
-An alias for sub_SeqFeatures().
+An alias for sub_SeqFeature().
 
 =item merged_segments()
 
-Another alias for sub_SeqFeatures().
+Another alias for sub_SeqFeature().
 
 =item stop()
 
@@ -297,7 +376,7 @@
 
 =item exons()
 
-An alias for sub_SeqFeatures() (you don't want to know why!)
+An alias for sub_SeqFeature() (you don't want to know why!)
 
 =back
 
diff -Naur bioperl-1.0/Bio/Graphics/FeatureFile.pm bioperl-1.01/Bio/Graphics/FeatureFile.pm
--- bioperl-1.0/Bio/Graphics/FeatureFile.pm	Fri Mar 15 09:40:02 2002
+++ bioperl-1.01/Bio/Graphics/FeatureFile.pm	Sat May  4 16:29:59 2002
@@ -1,11 +1,105 @@
 package Bio::Graphics::FeatureFile;
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 # This package parses and renders a simple tab-delimited format for features.
 # It is simpler than GFF, but still has a lot of expressive power.
+# See __END__ for the file format
 
-# Documentation is pending, but see __END__ for the file format, and eg/feature_draw.pl for an
-# example of usage.
+=head1 NAME
+
+Bio::Graphics::FeatureFile -- A set of Bio::Graphics features, stored in a file
+
+=head1 SYNOPSIS
+
+ use Bio::Graphics::FeatureFile;
+ my $data  = Bio::Graphics::FeatureFile->new(-file => 'features.txt');
+
+ # render contents of the file onto a Bio::Graphics::Panel in one step
+ $data->render($panel);
+
+ # for more control, render tracks individually
+ my @feature_types = $data->types;
+ for my $type (@feature_types) {
+    my $features = $data->features($type);
+    my %options  = $data->style($type);
+    $panel->add_track($features,%options);  # assuming we have a Bio::Graphics::Panel
+ }
+
+ # get individual settings
+ my $est_fg_color = $data->setting(EST => 'fgcolor');
+
+ # or create the FeatureFile by hand
+
+ # add a type
+ $data->add_type(EST => {fgcolor=>'blue',height=>12});
+
+ # add a feature
+ my $feature = Bio::Graphics::Feature->new(....); # or some other SeqI
+ $data->add_feature($feature=>'EST');
+
+=head1 DESCRIPTION
+
+The Bio::Graphics::FeatureFile module reads and parses files that
+describe sequence features and their renderings.  It accepts both GFF
+format and a more human-friendly file format described below.  Once a
+FeatureFile object has been initialized, you can interrogate it for
+its consistuent features and their settings, or render the entire file
+onto a Bio::Graphics::Panel.
+
+=head2 The File Format
+
+There are two types of entry in the file format: feature entries, and
+formatting entries.  They can occur in any order.  See the Appendix
+for a full example.
+
+Feature entries can take several forms.  At their simplest, they look
+like this:
+
+ Gene	B0511.1	516-11208
+
+This means that a feature of type "Gene" and name "B0511.1" occupies
+the range between bases 516 and 11208.  A range can be specified
+equally well using a hyphen, or two dots as in 516..11208.  Negative
+coordinates are allowed, such as -187..1000.
+
+A discontinuous range ("split location") uses commas to separate the
+ranges.  For example:
+
+ Gene B0511.1  516-619,3185-3294,10946-11208
+
+Alternatively, the locations can be split by repeating the features
+type and name on multiple adjacent lines:
+
+ Gene	B0511.1	516-619
+ Gene	B0511.1	3185-3294
+ Gene	B0511.1	10946-11208
+
+A comment can be added to features by adding a fourth column.  These
+comments will be rendered as under-the-glyph descriptions by those
+glyphs that honor descriptions:
+
+ Gene  B0511.1  516-619,3185-3294,10946-11208 "Putative primase"
+
+Columns are separated using whitespace, not (necessarily) tabs.
+Embedded whitespace can be escaped using quote marks or backslashes in
+the same way as in the shell:
+
+ 'Putative Gene' my\ favorite\ gene 516-11208
+
+Features can be grouped so that they are rendered by the "group" glyph
+(so far this has only been used to relate 5' and 3' ESTs).  To start a
+group, create a two-column feature entry showing the group type and a
+name for the group.  Follow this with a list of feature entries with a
+blank type.  For example:
+
+ EST	yk53c10
+ 	yk53c10.3	15000-15500,15700-15800
+ 	yk53c10.5	18892-19154
+
+This example is declaring that the ESTs named yk53c10.3 and yk53c10.5
+belong to the same group named yk53c10.  
+
+=cut
 
 use strict;
 use Bio::Graphics::Feature;
@@ -61,7 +155,7 @@
   } elsif (my $text = $args{-text}) {
     $self->parse_text($text);
   }
-  $fh->close or warn "Error closing file: $!" if $fh;
+  close($fh) or warn "Error closing file: $!" if $fh;
   $self;
 }
 
@@ -193,7 +287,7 @@
     ($type,$name,$bounds,$description,$url) = @tokens;
   }
 
-  $type ||= $self->{grouptype};
+  $type ||= $self->{grouptype} || '';
   $type =~ s/\s+$//;  # get rid of excess whitespace
 
   # the reference is specified by the GFF reference line first,
@@ -218,38 +312,83 @@
     return unless $ref;
   }
 
+  $type = '' unless defined $type;
+  $name = '' unless defined $name;
+
   # either create a new feature or add a segment to it
   if (my $feature = $self->{seenit}{$type,$name}) {
     $feature->add_segment(@parts);
   } else {
-    $feature = $self->{seenit}{$type,$name} = Bio::Graphics::Feature->new(-name     => $name,
-									  -type     => $type,
-									  $strand ? (-strand   => make_strand($strand))
-                                                                                  : (),
-									  -segments => \@parts,
-									  -source   => $description,
-									  -ref      => $ref,
-									  -url      => $url,
-									 );
+    $feature = $self->{seenit}{$type,$name} = 
+      Bio::Graphics::Feature->new(-name     => $name,
+				  -type     => $type,
+				  $strand ? (-strand   => make_strand($strand)) : (),
+				  -segments => \@parts,
+				  -source   => $description,
+				  -ref      => $ref,
+				  defined($url) ? (-url      => $url) : (),
+				 );
     $feature->configurator($self) if $self->smart_features;
     if ($self->{grouptype}) {
       push @{$self->{groups}{$self->{grouptype}}{$self->{groupname}}},$feature;
     } else {
-      push @{$self->{features}{$type}},$feature;
+      push @{$self->{features}{$type}},$feature;  # for speed; should use add_feature() instead
     }
   }
 }
 
+# add a feature of given type to our list
+# we use the primary_tag() method
+sub add_feature {
+  my $self = shift;
+  my ($feature,$type) = @_;
+  $type = $feature->primary_tag unless defined $type;
+  push @{$self->{features}{$type}},$feature;
+}
+
+# Add a type to the list.  Hash values are used for key/value pairs
+# in the configuration.  Call as add_type($type,$configuration) where
+# $configuration is a hashref.
+sub add_type {
+  my $self = shift;
+  my ($type,$type_configuration) = @_;
+  my $cc = $type =~ /^(general|default)$/i ? 'general' : $type;  # normalize
+  push @{$self->{types}},$cc unless $cc eq 'general' or $self->{config}{$cc};
+  if (defined $type_configuration) {
+    for my $tag (keys %$type_configuration) {
+      $self->{config}{$cc}{lc $tag} = $type_configuration->{$tag};
+    }
+  }
+}
+
+# change configuration of a type.  Call as set($type,$tag,$value)
+# $type will be added if not already there.
+sub set {
+  my $self = shift;
+  croak("Usage: \$featurefile->set(\$type,\$tag,\$value\n")
+    unless @_ == 3;
+  my ($type,$tag,$value) = @_;
+  unless ($self->{config}{$type}) {
+    return $self->add_type($type,{$tag=>$value});
+  } else {
+    $self->{config}{$type}{lc $tag} = $value;
+  }
+}
+
 # break circular references
 sub destroy {
   my $self = shift;
   delete $self->{features};
 }
 
+sub DESTROY { shift->destroy(@_) }
+
 # return configuration information
+# arguments are ($type) => returns tags for type
+#               ($type=>$tag) => returns values of tag on type
 sub setting {
   my $self = shift;
-  my $config = $self->{config} or return; 
+  my $config = $self->{config} or return;
   return keys %{$config} unless @_;
   return keys %{$config->{$_[0]}} if @_ == 1;
   return $config->{$_[0]}{$_[1]}  if @_ > 1;
@@ -413,10 +552,14 @@
 
   my @base_config = $self->style('general');
 
-  $options ||= 0;
   my @override = ();
-  push @override,(-bump => 1) if $options >= 1;
-  push @override,(-label =>1) if $options >= 2;
+  if ($options && ref $options eq 'HASH') {
+    @override = %$options;
+  } else {
+    $options ||= 0;
+    push @override,(-bump => 1) if $options >= 1;
+    push @override,(-label =>1) if $options >= 2;
+  }
 
   for my $type (@configured_types,@unconfigured_types) {
     my @config = ( -glyph   => 'segments',         # really generic
@@ -472,7 +615,12 @@
   $self->{stat} = [stat($fh)];
 }
 
-sub mtime { shift->{stat}->[9];  }
+sub mtime {
+  my $self = shift;
+  my $d = $self->{m_time} || $self->{stat}->[9];
+  $self->{m_time} = shift if @_;
+  $d;
+}
 sub atime { shift->{stat}->[8];  }
 sub ctime { shift->{stat}->[10]; }
 sub size  { shift->{stat}->[7];  }
@@ -555,22 +703,13 @@
 
 __END__
 
-=head1 NAME
-
-Bio::Graphics::FeatureFile - Parse a simple feature file format into a form suitable for rendering
-
-=head1 SYNOPSIS
-
-This package parses and renders a simple tab-delimited format for features.
-It is simpler than GFF, but still has a lot of expressive power.
-
-Documentation is pending, but see the file format here, and eg/feature_draw.pl for an
-example of usage.
+=head1 Appendix -- Sample Feature File
 
  # file begins
  [general]
  pixels = 1024
  bases = 1-20000
+ reference = Contig41
  height = 12
 
  [Cosmid]
@@ -589,34 +728,25 @@
  bgcolor = green
  description = 1
 
- Cosmid	B0511	+	516-619
- Cosmid	B0511	+	3185-3294
- Cosmid	B0511	+	10946-11208
- Cosmid	B0511	+	13126-13511
- Cosmid	B0511	+	11394-11539
- Cosmid	B0511	+	14383-14490
- Cosmid	B0511	+	15569-15755
- Cosmid	B0511	+	18879-19178
- Cosmid	B0511	+	15850-16110
- Cosmid	B0511	+	66-208
- Cosmid	B0511	+	6354-6499
- Cosmid	B0511	+	13955-14115
- Cosmid	B0511	+	7985-8042
- Cosmid	B0511	+	11916-12046
- EST	yk260e10.5	+	15569-15724
- EST	yk672a12.5	+	537-618,3187-3294
- EST	yk595e6.5	+	552-618
- EST	yk595e6.5	+	3187-3294
- EST	yk846e07.3	+	11015-11208
+ Cosmid	B0511	516-619
+ Cosmid	B0511	3185-3294
+ Cosmid	B0511	10946-11208
+ Cosmid	B0511	13126-13511
+ Cosmid	B0511	11394-11539
+ EST	yk260e10.5	15569-15724
+ EST	yk672a12.5	537-618,3187-3294
+ EST	yk595e6.5	552-618
+ EST	yk595e6.5	3187-3294
+ EST	yk846e07.3	11015-11208
  EST	yk53c10
- 	yk53c10.3	+	15000-15500,15700-15800
- 	yk53c10.5	+	18892-19154
- EST	yk53c10.5	+	16032-16105
- SwissProt	PECANEX	+	13153-13656	Swedish fish
- FGENESH	Predicted gene 1	-	1-205,518-616,661-735,3187-3365,3436-3846	Pfam domain
- FGENESH	Predicted gene 2	+	5513-6497,7968-8136,8278-8383,8651-8839,9462-9515,10032-10705,10949-11340,11387-11524,11765-12067,12876-13577,13882-14121,14169-14535,15006-15209,15259-15462,15513-15753,15853-16219	Mysterious
- FGENESH	Predicted gene 3	-	16626-17396,17451-17597
- FGENESH	Predicted gene 4	+	18459-18722,18882-19176,19221-19513,19572-19835	Transmembrane protein
+ 	yk53c10.3	15000-15500,15700-15800
+ 	yk53c10.5	18892-19154
+ EST	yk53c10.5	16032-16105
+ SwissProt	PECANEX	13153-13656	Swedish fish
+ FGENESH	Predicted gene 1	1-205,518-616,661-735,3187-3365,3436-3846	Pfam domain
+ FGENESH	Predicted gene 2	5513-6497,7968-8136,8278-8383,8651-8839,9462-9515,10032-10705,10949-11340,11387-11524,11765-12067,12876-13577,13882-14121,14169-14535,15006-15209,15259-15462,15513-15753,15853-16219	Mysterious
+ FGENESH	Predicted gene 3	16626-17396,17451-17597
+ FGENESH	Predicted gene 4	18459-18722,18882-19176,19221-19513,19572-19835	Transmembrane protein
  # file ends
 
 =head1 SEE ALSO
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/Factory.pm bioperl-1.01/Bio/Graphics/Glyph/Factory.pm
--- bioperl-1.0/Bio/Graphics/Glyph/Factory.pm	Tue Mar  5 14:20:29 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/Factory.pm	Sat May  4 16:27:40 2002
@@ -61,7 +61,8 @@
 
 # create a glyph
 sub make_glyph {
-  my $self = shift;
+  my $self  = shift;
+  my $level = shift;
   my @result;
   my $panel = $self->panel;
   my ($leftmost,$rightmost) = ($panel->left,$panel->right);
@@ -78,12 +79,14 @@
 	unless (eval "require $glyphclass");
     }
     my $glyph = $glyphclass->new(-feature  => $f,
-				 -factory  => $self);
+				 -factory  => $self,
+				 -level    => $level);
 
     # this is removing glyphs that are not onscreen at all.
     # But never remove tracks!
     push @result,$glyph if $type eq 'track'
-      || ($glyph->{left} + $glyph->{width} > $leftmost && $glyph->{left} < $rightmost);
+	|| ($glyph->{left} + $glyph->{width} > $leftmost && $glyph->{left} < $rightmost);
+
   }
   return wantarray ? @result : $result[0];
 }
@@ -123,7 +126,7 @@
       my $feature = $glyph->feature;
       return $value unless ref $value eq 'CODE';
       return unless $feature->isa('Bio::SeqFeatureI');
-      my $val = $value->($feature,$option_name,$partno,$total_parts);
+      my $val = $value->($feature,$option_name,$partno,$total_parts,$glyph);
       return defined $val && $val eq '*default*' ? $GENERIC_OPTIONS{$option_name} : $val;
     }
   }
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/anchored_arrow.pm bioperl-1.01/Bio/Graphics/Glyph/anchored_arrow.pm
--- bioperl-1.0/Bio/Graphics/Glyph/anchored_arrow.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/anchored_arrow.pm	Sat May  4 16:27:40 2002
@@ -50,10 +50,10 @@
   my $pstart  = $self->panel->left;
   my $pend    = $self->panel->right-1;
 
-  if ($gstart < $pstart) {  # off left end
+  if ($gstart <= $pstart) {  # off left end
     $sw = 1;
   }
-  if ($gend > $pend) { # off right end
+  if ($gend >= $pend) { # off right end
     $ne = 1;
   }
   return ($sw,$ne,!$sw,!$ne);
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/arrow.pm bioperl-1.01/Bio/Graphics/Glyph/arrow.pm
--- bioperl-1.0/Bio/Graphics/Glyph/arrow.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/arrow.pm	Sat May  4 16:27:40 2002
@@ -92,7 +92,7 @@
     my $stop     = $start + $self->feature->length - 1;
 
     my $offset   = $relative ? $self->feature->start-1 : 0;
-    my $reversed = $self->feature->strand < 0;
+    my $reversed = $relative && $self->feature->strand;
 
     my $units    = $self->option('units') || $self->calculate_units($start,$self->feature->length);
     my $divisor  = $UNITS{$units} || 1;
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/diamond.pm bioperl-1.01/Bio/Graphics/Glyph/diamond.pm
--- bioperl-1.0/Bio/Graphics/Glyph/diamond.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/diamond.pm	Sat May  4 16:27:40 2002
@@ -16,12 +16,20 @@
   my $ymid = ($y1+$y2)/2;
 
   my $h = $self->option('height')/2;
-  $x1 = $xmid - $h;
-  $x2 = $xmid + $h;
   $y1 = $ymid - $h;
   $y2 = $ymid + $h;
 
-  # now draw the diamond
+  # if it's a point-like feature, then draw symmetrically
+  # around the midpoing
+  if ($self->option('point') || $x2 - $x1 < $h*2) {
+    $x1 = $xmid - $h;
+    $x2 = $xmid + $h;
+  }
+
+  elsif ($self->option('fallback_to_rectangle')) {
+    return $self->SUPER::draw_component($gd,@_);
+  }
+
   $gd->line($x1,$ymid,$xmid,$y1,$fg);
   $gd->line($xmid,$y1,$x2,$ymid,$fg);
   $gd->line($x2,$ymid,$xmid,$y2,$fg);
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/group.pm bioperl-1.01/Bio/Graphics/Glyph/group.pm
--- bioperl-1.0/Bio/Graphics/Glyph/group.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/group.pm	Sat May  4 16:27:40 2002
@@ -16,6 +16,15 @@
 # we don't label group (yet)
 sub label { 0 }
 
+sub new {
+  my $self = shift->SUPER::new(@_);
+  # reset our parts to level zero
+  foreach (@{$self->{parts}}) {
+    $_->{level} = 0;
+  }
+  $self;
+}
+
 #sub layout_width {
 #  my $self = shift;
 #  my @parts = $self->parts or return $self->SUPER::layout_width;
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/segmented_keyglyph.pm bioperl-1.01/Bio/Graphics/Glyph/segmented_keyglyph.pm
--- bioperl-1.0/Bio/Graphics/Glyph/segmented_keyglyph.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/segmented_keyglyph.pm	Sat May  4 16:29:59 2002
@@ -1,6 +1,6 @@
 package Bio::Graphics::Glyph::segmented_keyglyph;
 
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 # Don't use this package.  It's just for inheriting the segmented glyph in the panel key.
 
 use strict;
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/segments.pm bioperl-1.01/Bio/Graphics/Glyph/segments.pm
--- bioperl-1.0/Bio/Graphics/Glyph/segments.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/segments.pm	Sat May  4 16:27:40 2002
@@ -1,18 +1,14 @@
 package Bio::Graphics::Glyph::segments;
 
 use strict;
+use Bio::Location::Simple;
 use Bio::Graphics::Glyph::generic;
 use Bio::Graphics::Glyph::segmented_keyglyph;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
 @ISA = qw( Bio::Graphics::Glyph::segmented_keyglyph
 	   Bio::Graphics::Glyph::generic
 	 );
-
-#sub pad_right {
-#  my $self = shift;
-#  my @parts = $self->parts or return $self->SUPER::pad_right;
-#  $parts[-1]->pad_right;
-#}
+$VERSION = '1.00';
 
 # group sets connector to 'solid'
 sub connector {
@@ -20,7 +16,7 @@
   return $self->SUPER::connector(@_) if $self->all_callbacks;
   return $self->SUPER::connector(@_) || 'solid';
 }
-# group sets connector to 'solid'
+# never allow our components to bump
 sub bump {
   my $self = shift;
   return $self->SUPER::bump(@_) if $self->all_callbacks;
@@ -28,15 +24,35 @@
 }
 sub label {
   my $self = shift;
-  return $self->SUPER::label(@_) if $self->all_callbacks || !$self->is_recursive;
-  return unless $self->subseq($self->feature);
+  return $self->SUPER::label(@_) if $self->all_callbacks;
+  return unless $self->{level} == 0;
   return $self->SUPER::label(@_);
 }
 sub description {
   my $self = shift;
-  return $self->SUPER::description(@_) if $self->all_callbacks || !$self->is_recursive;
-  return unless $self->subseq($self->feature);
+  return $self->SUPER::description(@_) if $self->all_callbacks;
+  return unless $self->{level} == 0;
   return $self->SUPER::description(@_);
+}
+
+# Override _subseq() method to make it appear that a top-level feature that
+# has no subfeatures appears as a feature that has a single subfeature.
+# Otherwise at high mags gaps will be drawn as components rather than
+# as connectors.  Because of differing representations of split features
+# in Bio::DB::GFF::Feature and Bio::SeqFeature::Generic, there is
+# some breakage of encapsulation here.
+sub _subseq {
+  my $self    = shift;
+  my $feature = shift;
+  my @subseq  = $self->SUPER::_subseq($feature);
+  return @subseq if @subseq;
+  if ($self->level == 0 && !@subseq && !eval{$feature->compound}) {
+    my($start,$end) = ($feature->start,$feature->end);
+    ($start,$end) = ($end,$start) if $start > $end; # to keep Bio::Location::Simple from bitching
+    return Bio::Location::Simple->new(-start=>$start,-end=>$end);
+  } else {
+    return;
+  }
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/track.pm bioperl-1.01/Bio/Graphics/Glyph/track.pm
--- bioperl-1.0/Bio/Graphics/Glyph/track.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/track.pm	Sat May  4 16:27:40 2002
@@ -12,11 +12,14 @@
   return 'none';
 }
 
-#sub draw {
-#  my $self = shift;
-#  my ($gd,$left,$top,$partno,$total_parts) = @_;
-#  $self->SUPER::draw(@_);
-#}
+sub draw {
+  my $self = shift;
+  my ($gd,$left,$top,$partno,$total_parts) = @_;
+  my @parts = $self->parts;
+  for (my $i=0; $i<@parts; $i++) {
+    $parts[$i]->draw($gd,$left,$top,0,1);
+  }
+}
 
 # do nothing for components
 # sub draw_component { }
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/transcript.pm bioperl-1.01/Bio/Graphics/Glyph/transcript.pm
--- bioperl-1.0/Bio/Graphics/Glyph/transcript.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/transcript.pm	Sat May  4 16:29:59 2002
@@ -1,16 +1,15 @@
 package Bio::Graphics::Glyph::transcript;
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 use strict;
-use Bio::Graphics::Glyph::generic;
-use Bio::Graphics::Glyph::segmented_keyglyph;
+use Bio::Graphics::Glyph::segments;
 use vars '@ISA';
-@ISA = qw( Bio::Graphics::Glyph::segmented_keyglyph
-	   Bio::Graphics::Glyph::generic
-	 );
+@ISA = qw( Bio::Graphics::Glyph::segments);
 
 sub pad_left  {
   my $self = shift;
   my $pad  = $self->SUPER::pad_left;
+  return $pad if $self->{level} > 0;
   return $pad unless $self->feature->strand < 0;
   return $self->arrow_length > $pad ? $self->arrow_length : $pad;
 }
@@ -18,17 +17,32 @@
 sub pad_right {
   my $self = shift;
   my $pad  = $self->SUPER::pad_right;
+  return $pad if $self->{level} > 0;
   return $pad unless $self->feature->strand > 0;
   return $self->arrow_length > $pad ? $self->arrow_length : $pad;
 }
 
+sub draw_component {
+  my $self = shift;
+  return unless $self->level > 0;
+  $self->SUPER::draw_component(@_);
+}
+
 sub draw_connectors {
   my $self = shift;
   my $gd = shift;
   my ($left,$top) = @_;
   $self->SUPER::draw_connectors($gd,$left,$top);
   my @parts = $self->parts;
-  @parts = $self unless @parts;
+
+  # H'mmm.  No parts.  Must be in an intron, so draw intron
+  # spanning entire range
+  if (!@parts) {
+    my($x1,$y1,$x2,$y2) = $self->bounds(0,0);
+    $self->_connector($gd,$left,$top,$x1,$y1,$x1,$y2,$x2,$y1,$x2,$y2);
+    @parts = $self;
+  }
+
   if ($self->feature->strand >= 0) {
     my($x1,$y1,$x2,$y2) = $parts[-1]->bounds(@_);
     my $center = ($y2+$y1)/2;
@@ -52,25 +66,6 @@
   return 'hat';
 }
 
-sub bump {
-  my $self = shift;
-  return $self->SUPER::bump(@_) if $self->all_callbacks;
-  return 0;  # never allow our components to bump
-}
-
-sub label {
-  my $self = shift;
-  return $self->SUPER::label(@_) if $self->all_callbacks || !$self->is_recursive;
-  return unless $self->subseq($self->feature);
-  return $self->SUPER::label(@_);
-}
-
-sub description {
-  my $self = shift;
-  return $self->SUPER::description(@_) if $self->all_callbacks || !$self->is_recursive;
-  return unless $self->subseq($self->feature);
-  return $self->SUPER::description(@_);
-}
 
 1;
 
diff -Naur bioperl-1.0/Bio/Graphics/Glyph/transcript2.pm bioperl-1.01/Bio/Graphics/Glyph/transcript2.pm
--- bioperl-1.0/Bio/Graphics/Glyph/transcript2.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Glyph/transcript2.pm	Sat May  4 16:29:59 2002
@@ -1,9 +1,12 @@
 package Bio::Graphics::Glyph::transcript2;
 
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+
 use strict;
 use Bio::Graphics::Glyph::transcript;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
 @ISA = 'Bio::Graphics::Glyph::transcript';
+$VERSION = '1.2';
 
 use constant MIN_WIDTH_FOR_ARROW => 8;
 
@@ -11,25 +14,28 @@
   my $self = shift;
   my $pad = $self->Bio::Graphics::Glyph::generic::pad_left;
   return $pad unless $self->feature->strand < 0;
-  my $first = ($self->parts)[0] or return $pad;
+  my $first = ($self->parts)[0] || $self;
   my @rect  = $first->bounds();
   my $width = abs($rect[2] - $rect[0]);
   return $self->SUPER::pad_left if $width < MIN_WIDTH_FOR_ARROW;
-  return 0;
+  return $pad;
 }
 
 sub pad_right  {
   my $self = shift;
   my $pad = $self->Bio::Graphics::Glyph::generic::pad_right;
-  my $last = ($self->parts)[-1] or return $pad;
+  return $pad if $self->{level} > 0;
+  my $last = ($self->parts)[-1] || $self;
   my @rect  = $last->bounds();
   my $width = abs($rect[2] - $rect[0]);
   return $self->SUPER::pad_right if $width < MIN_WIDTH_FOR_ARROW;
-  return $pad;
+  return $pad
 }
 
 sub draw_component {
   my $self = shift;
+  return unless $self->level > 0;
+
   my $gd = shift;
   my ($left,$top) = @_;
   my @rect = $self->bounds(@_);
@@ -40,16 +46,14 @@
   if ($filled) {
     my $f = $self->feature;
 
-    if ($f->strand < 0 
-	&& (!$self->is_recursive
-	 || $self->{partno} == 0)) { # first exon, minus strand transcript
+    if ($f->strand < 0
+	&& 
+	$self->{partno} == 0) { # first exon, minus strand transcript
       $self->filled_arrow($gd,-1,@rect);
-      $self->{filled}++;
-    } elsif ($f->strand >= 0 
-	     && (!$self->is_recursive
-		 || $self->{partno} == $self->{total_parts}-1)) { # last exon, plus strand
+    } elsif ($f->strand >= 0
+	     &&
+	     $self->{partno} == $self->{total_parts}-1) { # last exon, plus strand
       $self->filled_arrow($gd,+1,@rect);
-      $self->{filled}++;
     } else {
       $self->SUPER::draw_component($gd,@_);
     }
@@ -68,8 +72,22 @@
 
 sub draw_connectors {
   my $self = shift;
-  my @parts = $self->parts;
-  if ($self->{filled} || $parts[0]->{filled} || $parts[-1]->{filled}) {
+  my ($gd,$dx,$dy) = @_;
+
+  my $part;
+  if (my @parts  = $self->parts) {
+    $part   = $self->feature->strand > 0 ? $parts[-1] : $parts[0];
+  } else {
+    # no parts -- so draw an intron spanning whole thing
+    my($x1,$y1,$x2,$y2) = $self->bounds(0,0);
+    $self->_connector($gd,$dx,$dy,$x1,$y1,$x1,$y2,$x2,$y1,$x2,$y2);
+    $part = $self;
+  }
+  my @rect   = $part->bounds();
+  my $width  = abs($rect[2] - $rect[0]);
+  my $filled = $width >= MIN_WIDTH_FOR_ARROW;
+
+  if ($filled) {
     $self->Bio::Graphics::Glyph::generic::draw_connectors(@_);
   } else {
     $self->SUPER::draw_connectors(@_);
diff -Naur bioperl-1.0/Bio/Graphics/Glyph.pm bioperl-1.01/Bio/Graphics/Glyph.pm
--- bioperl-1.0/Bio/Graphics/Glyph.pm	Fri Mar 15 09:40:02 2002
+++ bioperl-1.01/Bio/Graphics/Glyph.pm	Sat May  4 16:27:49 2002
@@ -4,6 +4,8 @@
 use strict;
 use Carp 'croak';
 use constant BUMP_SPACING => 2; # vertical distance between bumped glyphs
+use vars '$VERSION';
+$VERSION = '1.01';
 
 my %LAYOUT_COUNT;
 
@@ -19,10 +21,12 @@
 
   my $feature = $arg{-feature} or die "No feature";
   my $factory = $arg{-factory} || $class->default_factory;
+  my $level   = $arg{-level} || 0;
 
   my $self = bless {},$class;
   $self->{feature} = $feature;
   $self->{factory} = $factory;
+  $self->{level}   = $level;
   $self->{top} = 0;
 
   my @subglyphs;
@@ -31,7 +35,7 @@
   if (@subfeatures) {
 
     # dynamic glyph resolution
-    @subglyphs = sort { $a->left  <=> $b->left }  $factory->make_glyph(@subfeatures);
+    @subglyphs = sort { $a->left  <=> $b->left }  $factory->make_glyph($level+1,@subfeatures);
 
     $self->{parts}   = \@subglyphs;
   }
@@ -112,7 +116,7 @@
     if (ref $feature eq 'ARRAY') {
       $self->add_group(@$feature);
     } else {
-      push @{$self->{parts}},$factory->make_glyph($feature);
+      push @{$self->{parts}},$factory->make_glyph(0,$feature);
     }
   }
 }
@@ -341,7 +345,7 @@
 # we also look for the "background-color" option for Ace::Graphics compatibility
 sub bgcolor {
   my $self = shift;
-  my $index = $self->option('fillcolor') || $self->option('bgcolor') || return 0;
+  my $index = $self->option('bgcolor') || $self->option('fillcolor') || return 0;
   $self->factory->translate_color($index);
 }
 sub font {
@@ -443,6 +447,7 @@
   if (my @parts = $self->parts) {
     my $x = $left;
     my $y = $top  + $self->top + $self->pad_top;
+    $self->draw_connectors($gd,$x,$y) if $connector && $connector ne 'none';
 
     my $last_x;
     for (my $i=0; $i<@parts; $i++) {
@@ -453,16 +458,21 @@
       $parts[$i]->draw($gd,$fake_x,$y,$i,scalar(@parts));
       $last_x = $parts[$i]->right;
     }
-    $self->draw_connectors($gd,$x,$y) if $connector && $connector ne 'none';
   }
 
   else {  # no part
-    $self->draw_component($gd,$left,$top);
     $self->draw_connectors($gd,$left,$top)
-      if $connector && $connector ne 'none' && !$self->is_recursive;
+      if $connector && $connector ne 'none' && $self->{level} == 0;
+    $self->draw_component($gd,$left,$top);
   }
 }
 
+# the "level" is the level of testing of the glyph
+# groups are level -1, top level glyphs are level 0, subcomponents are level 1 and so forth.
+sub level {
+  shift->{level};
+}
+
 sub draw_connectors {
   my $self = shift;
   my $gd = shift;
@@ -473,7 +483,7 @@
   }
 
   # extra connectors going off ends
-  if (@parts>1) {
+  if (@parts) {
     my($x1,$y1,$x2,$y2) = $self->bounds(0,0);
     my($xl,$xt,$xr,$xb) = $parts[0]->bounds;
     $self->_connector($gd,$dx,$dy,$x1,$xt,$x1,$xb,$xl,$xt,$xr,$xb);
@@ -485,19 +495,24 @@
 
 sub _connector {
   my $self = shift;
-  my ($gd,$dx,$dy,$xl,$xt,$xr,$xb,$yl,$yt,$yr,$yb) = @_;
-    my $left   = $dx + $xr;
-    my $right  = $dx + $yl;
-    my $top1     = $dy + $xt;
-    my $bottom1  = $dy + $xb;
-    my $top2     = $dy + $yt;
-    my $bottom2  = $dy + $yb;
-    return unless $right-$left > 1;
-
-    $self->draw_connector($gd,
-			  $top1,$bottom1,$left,
-			  $top2,$bottom2,$right,
-			 );
+  my ($gd,
+      $dx,$dy,
+      $xl,$xt,$xr,$xb,
+      $yl,$yt,$yr,$yb) = @_;
+  my $left   = $dx + $xr;
+  my $right  = $dx + $yl;
+  my $top1     = $dy + $xt;
+  my $bottom1  = $dy + $xb;
+  my $top2     = $dy + $yt;
+  my $bottom2  = $dy + $yb;
+  # restore this comment if you don't like the group dash working
+  # its way backwards.
+  #    return unless $right-$left > 1;
+
+  $self->draw_connector($gd,
+			$top1,$bottom1,$left,
+			$top2,$bottom2,$right,
+		       );
 }
 
 sub draw_connector {
@@ -506,6 +521,7 @@
 
   my $color          = $self->connector_color;
   my $connector_type = $self->connector or return;
+
   if ($connector_type eq 'hat') {
     $self->draw_hat_connector($gd,$color,@_);
   } elsif ($connector_type eq 'solid') {
@@ -653,16 +669,16 @@
     $gd->line($x2,($y2+$y1)/2,$x2-$indent,$y2,$fg);
     $gd->line($x2-$indent,$y2,$x1,$y2,$fg);
     $gd->line($x1,$y2,$x1,$y1,$fg);
-    $gd->fillToBorder($x1+1,($y1+$y2)/2,$fg,$self->bgcolor);
+    my $left = $self->panel->left > $x1 ? $self->panel->left : $x1;
+    $gd->fillToBorder($left+1,($y1+$y2)/2,$fg,$self->bgcolor);
   } else {
     $gd->line($x1,($y2+$y1)/2,$x1+$indent,$y1,$fg);
     $gd->line($x1+$indent,$y1,$x2,$y1,$fg);
     $gd->line($x2,$y2,$x1+$indent,$y2,$fg);
     $gd->line($x1+$indent,$y2,$x1,($y1+$y2)/2,$fg);
     $gd->line($x2,$y1,$x2,$y2,$fg);
-    if ($x2 > 0 && $x2<=$self->panel->right) {
-       $gd->fillToBorder($x2-1,($y1+$y2)/2,$fg,$self->bgcolor);
-    }
+    my $right = $self->panel->right < $x2 ? $self->panel->right : $x2;
+    $gd->fillToBorder($right-1,($y1+$y2)/2,$fg,$self->bgcolor);
   }
 }
 
@@ -723,9 +739,9 @@
   my $feature = shift;
   return $feature->merged_segments         if $feature->can('merged_segments');
   return $feature->segments                if $feature->can('segments');
-  my @split = eval { my $id = $feature->location->seq_id;
+  my @split = eval { my $id   = $feature->location->seq_id;
 		     my @subs = $feature->location->sub_Location;
-		     grep {$id eq $_->seq_id} $feature->location->sub_Location};
+		     grep {$id eq $_->seq_id} @subs};
   return @split if @split;
   return $feature->sub_SeqFeature          if $feature->can('sub_SeqFeature');
   return;
@@ -739,7 +755,7 @@
   $factory->set_option(label => 1);
   $factory->set_option(bump  => 0);
   $factory->set_option(connector  => 'solid');
-  return $factory->make_glyph($feature);
+  return $factory->make_glyph(0,$feature);
 }
 
 # synthesize a key glyph
@@ -764,23 +780,13 @@
   my $self = shift;
   my $track_level = $self->option('all_callbacks');
   return $track_level if defined $track_level;
-  return $self->panel->all_callbacks; 
+  return $self->panel->all_callbacks;
 }
 
 sub default_factory {
   croak "no default factory implemented";
 }
 
-# This returns true if the underlying feature is fully recursive, like Bio::DB::GFF or
-# Gadfly, false if the underlying feature has split locations, like Bio::Seq::RichSeq.
-# Play with this if you start getting labels appearing on each element of a segmented
-# glyph.
-sub is_recursive {
-  my $self = shift;
-  return $self->{_recursive} if exists $self->{_recursive};
-  return $self->{_recursive} = !$self->feature->isa('Bio::SeqFeature::Generic');
-}
-
 1;
 
 __END__
@@ -920,6 +926,12 @@
 =item $index = $glyph-E<gt>color($color)
 
 Given a symbolic or #RRGGBB-form color name, returns its GD index.
+
+=item $level = $glyph-E<gt>level
+
+The "level" is the nesting level of the glyph.
+Groups are level -1, top level glyphs are level 0,
+subparts (e.g. exons) are level 1 and so forth.
 
 =back
 
diff -Naur bioperl-1.0/Bio/Graphics/Panel.pm bioperl-1.01/Bio/Graphics/Panel.pm
--- bioperl-1.0/Bio/Graphics/Panel.pm	Fri Mar 15 09:40:03 2002
+++ bioperl-1.01/Bio/Graphics/Panel.pm	Sat May  4 16:27:49 2002
@@ -7,7 +7,7 @@
 use GD;
 use vars '$VERSION';
 
-$VERSION = '0.99';
+$VERSION = '1.01';
 
 use constant KEYLABELFONT => gdMediumBoldFont;
 use constant KEYSPACING   => 5; # extra space between key columns
@@ -221,15 +221,15 @@
   my $panel_map = ref($map) eq 'CODE'
     ?  sub {
           my $feature = shift;
-	  return 'track' if eval { $feature->primary_tag } eq 'track';
-	  return 'group' if eval { $feature->primary_tag } eq 'group';
+	  return 'track' if eval { $feature->primary_tag  eq 'track' };
+	  return 'group' if eval { $feature->primary_tag  eq 'group' };
 	  return $map->($feature);
 	}
       :
 	sub {
 	  my $feature = shift;
-	  return 'track' if eval { $feature->primary_tag } eq 'track';
-	  return 'group' if eval { $feature->primary_tag } eq 'group';
+	  return 'track' if eval { $feature->primary_tag  eq 'track' };
+	  return 'group' if eval { $feature->primary_tag  eq 'group' };
 	  return $glyph_name;
 	};
 
@@ -261,7 +261,7 @@
 					   );
 
   my $factory = Bio::Graphics::Glyph::Factory->new($self,@options);
-  my $track   = $factory->make_glyph($feature);
+  my $track   = $factory->make_glyph(-1,$feature);
 
   splice(@{$self->{tracks}},$position,0,$track);
   return $track;
@@ -404,7 +404,7 @@
 	my $t = Bio::Graphics::Feature->new(-segments=>
 					    [Bio::Graphics::Feature->new(-start => $self->offset,
 									 -stop  => $self->offset+$self->length)]);
-	my $g = $track->factory->make_glyph($t);
+	my $g = $track->factory->make_glyph(0,$t);
 	$glyph = $g->keyglyph;
       }
       next unless $glyph;
@@ -729,35 +729,88 @@
 
 =head1 SYNOPSIS
 
-  use Ace::Sequence;  # or any Bio::Seq factory
-  use Bio::Graphics::Panel;
+=head1 NAME
+
+Bio::Graphics - Generate GD images of Bio::Seq objects
+
+=head1 SYNOPSIS
 
-  my $db     = Ace->connect(-host=>'brie2.cshl.org',-port=>2005) or die;
-  my $cosmid = Ace::Sequence->new(-seq=>'Y16B4A',
-				  -db=>$db,-start=>-15000,-end=>15000) or die;
+  use Bio::Graphics;
+  use Bio::DB::BioFetch;  # or some other Bio::SeqI generator
 
-  my @transcripts = $cosmid->transcripts;
+  # get a Bio::SeqI object somehow
+  my $bf     = Bio::DB::BioFetch->new;
+  my $cosmid = $bf->getSeq_by_id('CEF58D5');
+
+  my @features = $seq->all_SeqFeatures;
+  my @CDS      = grep {$_->primary_tag eq 'CDS'}  @features;
+  my @gene     = grep {$_->primary_tag eq 'gene'} @features;
+  my @tRNAs    = grep {$_->primary_tag eq 'tRNA'} @features;
 
+  # let the drawing begin...
   my $panel = Bio::Graphics::Panel->new(
 				      -segment => $cosmid,
 				      -width  => 800
 				     );
 
-
   $panel->add_track(arrow => $cosmid,
- 		  -bump => 0,
- 		  -tick=>2);
-
-  $panel->add_track(transcript => \@transcripts,
- 		    -bgcolor   =>  'wheat',
- 		    -fgcolor   =>  'black',
-                    -key       => 'Curated Genes',
- 		    -bump      =>  +1,
- 		    -height    =>  10,
- 		    -label     =>  1);
+	  	   -bump => 0,
+		   -double=>1,
+		   -tick => 2);
+
+  $panel->add_track(transcript  => \@gene,
+		   -bgcolor    =>  'blue',
+		   -fgcolor    =>  'black',
+		   -key        => 'Genes',
+		   -bump       =>  +1,
+		   -height     =>  10,
+		   -label      => 1,
+		   -description=> 1
+		 ) ;
+
+  $panel->add_track(transcript2  => \@CDS,
+		    -bgcolor    =>  'cyan',
+		    -fgcolor    =>  'black',
+		    -key        => 'CDS',
+		    -bump       =>  +1,
+		    -height     =>  10,
+		    -label      => \&cds_label,
+		    -description=> \&cds_description,
+		 );
+
+  $panel->add_track(generic    => \@tRNAs,
+		    -bgcolor   =>  'red',
+		    -fgcolor   =>  'black',
+		    -key       => 'tRNAs',
+		    -bump      =>  +1,
+		    -height    =>  8,
+		    -label      => 1,
+		   );
+
+  my $gd = $panel->gd;
+  print $gd->can('png') ? $gd->png : $gd->gif;
+
+  # these are callbacks used to generate nice labels and descriptions for
+  # the features...
+  sub cds_label {
+    my $feature = shift;
+    my @notes;
+    foreach (qw(product gene)) {
+      next unless $feature->has_tag($_);
+      @notes = $feature->each_tag_value($_);
+      last;
+    }
+    $notes[0];
+  }
 
-  my $boxes = $panel->boxes;
-  print $panel->png;
+  sub cds_description {
+    my $feature = shift;
+    my @notes = $feature->each_tag_value('notes')
+                if $feature->has_tag('notes');
+    return unless @notes;
+    substr($notes[0],30) = '...' if length $notes[0] > 30;
+    $notes[0];
+  }
 
 =head1 DESCRIPTION
 
@@ -1196,19 +1249,19 @@
 three arguments like this:
 
    sub callback {
-      my ($feature,$option_name,$part_no,$total_parts) = @_;
+      my ($feature,$option_name,$part_no,$total_parts,$glyph) = @_;
       # do something which results in $option_value being set
       return $option_value;
    }
 
-The three arguments are C<$feature>, a reference to the
-IO::SeqFeatureI object, C<$option_name>, the name of the option to
-configure, C<$part_no>, an integer index indicating which subpart of
-the feature is being drawn, and C<$total_parts>, an integer indicating
-the total number of subfeatures in the feature.  The latter fields are
-useful in the common case of treating the first or last subfeature
-differently, such as using a different color for the terminal exon of
-a gene.
+The five arguments are C<$feature>, a reference to the IO::SeqFeatureI
+object, C<$option_name>, the name of the option to configure,
+C<$part_no>, an integer index indicating which subpart of the feature
+is being drawn, C<$total_parts>, an integer indicating the total
+number of subfeatures in the feature, and finally C<$glyph>, the Glyph
+object itself.  The latter fields are useful in the common case of
+treating the first or last subfeature differently, such as using a
+different color for the terminal exon of a gene.
 
 The callback should return a string indicating the desired value of
 the option.  To tell the panel to use the default value for this
diff -Naur bioperl-1.0/Bio/Graphics.pm bioperl-1.01/Bio/Graphics.pm
--- bioperl-1.0/Bio/Graphics.pm	Sat Mar 16 14:26:09 2002
+++ bioperl-1.01/Bio/Graphics.pm	Fri Apr 12 07:53:30 2002
@@ -4,7 +4,7 @@
 use strict;
 
 use vars '$VERSION';
-$VERSION = '0.98';
+$VERSION = '1.04';
 
 1;
 
@@ -15,32 +15,79 @@
 =head1 SYNOPSIS
 
   use Bio::Graphics;
-  use Ace::Sequence; # or any other way to create a Bio::Seq object
-
-  # get a set of Bio::SeqFeature objects ... somehow
-  my $db     = Ace->connect(-host=>'brie2.cshl.org',-port=>2005) or die;
-  my $cosmid = Ace::Sequence->new(-seq=>'Y16B4A',
-				  -db=>$db,-start=>-15000,-end=>15000) or die;
-  my @transcripts = $cosmid->transcripts;
-
+  use Bio::DB::BioFetch;  # or some other Bio::SeqI generator
+  # get a Bio::SeqI object somehow
+  my $bf     = Bio::DB::BioFetch->new;
+  my $cosmid = $bf->getSeq_by_id('CEF58D5');
+
+  my @features = $seq->all_SeqFeatures;
+  my @CDS      = grep {$_->primary_tag eq 'CDS'}  @features;
+  my @gene     = grep {$_->primary_tag eq 'gene'} @features;
+  my @tRNAs    = grep {$_->primary_tag eq 'tRNA'} @features;
   # let the drawing begin...
-  my $panel = Bio::Graphics::Panel->new( -segment => $cosmid,
-				         -width   => 800  );
+  my $panel = Bio::Graphics::Panel->new(
+				      -segment => $cosmid,
+				      -width  => 800
+				     );
 
   $panel->add_track(arrow => $cosmid,
- 		    -bump => 0,
- 		    -tick =>2);
-
-  $panel->add_track(transcript => \@transcripts,
- 		    -bgcolor   =>  'wheat',
- 		    -fgcolor   =>  'black',
-                    -key       => 'Curated Genes',
- 		    -bump      =>  +1,
- 		    -height    =>  10,
- 		    -label     =>  1);
-
-  my $boxes = $panel->boxes;
-  print $panel->png;
+	  	   -bump => 0,
+		   -double=>1,
+		   -tick => 2);
+
+  $panel->add_track(transcript  => \@gene,
+		   -bgcolor    =>  'blue',
+		   -fgcolor    =>  'black',
+		   -key        => 'Genes',
+		   -bump       =>  +1,
+		   -height     =>  10,
+		   -label      => 1,
+		   -description=> 1
+		 ) ;
+
+  $panel->add_track(transcript2  => \@CDS,
+		    -bgcolor    =>  'cyan',
+		    -fgcolor    =>  'black',
+		    -key        => 'CDS',
+		    -bump       =>  +1,
+		    -height     =>  10,
+		    -label      => \&cds_label,
+		    -description=> \&cds_description,
+		 );
+
+  $panel->add_track(generic    => \@tRNAs,
+		    -bgcolor   =>  'red',
+		    -fgcolor   =>  'black',
+		    -key       => 'tRNAs',
+		    -bump      =>  +1,
+		    -height    =>  8,
+		    -label      => 1,
+		   );
+
+  my $gd = $panel->gd;
+  print $gd->can('png') ? $gd->png : $gd->gif;
+
+  # these are callbacks used to generate nice labels and descriptions for
+  # the features...
+  sub cds_label {
+    my $feature = shift;
+    my @notes;
+    foreach (qw(product gene)) {
+      next unless $feature->has_tag($_);
+      @notes = $feature->each_tag_value($_);
+      last;
+    }
+    $notes[0];
+  }
+
+  sub cds_description {
+    my $feature = shift;
+    my @notes = $feature->each_tag_value('notes')
+                if $feature->has_tag('notes');
+    return unless @notes;
+    substr($notes[0],30) = '...' if length $notes[0] > 30;
+    $notes[0];
+  }
 
 =head1 DESCRIPTION
 
diff -Naur bioperl-1.0/Bio/Index/GenBank.pm bioperl-1.01/Bio/Index/GenBank.pm
--- bioperl-1.0/Bio/Index/GenBank.pm	Thu Dec 13 18:09:00 2001
+++ bioperl-1.01/Bio/Index/GenBank.pm	Sun Mar 31 16:30:01 2002
@@ -1,6 +1,5 @@
-
 #
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Index::Abstract
 #
@@ -29,13 +28,13 @@
     # Print out several sequences present in the index
     # in gcg format
     use Bio::Index::GenBank;
-
+    use Bio::SeqIO;
     my $Index_File_Name = shift;
     my $inx = Bio::Index::GenBank->new('-filename' => $Index_File_Name);
-
+    my $seqio = new Bio::SeqIO(-format => 'gcg');
     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns Bio::Seq object
-        print $seq->layout('GCG');
+        $seqio->write_seq($seq);
     }
 
     # alternatively
@@ -72,7 +71,7 @@
 
 =head1 AUTHOR - Ewan Birney
 
-Email - birney@sanger.ac.uk
+Email - birney@ebi.ac.uk
 
 =head1 APPENDIX
 
@@ -202,16 +201,4 @@
    return 'GenBank';
 }
 
-
-
 1;
-
-
-
-
-
-
-
-
-
-
diff -Naur bioperl-1.0/Bio/LocationI.pm bioperl-1.01/Bio/LocationI.pm
--- bioperl-1.0/Bio/LocationI.pm	Mon Jan  7 20:25:31 2002
+++ bioperl-1.01/Bio/LocationI.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::LocationI
 # Cared for by Jason Stajich <jason@chg.mc.duke.edu>
@@ -26,7 +26,7 @@
 This Interface defines the methods for a Bio::LocationI, an object
 which encapsulates a location on a biological sequence.  Locations
 need not be attached to actual sequences as they are stand alone
-objects.  LocationI objects are used by Bio::SeqFeatureI objects to
+objects.  LocationI objects are used by L<Bio::SeqFeatureI> objects to
 manage and represent locations for a Sequence Feature.
 
 =head1 FEEDBACK
@@ -49,7 +49,7 @@
 
 =head1 AUTHOR - Jason Stajich
 
-Email jason@chg.mc.duke.edu
+Email jason@bioperl.org
 
 =head1 APPENDIX
 
@@ -86,7 +86,7 @@
 
 sub location_type { 
     my ($self,@args) = @_;
-    $self->_abstractDeath('location_type');
+    $self->throw_not_implemented();
 }
 
 =head2 start
@@ -99,11 +99,12 @@
             in more ambiguous cases like fuzzy locations the number may be
             equal to one or neither of both.
 
-            We override this here from RangeI in order to delegate 'get' to
-            a Bio::Location::CoordinatePolicy implementing object. Implementing
-            classes may also wish to provide 'set' functionality, in which
-            case they *must* override this method. The implementation
-            provided here will throw an exception if called with arguments.
+            We override this here from RangeI in order to delegate
+            'get' to a L<Bio::Location::CoordinatePolicy> implementing
+            object.  Implementing classes may also wish to provide
+            'set' functionality, in which case they *must* override
+            this method. The implementation provided here will throw
+            an exception if called with arguments.
 
   Returns : A positive integer value.
   Args    : none
@@ -131,11 +132,12 @@
             in more ambiguous cases like fuzzy locations the number may be
             equal to one or neither of both.
 
-            We override this here from RangeI in order to delegate 'get' to
-            a Bio::Location::CoordinatePolicy implementing object. Implementing
-            classes may also wish to provide 'set' functionality, in which
-            case they *must* override this method. The implementation
-            provided here will throw an exception if called with arguments.
+            We override this here from L<Bio::RangeI> in order to delegate
+            'get' to a L<Bio::Location::CoordinatePolicy> implementing
+            object. Implementing classes may also wish to provide
+            'set' functionality, in which case they *must* override
+            this method. The implementation provided here will throw
+            an exception if called with arguments.
 
   Returns : A positive integer value.
   Args    : none
@@ -304,16 +306,17 @@
             setting of a different policy. The implementation provided here
             does, however, allow to do so.
 
-            Implementors of this interface are expected to initialize every
-            new instance with a CoordinatePolicyI object. The implementation
-            provided here will return a default policy object if none has
-            been set yet. To change this default policy object call this
-            method as a class method with an appropriate argument. Note that
-            in this case only subsequently created Location objects will be
-            affected.
+            Implementors of this interface are expected to initialize
+            every new instance with a
+            L<Bio::Location::CoordinatePolicyI> object. The
+            implementation provided here will return a default policy
+            object if none has been set yet. To change this default
+            policy object call this method as a class method with an
+            appropriate argument. Note that in this case only
+            subsequently created Location objects will be affected.
 
-  Returns : A Bio::Location::CoordinatePolicyI implementing object.
-  Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.
+  Returns : A L<Bio::Location::CoordinatePolicyI> implementing object.
+  Args    : On set, a L<Bio::Location::CoordinatePolicyI> implementing object.
 
 =cut
 
diff -Naur bioperl-1.0/Bio/Map/MapI.pm bioperl-1.01/Bio/Map/MapI.pm
--- bioperl-1.0/Bio/Map/MapI.pm	Sat Dec  1 17:38:02 2001
+++ bioperl-1.01/Bio/Map/MapI.pm	Sat May  4 16:28:12 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# MapI.pm,v 1.5 2002/04/18 12:52:48 jason Exp
 #
 # BioPerl module for Bio::Map::MapI
 #
@@ -79,14 +79,14 @@
  Title   : species
  Usage   : my $species = $map->species;
  Function: Get/Set Species for a map
- Returns : Bio::Species object
+ Returns : L<Bio::Species> object
  Args    : (optional) Bio::Species
 
 =cut
 
 sub species{
    my ($self) = @_;
-   $self->_abstractDeath('species');
+   $self->throw_not_implemented();
 }
 
 =head2 units
@@ -101,7 +101,7 @@
 
 sub units{
    my ($self) = @_;
-   $self->_abstractDeath('units');
+   $self->throw_not_implemented();
 }
 
 =head2 type
@@ -116,7 +116,7 @@
 
 sub type {
    my ($self) = @_;
-   $self->_abstractDeath('type');
+   $self->throw_not_implemented();
 }
 
 =head2 name
@@ -131,7 +131,7 @@
 
 sub name {
    my ($self) = @_;
-   $self->_abstractDeath('name');
+   $self->throw_not_implemented();
 }
 
 =head2 length
@@ -150,7 +150,7 @@
 
 sub length{
    my ($self) = @_;
-   $self->_abstractDeath('length');
+   $self->throw_not_implemented();
 }
 
 =head2 unique_id
@@ -165,7 +165,7 @@
 
 sub unique_id{
    my ($self,$id) = @_;
-   $self->_abstractDeath('unique_id');
+   $self->throw_not_implemented();
 }
 
 =head2 add_element
@@ -180,7 +180,7 @@
 
 sub add_element{
    my ($self) = @_;
-   $self->_abstractDeath('add_element');
+   $self->throw_not_implemented();
 }
 
 =head2 each_element
@@ -189,7 +189,7 @@
  Usage   : my @elements = $map->each_element;
  Function: Retrieves all the elements in a map
            unordered
- Returns : 
+ Returns : Array of Map elements (L<Bio::Map::MarkerI>)
  Args    :
 
 
@@ -197,7 +197,7 @@
 
 sub each_element{
    my ($self) = @_;
-   $self->_abstractDeath('each_element');
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Map/PositionI.pm bioperl-1.01/Bio/Map/PositionI.pm
--- bioperl-1.0/Bio/Map/PositionI.pm	Mon Feb 11 04:24:51 2002
+++ bioperl-1.01/Bio/Map/PositionI.pm	Sat May  4 16:28:12 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# PositionI.pm,v 1.7 2002/04/18 12:52:48 jason Exp
 #
 # BioPerl module for Bio::Map::PositionI
 #
@@ -91,7 +91,7 @@
 
 sub map {
    my ($self, $value) = @_;
-   $self->_abstractDeath('map');
+   $self->throw_not_implemented();
 }
 
 =head2 marker
@@ -106,7 +106,7 @@
 
 sub marker {
    my ($self, $value) = @_;
-   $self->_abstractDeath('marker');
+   $self->throw_not_implemented();
 }
 
 
@@ -122,7 +122,7 @@
 
 sub value {
    my ($self, $value) = @_;
-   $self->_abstractDeath('value');
+   $self->throw_not_implemented();
 }
 
 =head2 numeric
@@ -138,7 +138,7 @@
 
 sub numeric {
    my ($self) = @_;
-   $self->_abstractDeath('numeric');
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Map/SimpleMap.pm bioperl-1.01/Bio/Map/SimpleMap.pm
--- bioperl-1.0/Bio/Map/SimpleMap.pm	Mon Feb 11 04:24:51 2002
+++ bioperl-1.01/Bio/Map/SimpleMap.pm	Sat May  4 16:28:12 2002
@@ -1,5 +1,5 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
-#
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+
 # BioPerl module for Bio::Map::SimpleMap
 #
 # Cared for by Jason Stajich <jason@bioperl.org>
@@ -224,7 +224,7 @@
    my ($len ) = 0;
 
    foreach my $marker ($self->each_element) {
-       $len = $marker->position->numeric if  $marker->postion->numeric > $len;
+       $len = $marker->position->numeric if  $marker->position->numeric > $len;
    }
    return $len;
 }
diff -Naur bioperl-1.0/Bio/MapIO/mapmaker.pm bioperl-1.01/Bio/MapIO/mapmaker.pm
--- bioperl-1.0/Bio/MapIO/mapmaker.pm	Mon Feb 11 04:34:18 2002
+++ bioperl-1.01/Bio/MapIO/mapmaker.pm	Sat May  4 16:28:12 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::MapIO::mapmaker
 #
@@ -31,7 +31,7 @@
 =head1 DESCRIPTION
 
 This object contains code for parsing and processing Mapmaker output
-and creating Bio::Map::MapI objects from it.
+and creating L<Bio::Map::MapI> objects from it.
 
 =head1 FEEDBACK
 
@@ -90,7 +90,7 @@
  Title   : next_tree
  Usage   : my $map = $factory->next_map;
  Function: Get a map from the factory
- Returns : Bio::Map::MapI
+ Returns : L<Bio::Map::MapI>
  Args    : none
 
 =cut
@@ -144,7 +144,7 @@
 
 sub write_map{
    my ($self,@args) = @_;
-   $self->_abstractDeath('write_map');
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/MapIO.pm bioperl-1.01/Bio/MapIO.pm
--- bioperl-1.0/Bio/MapIO.pm	Mon Dec 10 11:10:16 2001
+++ bioperl-1.01/Bio/MapIO.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::MapIO
 #
@@ -129,7 +129,7 @@
  Title   : next_tree
  Usage   : my $map = $factory->next_map;
  Function: Get a map from the factory
- Returns : Bio::Map::MapI
+ Returns : L<Bio::Map::MapI>
  Args    : none
 
 
@@ -139,7 +139,7 @@
  Usage   : $factory->write_map($map);
  Function: Write a map out through the factory
  Returns : none
- Args    : Bio::Map::MapI
+ Args    : L<Bio::Map::MapI>
 
 =cut
 
@@ -150,7 +150,7 @@
  Usage   : $parser->attatch_EventHandler($handler)
  Function: Adds an event handler to listen for events
  Returns : none
- Args    : Bio::Event::EventHandlerI
+ Args    : L<Bio::Event::EventHandlerI>
 
 =cut
 
@@ -169,7 +169,7 @@
  Title   : _eventHandler
  Usage   : private
  Function: Get the EventHandler
- Returns : Bio::Event::EventHandlerI
+ Returns : L<Bio::Event::EventHandlerI>
  Args    : none
 
 
diff -Naur bioperl-1.0/Bio/Root/Exception.pm bioperl-1.01/Bio/Root/Exception.pm
--- bioperl-1.0/Bio/Root/Exception.pm	Wed Feb 13 06:02:46 2002
+++ bioperl-1.01/Bio/Root/Exception.pm	Sat May  4 16:28:13 2002
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module Bio::Root::Exception
 #
@@ -268,7 +268,7 @@
     my $self = shift;
     my $msg = $self->text;
     my $stack = $self->stacktrace();
-    $stack =~ s/$msg//;
+    $stack =~ s/\Q$msg//;
     my @stack = split( /\n/, $stack);
     my @new_stack = ();
     my ($method, $file, $linenum, $prev_file, $prev_linenum);
@@ -288,7 +288,7 @@
             ($prev_file, $prev_linenum) = ($file, $linenum);
             next;
         }
-        
+
         if( $method =~ /__ANON__/ ) {
             $method = "try{} block";
         }
@@ -299,6 +299,8 @@
         push @new_stack, "STACK: $method $prev_file:$prev_linenum";
         ($prev_file, $prev_linenum) = ($file, $linenum);
     }
+    push @new_stack, "STACK: $prev_file:$prev_linenum";
+
     return join "\n", @new_stack;
 }
 
diff -Naur bioperl-1.0/Bio/Root/RootI.pm bioperl-1.01/Bio/Root/RootI.pm
--- bioperl-1.0/Bio/Root/RootI.pm	Sun Mar 10 20:44:47 2002
+++ bioperl-1.01/Bio/Root/RootI.pm	Sat May  4 16:28:13 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Root::RootI
 #
@@ -108,7 +108,8 @@
 BEGIN { 
     $ID        = 'Bio::Root::RootI';
     $VERSION   = 1.0;
-    $Revision  = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $ ';
+    $Revision  = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $ ';
+    $VERSION   = 1.0;
     $DEBUG     = 0;
     $VERBOSITY = 0;
 }
@@ -132,7 +133,6 @@
 
     ## See "Comments" above regarding use of _rearrange().
     $self->verbose($verbose);
-
     return $self;
 }
 
@@ -156,7 +156,7 @@
   my $class = shift;
   my @args = @_;
   carp("Use of Bio::Root::RootI is deprecated.  Please use Bio::Root::Root instead");
-  eval "use Bio::Root::Root";
+  eval "require Bio::Root::Root";
   return Bio::Root::Root->new(@args);
 }
 
@@ -259,7 +259,6 @@
    }
 }
 
-		     
 =head2 verbose
 
  Title   : verbose
@@ -277,7 +276,7 @@
 
 sub verbose{
    my ($self,$value) = @_;
-   $self->_abstractDeath('verbose');
+   $self->throw_not_implemented();
 }
 
 =head2 stack_trace_dump
@@ -477,7 +476,7 @@
 
 sub _register_for_cleanup {
   my ($self,$method) = @_;
-  $self->_abstractDeath('_register_for_cleanup');
+   $self->throw_not_implemented();
 }
 
 =head2 _unregister_for_cleanup
@@ -494,7 +493,7 @@
 
 sub _unregister_for_cleanup {
   my ($self,$method) = @_;
-  $self->_abstractDeath('_unregister_for_cleanup');
+   $self->throw_not_implemented();
 }
 
 =head2 _cleanup_methods
diff -Naur bioperl-1.0/Bio/Search/HSP/GenericHSP.pm bioperl-1.01/Bio/Search/HSP/GenericHSP.pm
--- bioperl-1.0/Bio/Search/HSP/GenericHSP.pm	Thu Mar  7 12:58:20 2002
+++ bioperl-1.01/Bio/Search/HSP/GenericHSP.pm	Sat May  4 16:28:13 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Search::HSP::GenericHSP
 #
@@ -300,9 +300,7 @@
     } else {
 	$self->gaps('hit', scalar ( $hit_seq =~ tr/\-//));
     }
-
     if(! defined $gaps ) {
-	$self->warn("Did not defined the number of gaps in the HSP calculating");
 	$gaps = $self->gaps("query") + $self->gaps("hit");
     } 
     $self->gaps('total', $gaps);
@@ -585,8 +583,9 @@
  Returns : array of query and subjects if return type wants an array
            or query frame if defined or subject frame
  Args    : none
- Note    : Frames are stored in the GFF way (0-2 +/-) not 1-3
-           as they are in BLAST
+ Note    : Frames are stored in the GFF way (0-2) not 1-3
+           as they are in BLAST (negative frames are deduced by checking 
+				 the strand of the query or hit)
 
 =cut
 
@@ -607,7 +606,7 @@
 	    }
 	    # Set frame to GFF [0-2] -
 	    # what if someone tries to put in a GFF frame!
-	    $qframe = $2 - 1;
+	    $qframe = $2 - 1;	    
 	}
 	$self->query->frame($qframe);
     }
@@ -618,8 +617,10 @@
 	    $self->warn("Specifying an invalid subject frame ($sframe)");
 	    $sframe = undef;
 	  } else {
-	      if( (defined $1 && $1 eq '-' && $self->hit->strand >= 0) ||
-		  (defined $1 && $1 eq '+' && $self->hit->strand <= 0) )
+	      my $dir = $1;
+	      $dir = '+' unless defined $dir;
+	      if( ($dir eq '-' && $self->hit->strand >= 0) ||
+		  ($dir eq '+' && $self->hit->strand <= 0) )
 	      {
 		  $self->warn("Subject frame ($sframe) did not match strand of subject (". $self->hit->strand() . ")");
 	      }
diff -Naur bioperl-1.0/Bio/Search/Hit/BlastHit.pm bioperl-1.01/Bio/Search/Hit/BlastHit.pm
--- bioperl-1.0/Bio/Search/Hit/BlastHit.pm	Wed Jan 23 06:30:25 2002
+++ bioperl-1.01/Bio/Search/Hit/BlastHit.pm	Fri Apr 12 00:10:14 2002
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module Bio::Search::Hit::BlastHit
 #
@@ -211,7 +211,7 @@
 
 @ISA = qw( Bio::Root::Root Bio::Search::Hit::HitI );
 
-$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
+$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
 
 
 =head2 new
@@ -273,6 +273,7 @@
 			      SCORE
 			      FOUND_AGAIN )], @args );
 
+    # TODO: Handle this in parser. Just pass in name parameter.
     $self->_set_id( $raw_data->[0] );
 
     if($is_pval) {
@@ -323,12 +324,14 @@
 
  Usage     : $hit->name([string]);
  Purpose   : Set/Get a string to identify the hit.
-             This is parsed out of the "Query=" line as the first chunk of 
-             non-whitespace text. If you want the rest of the line, use
-             $hit->description().
  Example   : $name = $hit->name;
            : $hit->name('M81707');
  Returns   : String consisting of the hit's name or undef if not set.
+ Comments  : The name is parsed out of the "Query=" line as the first chunk of 
+             non-whitespace text. If you want the rest of the line, use
+             $hit->description().
+
+See Also: L<accession()|accession>
 
 =cut
 
@@ -371,6 +374,29 @@
     return substr( $self->{'_description'}, 0 ,$len ); 
 }
 
+=head2 accession
+
+ Title   : accession
+ Usage   : $acc = $hit->accession();
+ Function: Retrieve the accession (if available) for the hit
+ Returns : a scalar string (empty string if not set)
+ Args    : none
+ Comments: Accession numbers are extracted based on the assumption that they
+           are delimited by | characters (NCBI-style). If this is not the case,
+           use the name() method and parse it as necessary.
+
+See Also: L<name()|name>
+
+=cut
+
+#--------------------
+sub accession {
+#--------------------
+    my $self = shift;
+    if(@_) { $self->{'_accession'} = shift; }
+    $self->{'_accession'} || '';
+}
+
 =head2 raw_score
 
  Usage     : $hit_object->raw_score();
@@ -684,7 +710,7 @@
 #           : or first line of an alignment section (with or without the leading '>').
 # Throws    : Warning if cannot locate sequence ID.
 #
-#See Also   : L<new()|new>
+#See Also   : L<new()|new>, L<accession()|accession>
 #
 #=cut
 
@@ -694,15 +720,21 @@
     my( $self, $desc ) = @_;
 
     # New strategy: Assume only that the ID is the first white space
-    # delimited chunk. Not attempting to extract database name.
+    # delimited chunk. Not attempting to extract accession & database name.
     # Clients will have to interpret it as necessary.
     if($desc =~ /^>?(\S+)\s*(.*)/) {
-        $self->name($1);
-        $self->{'_description'} = $2;
+        my ($name, $desc) = ($1, $2);
+        $self->name($name);
+        $self->{'_description'} = $desc;
 	# Note that this description comes from the summary section of the
 	# BLAST report and so may be truncated. The full description will be
 	# set from the alignment section. We're setting description here in case
 	# the alignment section isn't being parsed.
+
+        # Assuming accession is delimited with | symbols (NCBI-style)
+        my @pieces = split(/\|/,$name);
+        my $acc = pop @pieces;
+        $self->accession( $acc );
     }
     else {
         $self->warn("Can't locate sequence identifier in summary line.", "Line = $desc");
diff -Naur bioperl-1.0/Bio/SearchIO/blast.pm bioperl-1.01/Bio/SearchIO/blast.pm
--- bioperl-1.0/Bio/SearchIO/blast.pm	Fri Mar  8 15:22:16 2002
+++ bioperl-1.01/Bio/SearchIO/blast.pm	Sat May  4 16:28:14 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SearchIO::blast
 #
@@ -284,19 +284,20 @@
 	   $self->element({'Name' => 'BlastOutput_db',
 			   'Data' => $db});
        } elsif( /^>(\S+)\s*(.*)?/ ) {
+	   chomp;
 	   $self->in_element('hsp') && $self->end_element({ 'Name' => 'Hsp'});
 	   $self->in_element('hit') && $self->end_element({ 'Name' => 'Hit'});
 	   
 	   $self->start_element({ 'Name' => 'Hit'});
 	   my $id = $1;	  
+	   my $restofline = $2;
 	   $self->element({ 'Name' => 'Hit_id',
 			    'Data' => $id});
 	   my @pieces = split(/\|/,$id);
 	   my $acc = pop @pieces;
 	   $self->element({ 'Name' =>  'Hit_accession',
 			    'Data'  => $acc});	   
-	   $self->element({ 'Name' => 'Hit_def',
-			    'Data' => $2});
+
 	   my $v = shift @hit_signifs;
 	   if( defined $v ) {
 	       $self->element({'Name' => 'Hit_signif',
@@ -304,24 +305,41 @@
 	       $self->element({'Name' => 'Hit_score',
 			       'Data' => $v->[1]});
 	   }
-
+	   while(defined($_ = $self->_readline()) ) {
+	       next if( /^\s+$/ );
+	       chomp;
+	       if(  /Length\s*=\s*([\d,]+)/ ) {
+		   my $l = $1;
+		   $l =~ s/\,//g;
+		   $self->element({ 'Name' => 'Hit_len',
+				    'Data' => $l });
+		   last;
+	       }  elsif ( /Score/ ) {
+		   $self->_pushback($_);
+		   last;
+	       } else { 
+		   $restofline .= $_;
+	       }
+	   }
+	   $restofline =~ s/\s+/ /g;
+	   $self->element({ 'Name' => 'Hit_def',
+			    'Data' => $restofline});       
       } elsif( /\s+(Plus|Minus) Strand HSPs:/i ) {
 	   next;
-       } elsif(  /Length\s*=\s*([\d,]+)/ ) {
-	   $self->element({ 'Name' => 'Hit_len',
-			    'Data' => $1 });
-       } elsif( ($self->in_element('hit') || $self->in_element('hsp')) && # wublast
-		/Score\s*=\s*(\d+)\s*\(([\d\.]+)\s*bits\),\s*Expect\s*=\s*([^,\s]+),\s*P\s*=\s*([^,\s]+)/ ) {
+       } elsif( ($self->in_element('hit') || 
+		 $self->in_element('hsp')) && # wublast
+	       /Score\s*=\s*(\S+)\s*\(([\d\.]+)\s*bits\),\s*Expect\s*=\s*([^,\s]+),\s*(Sum)?\s*P(\(\d+\))?\s*=\s*([^,\s]+)/ 
+		  ) {
 	   $self->in_element('hsp') && $self->end_element({'Name' => 'Hsp'});
 	   $self->start_element({'Name' => 'Hsp'});
        	   $self->element( { 'Name' => 'Hsp_score',
 			     'Data' => $1});
 	   $self->element( { 'Name' => 'Hsp_bit-score',
 			     'Data' => $2});
-	   $self->element( { 'Name' => 'Hsp_evalue',
+	   $self->element( { 'Name' => 'Hsp_evalue',			     
 			     'Data' => $3});
 	   $self->element( {'Name'  => 'Hsp_pvalue',
-			    'Data'  =>$4});
+			    'Data'  =>$6});       
        } elsif( ($self->in_element('hit') || $self->in_element('hsp')) && # ncbi blast
 		/Score\s*=\s*(\S+)\s*bits\s*\((\d+)\),\s*Expect(\(\d+\))?\s*=\s*(\S+)/) {
 	   $self->in_element('hsp') && $self->end_element({ 'Name' => 'Hsp'});
@@ -347,27 +365,29 @@
 	   if( defined $6 ) { 
 	       $self->element( { 'Name' => 'Hsp_gaps',
 				 'Data' => $7});	   
-	   } else { 
-	       $self->element( { 'Name' => 'Hsp_gaps',
-				 'Data' => 0});
-	   }
-	   $self->{'_Query'} = {'begin' => 0, 'end' => 0};
+	   } 
+	   $self->{'_Query'} = { 'begin' => 0, 'end' => 0};
 	   $self->{'_Sbjct'} = { 'begin' => 0, 'end' => 0};
+
+	   if( /(Frame\s*=\s*.+)$/ ) {
+	       # handle wu-blast Frame listing on same line
+	       $self->_pushback($1);
+	   }	   
        } elsif( $self->in_element('hsp') &&
 		/Strand\s*=\s*(Plus|Minus)\s*\/\s*(Plus|Minus)/i ) {
+	   # consume this event
 	   next;
        } elsif( $self->in_element('hsp') &&
 		/Frame\s*=\s*([\+\-][1-3])\s*(\/\s*([\+\-][1-3]))?/ ){
-
 	   my ($queryframe,$hitframe);
 	   if( $reporttype eq 'TBLASTX' ) {
 	       ($queryframe,$hitframe) = ($1,$2);
 	       $hitframe =~ s/\/\s*//g;
 	   } elsif( $reporttype eq 'TBLASTN' ) {
-	       ($hitframe,$queryframe) = ($1,0);
-	   } else { 
+	       ($hitframe,$queryframe) = ($1,0);	       
+	   } elsif( $reporttype eq 'BLASTX' ) {	       
 	       ($queryframe,$hitframe) = ($1,0);
-	   }
+	   } 
 	   $self->element({'Name' => 'Hsp_query-frame',
 			   'Data' => $queryframe});
 	   	   
diff -Naur bioperl-1.0/Bio/SeqAnalysisParserI.pm bioperl-1.01/Bio/SeqAnalysisParserI.pm
--- bioperl-1.0/Bio/SeqAnalysisParserI.pm	Sat Nov 24 16:44:47 2001
+++ bioperl-1.01/Bio/SeqAnalysisParserI.pm	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SeqAnalysisParserI
 #
@@ -98,7 +98,7 @@
 
 sub next_feature {
     my ($self);
-    $self->_abstractDeath('next_feature');
+    $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/SeqFeature/Computation.pm bioperl-1.01/Bio/SeqFeature/Computation.pm
--- bioperl-1.0/Bio/SeqFeature/Computation.pm	Mon Nov 19 21:09:37 2001
+++ bioperl-1.01/Bio/SeqFeature/Computation.pm	Sat May  4 16:28:14 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SeqFeature::Generic
 #
@@ -125,9 +125,9 @@
     $database_version && $self->database_version($database_version);
     $computation_id   && $self->computation_id($computation_id);
     $score            && do {
-	if (ref($score)) {
-	    foreach my $t ( keys %$score ) {
-		$self->add_score_value($t,$score->{$t});
+	if (ref($score) =~ /hash/i) {
+	    while( my ($t,$val) = each %$score ) {
+		$self->add_score_value($t,$val);
 	    }
 	} else { 	     
 	    $self->score($score); 	
@@ -149,9 +149,9 @@
 =cut
 
 sub has_score {
-   my ($self, $score) = (shift, shift);
-
-   return exists $self->{'_gsf_score_hash'}->{$score};
+    my ($self, $score) = @_;
+    return undef unless defined $score;
+    return exists $self->{'_gsf_score_hash'}->{$score};
 }
 
 =head2 add_score_value
@@ -165,6 +165,11 @@
 
 sub add_score_value {
    my ($self, $score, $value) = @_;
+   if( ! defined $score || ! defined $value ) { 
+       $self->warn("must specify a valid $score and $value to add_score_value");
+       return 0;
+   }
+
    if ( !defined $self->{'_gsf_score_hash'}->{$score} ) {
        $self->{'_gsf_score_hash'}->{$score} = [];
    }
@@ -186,12 +191,15 @@
 =cut
 
 sub score {
-   my ($self, $value) = (shift, shift);
-   if ($value) {
-      $self->add_score_value('default', $value);
-   } else {
-      return ($self->get_score_value('default'))[0];
-   }
+    my ($self, $value) = @_;
+    my @v;
+    if (defined $value) {
+	@v = $value;
+	$self->add_score_value('default', $value);
+    } else {       
+	@v = $self->each_score_value('default');
+    }
+    return $v[0];
 }
 
 =head2 each_score_value
@@ -203,7 +211,6 @@
  Returns : A list of scalars
  Args    : The name of the score
 
-
 =cut
 
 sub each_score_value {
@@ -211,7 +218,6 @@
    if ( ! exists $self->{'_gsf_score_hash'}->{$score} ) {
        $self->throw("asking for score value that does not exist $score");
    }
-
    return @{$self->{'_gsf_score_hash'}->{$score}};
 }
 
diff -Naur bioperl-1.0/Bio/SeqFeature/Gene/ExonI.pm bioperl-1.01/Bio/SeqFeature/Gene/ExonI.pm
--- bioperl-1.0/Bio/SeqFeature/Gene/ExonI.pm	Sat Nov 24 16:49:23 2001
+++ bioperl-1.01/Bio/SeqFeature/Gene/ExonI.pm	Sat May  4 16:28:16 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SeqFeature::Gene::ExonI
 #
@@ -88,8 +88,7 @@
 
 sub is_coding {
     my ($self) = @_;
-
-    $self->_abstractDeath('is_coding');
+    $self->throw_not_implemented();
 }
 
 =head2 cds
@@ -104,7 +103,7 @@
            An implementation may return undef, indicating that a coding
            sequence does not exist, e.g. for a UTR (untranslated region).
 
- Returns : A Bio::PrimarySeqI implementing object.
+ Returns : A L<Bio::PrimarySeqI> implementing object.
  Args    : 
 
 
@@ -112,7 +111,7 @@
 
 sub cds {
     my ($self) = @_;
-    $self->_abstractDeath('cds');
+    $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/SeqFeature/Gene/GeneStructureI.pm bioperl-1.01/Bio/SeqFeature/Gene/GeneStructureI.pm
--- bioperl-1.0/Bio/SeqFeature/Gene/GeneStructureI.pm	Sat Nov 24 16:49:24 2001
+++ bioperl-1.01/Bio/SeqFeature/Gene/GeneStructureI.pm	Sat May  4 16:28:16 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SeqFeature::Gene::GeneStructureI
 #
@@ -88,8 +88,7 @@
 
 sub transcripts {
     my ($self) = @_;
-
-    $self->_abstractDeath('transcripts');
+    $self->throw_not_implemented();
 }
 
 =head2 promoters
@@ -110,8 +109,7 @@
 
 sub promoters {
     my ($self) = @_;
-
-    $self->_abstractDeath('promotors');
+    $self->throw_not_implemented();
 }
 
 =head2 exons
@@ -136,8 +134,7 @@
 
 sub exons {
     my ($self, $type) = @_;
-
-    $self->_abstractDeath('exons');
+    $self->throw_not_implemented();
 }
 
 =head2 introns
@@ -154,8 +151,7 @@
 
 sub introns {
     my ($self) = @_;
-
-    $self->_abstractDeath('introns');    
+    $self->throw_not_implemented();
 }
 
 =head2 poly_A_sites
@@ -172,8 +168,7 @@
 
 sub poly_A_sites {
     my ($self) = @_;
-
-    $self->_abstractDeath('poly_A_sites');
+    $self->throw_not_implemented();
 }
 
 =head2 utrs
@@ -194,12 +189,7 @@
 
 sub utrs {
     my ($self) = @_;
-
-    $self->_abstractDeath('utrs');
+    $self->throw_not_implemented();
 }
 
 1;
-
-
-
-
diff -Naur bioperl-1.0/Bio/SeqFeature/Gene/TranscriptI.pm bioperl-1.01/Bio/SeqFeature/Gene/TranscriptI.pm
--- bioperl-1.0/Bio/SeqFeature/Gene/TranscriptI.pm	Sat Nov 24 16:49:24 2001
+++ bioperl-1.01/Bio/SeqFeature/Gene/TranscriptI.pm	Sat May  4 16:28:16 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::SeqFeature::Gene::TranscriptI
 #
@@ -88,8 +88,7 @@
 
 sub promoters {
     my ($self) = @_;
-
-    $self->_abstractDeath('promotors');
+    $self->throw_not_implemented();
 }
 
 =head2 exons
@@ -113,8 +112,7 @@
 
 sub exons {
     my ($self, $type) = @_;
-
-    $self->_abstractDeath('exons');
+    $self->throw_not_implemented();
 }
 
 =head2 introns
@@ -131,8 +129,7 @@
 
 sub introns {
     my ($self) = @_;
-
-    $self->_abstractDeath('introns');    
+    $self->throw_not_implemented();
 }
 
 =head2 poly_A_site
@@ -148,8 +145,7 @@
 
 sub poly_A_site {
     my ($self) = @_;
-
-    $self->_abstractDeath('poly_A_site');
+    $self->throw_not_implemented();
 }
 
 =head2 utrs
@@ -169,8 +165,7 @@
 
 sub utrs {
     my ($self) = @_;
-
-    $self->_abstractDeath('utrs');
+    $self->throw_not_implemented();
 }
 
 =head2 mrna
@@ -187,8 +182,7 @@
 
 sub mrna {
     my ($self) = @_;
-
-    $self->_abstractDeath('mrna');
+    $self->throw_not_implemented();
 }
 
 =head2 cds
@@ -206,8 +200,7 @@
 
 sub cds {
     my ($self) = @_;
-
-    $self->_abstractDeath('cds');
+    $self->throw_not_implemented();
 }
 
 =head2 protein
@@ -224,8 +217,7 @@
 
 sub protein {
     my ($self) = @_;
-
-    $self->_abstractDeath('protein');
+    $self->throw_not_implemented();
 }
 
 =head2 parent
@@ -249,7 +241,6 @@
        }
     }
     return $self->{'parent'};
-
 }
 
 
diff -Naur bioperl-1.0/Bio/SeqIO/bsml.pm bioperl-1.01/Bio/SeqIO/bsml.pm
--- bioperl-1.0/Bio/SeqIO/bsml.pm	Wed Feb 13 06:02:50 2002
+++ bioperl-1.01/Bio/SeqIO/bsml.pm	Sat May  4 16:28:17 2002
@@ -561,8 +561,6 @@
     # <Sequences> #
     ###############
 
-   $seqsElem = $xml->getElementsByTagName("Sequences")->item(0);
-        
     # Map over Bio::Seq to BSML
     my %mol = ('dna' => 'DNA', 'rna' => 'RNA', 'protein' => 'AA');
     my @xmlSequences;
@@ -1382,7 +1380,9 @@
     # Reports off the net imply that DOM::Parser will memory leak if you
     # do not explicitly dispose of it:
     # http://aspn.activestate.com/ASPN/Mail/Message/perl-xml/788458
-    $self->{'domtree'}->dispose;
+    my $dom = $self->{'domtree'};
+    # For some reason the domtree can get undef-ed somewhere...
+    $dom->dispose if ($dom);
 }
 
 
diff -Naur bioperl-1.0/Bio/Structure/StructureI.pm bioperl-1.01/Bio/Structure/StructureI.pm
--- bioperl-1.0/Bio/Structure/StructureI.pm	Wed Feb 13 10:34:52 2002
+++ bioperl-1.01/Bio/Structure/StructureI.pm	Fri Apr 12 00:10:15 2002
@@ -1,9 +1,9 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
-# placeholder for Bio::StructureI
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# placeholder for Bio::Structure::StructureI
 
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
-# BioPerl module for Bio::StructureI
+# BioPerl module for Bio::Structure::StructureI
 #
 # Cared for by Kris Boulez <kris.boulez@algonomics.com>
 #
@@ -15,7 +15,7 @@
 
 =head1 NAME
 
-Bio::StructureI - Abstract Interface for a Structure objects
+Bio::Structure::StructureI - Abstract Interface for a Structure objects
 
 =head1 SYNOPSIS
 
@@ -66,7 +66,8 @@
 # Let the code begin...
 
 
-package Bio::StructureI;
+package Bio::Structure::StructureI;
+use Bio::Root::RootI;
 use vars qw(@ISA);
 use strict;
 
diff -Naur bioperl-1.0/Bio/Symbol/AlphabetI.pm bioperl-1.01/Bio/Symbol/AlphabetI.pm
--- bioperl-1.0/Bio/Symbol/AlphabetI.pm	Fri Dec 14 11:40:17 2001
+++ bioperl-1.01/Bio/Symbol/AlphabetI.pm	Sat May  4 16:28:17 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Symbol::AlphabetI
 #
@@ -73,17 +73,7 @@
 
 package Bio::Symbol::AlphabetI;
 use strict;
-
-use Carp;
-
-sub _abstractDeath {
-  my $self = shift;
-  my $package = ref $self;
-  my $caller = (caller)[1];
-
-  confess "Abstract method '$caller' defined in interface Bio::Symbol::AlphabetI not implemented by pacakge $package. Not your fault - author of $package should be blamed!";
-
-}
+use Bio::Root::RootI;
 
 =head2 AlphabetI Interface methods
 
@@ -95,14 +85,14 @@
  Usage   : my @symbols = $alphabet->symbols();
  Function: Get/Set Symbol list for an alphabet
            List of symbols, which make up this alphabet.
- Returns : Array of Bio::Symbol::SymbolI objects
- Args    : (optional) Array of Bio::Symbol::SymbolI objects
+ Returns : Array of L<Bio::Symbol::SymbolI> objects
+ Args    : (optional) Array of L<Bio::Symbol::SymbolI> objects
 
 =cut
 
 sub symbols{
    my ($self,@args) = @_;
-   $self->_abstractDeath();
+   $self->throw_not_implemented();
 }
 
 =head2 alphabets
@@ -111,14 +101,14 @@
  Usage   : my @alphabets = $alphabet->alphabets();
  Function: Get/Set Sub Alphabet list for an alphabet 
            Sub-alphabets. E.g. codons made from DNAxDNAxDNA alphabets
- Returns : Array of Bio::Symbol::AlphabetI objects
- Args    : (optional) Array of Bio::Symbol::AlphabetI objects
+ Returns : Array of L<Bio::Symbol::AlphabetI> objects
+ Args    : (optional) Array of L<Bio::Symbol::AlphabetI> objects
 
 =cut
 
 sub alphabets{
     my ($self,@args) = @_;
-    $self->_abstractDeath();
+    $self->throw_not_implemented();
 }
 
 =head2 contains
@@ -127,13 +117,13 @@
  Usage   : if($alphabet->contains($symbol)) { }
  Function: Tests of Symbol is contained in this alphabet
  Returns : Boolean
- Args    : Bio::Symbol::SymbolI
+ Args    : L<Bio::Symbol::SymbolI>
 
 =cut
 
 sub contains{
    my ($self,@args) = @_;
-   $self->_abstractDeath;
+   $self->throw_not_implemented();
 }
 
 # Other methods from BSANE - not sure if we will implement here or only in
diff -Naur bioperl-1.0/Bio/Symbol/SymbolI.pm bioperl-1.01/Bio/Symbol/SymbolI.pm
--- bioperl-1.0/Bio/Symbol/SymbolI.pm	Fri Dec 14 11:40:17 2001
+++ bioperl-1.01/Bio/Symbol/SymbolI.pm	Sat May  4 16:28:17 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Symbol::SymbolI
 #
@@ -76,17 +76,9 @@
 
 package Bio::Symbol::SymbolI;
 use strict;
-
-use Carp;
-
-sub _abstractDeath {
-  my $self = shift;
-  my $package = ref $self;
-  my $caller = (caller)[1];
-
-  confess "Abstract method '$caller' defined in interface Bio::Symbol::SymbolI not implemented by pacakge $package. Not your fault - author of $package should be blamed!";
-
-}
+use Bio::Root::RootI;
+use vars qw(@ISA);
+@ISA = qw(Bio::Root::RootI);
 
 =head2 Bio::Symbol::SymbolI interface methods
 
@@ -104,7 +96,7 @@
 
 sub name{
    my ($self,@args) = @_;
-   $self->_abstractDeath();
+   $self->throw_not_implemented();
 }
 
 =head2 token
@@ -120,7 +112,7 @@
 
 sub token{
    my ($self,@args) = @_;
-   $self->_abstractDeath();
+   $self->throw_not_implemented();
 }
 
 =head2 symbols
@@ -137,7 +129,7 @@
 
 sub symbols{
    my ($self,@args) = @_;
-   $self->_abstractDeath();
+   $self->throw_not_implemented();
 }
 
 =head2 matches
@@ -155,7 +147,7 @@
 
 sub matches{
    my ($self,@args) = @_;
-   $self->_abstractDeath();   
+   $self->throw_not_implemented();   
 }
 
 =head2 equals
@@ -170,7 +162,7 @@
 
 sub equals{
    my ($self,@args) = @_;
-   $self->_abstractDeath;
+   $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Tools/Blast/Sbjct.pm bioperl-1.01/Bio/Tools/Blast/Sbjct.pm
--- bioperl-1.0/Bio/Tools/Blast/Sbjct.pm	Sat Feb 23 03:33:20 2002
+++ bioperl-1.01/Bio/Tools/Blast/Sbjct.pm	Sat May  4 16:28:19 2002
@@ -3,7 +3,7 @@
 # AUTHOR  : Steve Chervitz (sac@bioperl.org) 
 # CREATED : 7 October 1996
 # STATUS  : Alpha
-# REVISION: $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# REVISION: $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # For the latest version and documentation, visit the distribution site:
 #    http://genome-www.stanford.edu/perlOOP/bioperl/blast/
@@ -26,7 +26,7 @@
 use strict;
 use vars qw($ID %SUMMARY_OFFSET $Revision);
 $ID = 'Bio::Tools::Blast::Sbjct';
-$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
+$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
 
 my $_prog       = '';
 my $_signif_fmt = '';
@@ -1342,7 +1342,7 @@
 #--------------
 sub database { 
     my $self = shift; 
-    self->warn("Bio::Tools::Sbjct::database() is deprecated.\nNo useful information is provided by this method.\nUse Bio::Tools::Blast::database().\n");
+    $self->warn("Bio::Tools::Sbjct::database() is deprecated.\nNo useful information is provided by this method.\nUse Bio::Tools::Blast::database().\n");
     return $self->{'_db'};
 }
 #--------------
diff -Naur bioperl-1.0/Bio/Tools/Gel.pm bioperl-1.01/Bio/Tools/Gel.pm
--- bioperl-1.0/Bio/Tools/Gel.pm	Mon Jan 21 04:33:03 2002
+++ bioperl-1.01/Bio/Tools/Gel.pm	Sat May  4 16:28:18 2002
@@ -1,3 +1,4 @@
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 # BioPerl module for Bio::Tools::Gel
 # Copyright Allen Day <allenday@ucla.edu>
 # You may distribute this module under the same terms as perl itself
@@ -86,7 +87,7 @@
 use strict;
 
 use Bio::Root::Root;
-use Bio::Seq;
+use Bio::PrimarySeq;
 
 @ISA = qw(Bio::Root::Root);
 
@@ -106,29 +107,19 @@
   my($class,@args) = @_;
 
   my $self = $class->SUPER::new(@args);
-  $self->_init(@args);
+  my ($seqs,$dilate) = $self->_rearrange([qw(SEQ DILATE)],
+					  @args);
+  if( ! ref($seqs)  ) {
+      $self->add_band([$seqs]);
+  } elsif( ref($seqs) =~ /array/i ||
+	   $seqs->isa('Bio::PrimarySeqI') ) {
+      $self->add_band($seqs);
+  } 
+  $self->dilate($dilate || 1);
   
   return $self;
 }
 
-=head2 _init
-
- Title   : _init
- Usage   : _init(@args);
- Function: Handles arguments to new()
- Returns : 
- Args    : @args from new()
-
-=cut
-
-sub _init {
-  my($self,%args) = @_;
-
-  my @seqs = ref $args{-seq} eq 'ARRAY' ? @{$args{-seq}}
-                                        :   $args{-seq}; 
-  $self->add_band(\@seqs);
-  $self->dilate($args{-dilate} || 1);
-}
 
 =head2 add_band
 
@@ -144,11 +135,18 @@
   my($self,$args) = @_;
 
   foreach my $arg (@$args){
+      my $seq;
+      if( ! ref($arg) ) {
+	  if( $arg =~ /^\d+/ ) {
+	      $seq= Bio::PrimarySeq->new(-seq=>"N"x$arg, -id => $arg);
+	  } else {
+	      $seq= Bio::PrimarySeq->new(-seq=>$arg,-id=>length($arg));
+	  }
+      } elsif( $arg->isa('Bio::PrimarySeqI') ) {
+	  $seq = $arg;
+      } 
 
-    my $seq = ref $arg eq 'Bio::Seq' ? $arg
-            : Bio::Seq->new(-seq=>$arg,-id=>length($arg));
-
-    $seq->validate_seq or $seq->throw("invalid symbol in sequence");
+    $seq->validate_seq or $seq->throw("invalid symbol in sequence".$seq->seq()."\n");
     $self->_add_band($seq);
   }
 }
@@ -164,8 +162,10 @@
 =cut
 
 sub _add_band {
-  my($self,$arg) = @_;
-  push @{$self->{bands}},$arg;
+  my($self,$arg) = @_;  
+  if( defined $arg) {
+      push (@{$self->{'bands'}},$arg);
+  }
 }
 
 =head2 dilate
@@ -187,10 +187,11 @@
 }
 
 sub migrate {
-  my $self = shift;
-  my $arg  = shift;
-
-  return 4 - log10($arg);
+  my ($self,$arg) = @_;
+  $arg = $self unless $arg;
+  if ( $arg ) {
+      return 4 - log10($arg);
+  } else { return 0; }
 }
 
 =head2 bands
@@ -208,10 +209,10 @@
   $self->throw("bands() is read-only") if @_;
 
   my %bands = ();
-
+  
   foreach my $band (@{$self->{bands}}){
-    my $distance = $self->dilate * migrate($band->length);
-    $bands{$band->id} = $distance;
+      my $distance = $self->dilate * migrate($band->length);
+      $bands{$band->id} = $distance;
   }
 
   return %bands;
@@ -229,8 +230,8 @@
 
 #from programming perl
 sub log10 {
-  my $n = shift;
-  return log($n)/log(10);
+    my $n = shift;
+    return log($n)/log(10);
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Tools/RestrictionEnzyme.pm bioperl-1.01/Bio/Tools/RestrictionEnzyme.pm
--- bioperl-1.0/Bio/Tools/RestrictionEnzyme.pm	Thu Feb 28 02:22:51 2002
+++ bioperl-1.01/Bio/Tools/RestrictionEnzyme.pm	Sat May  4 16:28:18 2002
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module Bio::Tools::RestrictionEnzyme
 #
@@ -169,7 +169,7 @@
 
 $ID = 'Bio::Tools::RestrictionEnzyme';
 $version = 0.04;
-$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
+$Revision = '$Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $';  #'
 
 # Generated from REBASE version 802 (strider format), dated Jan 29 98
 # by rebase2perl.pl (JA Feb 98). Merged with previous list by Ewan, Nov 1998
@@ -603,13 +603,12 @@
 sub cut_seq {
 #-------------
     my( $self, $seqObj) = @_;
-
-    # Could check that $seqObj is derived from Seq (Perl 5.004).
-    ref $seqObj || $self->throw( "Can't cut sequence. Missing or invalid object",
-				 "seqObj: $seqObj");
+    if( !ref($seqObj) || 
+	! $seqObj->isa('Bio::PrimarySeqI') ) {
+	$self->throw( "Can't cut sequence. Missing or invalid object".
+		      "seqObj: $seqObj");
+    }
     
-#    print STDERR "$ID: cutting sequence.\n";
-
     my $cuts_after = $self->{'_cuts_after'};
     my ($site_3prime_seq, $site_5prime_seq);
     my $reSeq = $self->seq;
@@ -624,20 +623,20 @@
 	$site_5prime_seq = $reSeq->subseq($self->{'_cuts_after'}+1, $reSeq->length);
     }
 
-#    print STDERR "3' site: $site_3prime_seq\n5' site: $site_5prime_seq\n";
+    $self->debug("3' site: $site_3prime_seq\n5' site: $site_5prime_seq\n");
 
     my(@re_frags);
-    my $seq = $self->_expanded_string;
+    my $seq = uc $self->_expanded_string;
 
     if(!$self->palindromic and $self->name ne 'N') {
 	my $revseq = $self->_expanded_string( $reSeq->revcom );
-	$seq .= '|'.$revseq;
+	$seq .= '|'.uc($revseq);
     }
-#    printf "$ID: site seq: %s\n\n", $seq;
-#    printf "$ID: splitting %s\n\n",$reSeq->str;
-    @re_frags = split(/$seq/, $seqObj->seq);
+    $self->debug(sprintf("$ID: site seq: %s\n\n", $seq));
+    $self->debug(sprintf("$ID: splitting %s\n\n",$reSeq->seq));
+    @re_frags = split(/$seq/, uc $seqObj->seq);
 
-#    print "$ID: cut_seq, ",scalar @re_frags, " fragments.\n";
+    $self->debug("$ID: cut_seq, ".scalar @re_frags. " fragments.\n");
 
     ## Re-attach the split recognition site back to the frags
     ## since perl zapped them in the split() call.
diff -Naur bioperl-1.0/Bio/Tools/Run/EMBOSSApplication.pm bioperl-1.01/Bio/Tools/Run/EMBOSSApplication.pm
--- bioperl-1.0/Bio/Tools/Run/EMBOSSApplication.pm	Mon Mar  4 17:09:04 2002
+++ bioperl-1.01/Bio/Tools/Run/EMBOSSApplication.pm	Sat May  4 16:28:19 2002
@@ -1,4 +1,4 @@
- # $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+ # $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Tools::Run::EMBOSSApplication
 #
@@ -137,7 +137,7 @@
 
 sub run {
     my ($self, $input) = @_;
-
+    $self->{'_io'}->_io_cleanup();
     # test input
     print Dumper($input) if $self->verbose > 0;
     $self->_acd2input($input);
diff -Naur bioperl-1.0/Bio/Tools/SeqWords.pm bioperl-1.01/Bio/Tools/SeqWords.pm
--- bioperl-1.0/Bio/Tools/SeqWords.pm	Mon Nov 19 21:09:40 2001
+++ bioperl-1.01/Bio/Tools/SeqWords.pm	Fri Apr 12 00:10:15 2002
@@ -1,3 +1,4 @@
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 #---------------------------------------------------------------------------
 # PACKAGE    : SeqWords.pm
@@ -22,45 +23,45 @@
 
 =head1 SYNOPSIS
 
-Take a sequence object from eg, an inputstream, and creates an object 
+Take a sequence object from eg, an inputstream, and creates an object
 for the purposes of holding n-mer word statistics about that sequence.
-The sequence can be nucleic acid or protein, but the module is probably
-most relevant for DNA.  The words are counted in a non-overlapping manner,
-ie. in the style of a codon table, but with any word length.
-For overlapping word counts, a sequence can be 'shifted' to remove the first
-character and then the count repeated.  For counts on opposite strand
-(DNA/RNA),
-a reverse complement method should be performed, and then the count
-repeated.
+The sequence can be nucleic acid or protein, but the module is
+probably most relevant for DNA.  The words are counted in a
+non-overlapping manner, ie. in the style of a codon table, but with
+any word length.  For overlapping word counts, a sequence can be
+'shifted' to remove the first character and then the count repeated.
+For counts on opposite strand (DNA/RNA), a reverse complement method
+should be performed, and then the count repeated.
 
 Creating the SeqWords object, eg:
 
-	my $inputstream = Bio::SeqIO->new( -file => "seqfile", -format =>
-'Fasta');
-	my $seqobj = $inputstream->next_seq();
-	my $seq_word = Bio::Tools::SeqWords->new(-seq => $seqobj);
+  my $inputstream = Bio::SeqIO->new( -file => "seqfile", 
+	                             -format => 'Fasta');
+  my $seqobj = $inputstream->next_seq();
+  my $seq_word = Bio::Tools::SeqWords->new(-seq => $seqobj);
 
 or:
 
-	my $seqobj = Bio::PrimarySeq->new(-seq=>'[cut and paste a sequence here]', 
-                                          -alphabet = 'dna', -id = 'test');
-	my $seq_word  =  Bio::Tools::SeqWords->new(-seq => $seqobj);
+  my $seqobj = Bio::PrimarySeq->new(-seq=>'[cut and paste a sequence here]', 
+                                    -alphabet => 'dna', 
+                                    -id => 'test');
+  my $seq_word  =  Bio::Tools::SeqWords->new(-seq => $seqobj);
 
 obtain a hash of word counts, eg:
 
-	my $hash_ref = $seq_stats->count_words($word_length);
+  my $hash_ref = $seq_stats->count_words($word_length);
 
 display hash table, eg:
 
-	my %hash = %$hash_ref;
-	foreach my $key(sort keys %hash)
-	{
-		print "\n$key\t$hash{$key}";
-	}
+  my %hash = %$hash_ref;
+  foreach my $key(sort keys %hash)
+  {
+    print "\n$key\t$hash{$key}";
+  }
 
 or	
 
-	my $hash_ref = Bio::SeqWords->count_words($seqobj,$word_length);
+  my $hash_ref = Bio::SeqWords->count_words($seqobj,$word_length);
 
 
 =head1 DESCRIPTION
@@ -91,7 +92,7 @@
 Your participation is much appreciated.
 
   bioperl-l@bioperl.org                 - General discussion
-  http://bio.perl.org/MailList.html             - About the mailing lists
+  http://bio.perl.org/MailList.html     - About the mailing lists
 
 =head2 Reporting Bugs
 
@@ -159,11 +160,10 @@
 	 : will give the hash
 	 : ACCG 1, TCCG 1
  Returns : Reference to a hash in which keys are words (any length) of the
-alphabet
-         : used and values are number of occurrences of the word in the
-sequence.
+         : alphabet used and values are number of occurrences of the word 
+         : in the sequence.
  Args    : Word length as scalar and, reference to sequence object if
-required
+         : required
 
   Throws an exception word length is not a positive integer
   or if word length is longer than the sequence.
@@ -188,11 +188,13 @@
 
 	if($word_length eq "" || $word_length =~ /[a-z]/i)
 	{
-		$self->throw("SeqWords cannot accept non-numeric characters or a null value in the \$word_length variable\n");
+	    $self->throw("SeqWords cannot accept non-numeric characters".
+                         " or a null value in the \$word_length variable\n");
 	}
 	elsif ($word_length <1 || ($word_length - int($word_length)) >0)
 	{
-		$self->throw("SeqWords requires the word length to be a positive integer\n");
+	    $self->throw("SeqWords requires the word length to be a ".
+                         "positive integer\n");
     	}
 	
 	if(! defined($seqobj)) {
@@ -202,7 +204,8 @@
 
 	if($word_length > length($seqstring))
 	{
-	    $self->throw("die in count words, \$word_length is bigger than sequence length\n");
+	    $self->throw("die in count words, \$word_length is bigger ".
+                         "than sequence length\n");
 	}
 	
 	my %codon = ();
diff -Naur bioperl-1.0/Bio/Tree/NodeI.pm bioperl-1.01/Bio/Tree/NodeI.pm
--- bioperl-1.0/Bio/Tree/NodeI.pm	Fri Dec 14 11:40:20 2001
+++ bioperl-1.01/Bio/Tree/NodeI.pm	Sat May  4 16:28:20 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# NodeI.pm,v 1.10 2002/04/18 12:52:46 jason Exp
 #
 # BioPerl module for Bio::Tree::NodeI
 #
@@ -104,7 +104,7 @@
 sub add_Descendent{
    my ($self,@args) = @_;
 
-   $self->_abstractDeath('add_Descendent');
+   $self->throw_not_implemented();
 }
 
 
@@ -121,7 +121,7 @@
 
 sub each_Descendent{
    my ($self) = @_;
-   $self->_abstractDeath('each_Descendent');   
+   $self->throw_not_implemented();
 }
 
 =head2 Decorated Interface methods
@@ -160,7 +160,7 @@
 
 sub is_Leaf{
     my ($self) = @_;
-    $self->_abstractDeath('is_Leaf');
+    $self->throw_not_implemented();
 }
 
 =head2 descendent_count
@@ -218,7 +218,7 @@
    
    if( $self->is_Leaf ) { 
        if( !defined $self->branch_length ) { 
-	   $self->warn(sprintf("Trying to calculate height of a node when a Node (%s) has an undefined branch_length",$self->id || '?' ));
+	   $self->debug(sprintf("Trying to calculate height of a node when a Node (%s) has an undefined branch_length",$self->id || '?' ));
 	   return 0;
        }
        return $self->branch_length;
@@ -228,7 +228,7 @@
        my $s = $subnode->height;
        if( $s > $max ) { $max = $s; }
    }
-   return $max + $self->branch_length;
+   return $max + ($self->branch_length || 0);
 }
 
 =head2 Get/Set methods
@@ -249,7 +249,7 @@
 
 sub branch_length{
     my ($self)= @_;
-    $self->_abstractDeath('branch_length');
+    $self->throw_not_implemented();
 }
 
 =head2 id
@@ -266,7 +266,7 @@
 
 sub id{
     my ($self)= @_;
-    $self->_abstractDeath;
+    $self->throw_not_implemented();
 }
 
 =head2 description
@@ -283,7 +283,7 @@
 
 sub description{
     my ($self) = @_;
-    $self->_abstractDeath;
+    $self->throw_not_implemented();
 }
 
 =head2 bootstrap
@@ -300,7 +300,7 @@
 
 sub bootstrap{
     my ($self) = @_;
-    $self->_abstractDeath;
+    $self->throw_not_implemented();
 }
 
 =head2 ancestor
@@ -316,7 +316,7 @@
 #'
 sub ancestor{
    my ($self,@args) = @_;
-   $self->_abstractDeath;
+    $self->throw_not_implemented();
 }
 
 1;
diff -Naur bioperl-1.0/Bio/Tree/TreeI.pm bioperl-1.01/Bio/Tree/TreeI.pm
--- bioperl-1.0/Bio/Tree/TreeI.pm	Mon Dec 10 11:10:27 2001
+++ bioperl-1.01/Bio/Tree/TreeI.pm	Sat May  4 16:28:20 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# TreeI.pm,v 1.7 2002/04/18 12:52:46 jason Exp
 #
 # BioPerl module for Bio::Tree::TreeI
 #
@@ -88,7 +88,7 @@
 
 sub get_nodes{
    my ($self) = @_;
-   $self->_abstractDeath('get_nodes');
+   $self->throw_not_implemented();
 }
 
 =head2 get_root_node
@@ -104,7 +104,7 @@
 
 sub get_root_node{
    my ($self) = @_;
-   $self->_abstractDeath('get_root_node');
+   $self->throw_not_implemented();
 }
 
 =head2 number_nodes
@@ -141,7 +141,7 @@
 
 sub branch_length {
    my ($self) = @_;
-   $self->_abstractDeath('branch_length');
+   $self->throw_not_implemented();
 }
 
 =head2 height
diff -Naur bioperl-1.0/Bio/TreeIO/newick.pm bioperl-1.01/Bio/TreeIO/newick.pm
--- bioperl-1.0/Bio/TreeIO/newick.pm	Mon Dec 10 11:10:28 2001
+++ bioperl-1.01/Bio/TreeIO/newick.pm	Sat May  4 16:28:20 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::TreeIO::newick
 #
@@ -108,30 +108,55 @@
 
    my $chars = '';
    $self->_eventHandler->start_document;
+   my $lastevent = '';
    foreach my $ch ( split(//,$_) ) {
        if( $ch eq ';' ) { 	   
 	   return $self->_eventHandler->end_document;
        } elsif( $ch eq '(' ) {
 	   $chars = '';
-	   $self->_eventHandler->start_element( {'Name' => 'tree'} )
+	   $self->_eventHandler->start_element( {'Name' => 'tree'} );
+	   $lastevent = $ch;
        } elsif($ch eq ')' ) {
-	   $self->_eventHandler->characters($chars);
-	   $self->_eventHandler->end_element( {'Name' => 'branch_length'});
-	   $self->_eventHandler->end_element( {'Name' => 'node'} );
+	   if( $chars ) {
+	       if( $lastevent eq ':' ) {
+		   $self->_eventHandler->start_element( { 'Name' => 'branch_length'});
+		   $self->_eventHandler->characters($chars);
+		   $self->_eventHandler->end_element( {'Name' => 'branch_length'});
+	       } else { 
+		   $self->debug($chars."\n");
+		   $self->_eventHandler->start_element( { 'Name' => 'node' } );
+		   $self->_eventHandler->start_element( { 'Name' => 'id' } );
+		   $self->_eventHandler->characters($chars);
+		   $self->_eventHandler->end_element( { 'Name' => 'id' } );
+	       }	   	   
+	       $self->_eventHandler->end_element( {'Name' => 'node'} );
+	   }
 	   $self->_eventHandler->end_element( {'Name' => 'tree'} );
 	   $chars = '';
+	   $lastevent = $ch;
        } elsif ( $ch eq ',' ) {
-	   $self->_eventHandler->characters($chars);
-	   $self->_eventHandler->end_element( {'Name' => 'branch_length'});
-	   $self->_eventHandler->end_element( {'Name' => 'node'} );
+	   if( $chars ) {
+	       if( $lastevent eq ':' ) {
+		   $self->_eventHandler->start_element( { 'Name' => 'branch_length'});
+		   $self->_eventHandler->characters($chars);
+		   $self->_eventHandler->end_element( {'Name' => 'branch_length'});
+	       } else { 
+		   $self->_eventHandler->start_element( { 'Name' => 'node' } );
+		   $self->_eventHandler->start_element( { 'Name' => 'id' } );
+		   $self->_eventHandler->characters($chars);
+		   $self->_eventHandler->end_element( { 'Name' => 'id' } );
+	       }
+	       $self->_eventHandler->end_element( {'Name' => 'node'} );
+	   }
 	   $chars = '';
+	   $lastevent = $ch;
        } elsif( $ch eq ':' ) {
 	   $self->_eventHandler->start_element( { 'Name' => 'node' } );
 	   $self->_eventHandler->start_element( { 'Name' => 'id' } );	   
 	   $self->_eventHandler->characters($chars);
-	   $self->_eventHandler->end_element( { 'Name' => 'id' } );
-	   $self->_eventHandler->start_element( { 'Name' => 'branch_length'});
+	   $self->_eventHandler->end_element( { 'Name' => 'id' } );	   
 	   $chars = '';
+	   $lastevent = $ch;
        } else { 	   
 	   $chars .= $ch;
        } 
diff -Naur bioperl-1.0/Bio/Variation/AAChange.pm bioperl-1.01/Bio/Variation/AAChange.pm
--- bioperl-1.0/Bio/Variation/AAChange.pm	Mon Feb 18 12:17:25 2002
+++ bioperl-1.01/Bio/Variation/AAChange.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Variation::AAChange
 #
@@ -160,9 +160,7 @@
 
 sub new {
     my($class,@args) = @_;
-    my $self;
-    $self = {};
-    bless $self, $class;
+    my $self = $class->SUPER::new(@args);
 
     my ($start, $end, $length, $strand, $primary, $source, 
 	$frame, $score, $gff_string,
@@ -195,34 +193,34 @@
 				  ISMUTATION
 				  )],@args);
     
-    $self->SUPER::primary_tag("Variation");
+    $self->primary_tag("Variation");
 
     $self->{ 'alleles' } = [];
 
-    $start && $self->SUPER::start($start);
-    $end   && $self->SUPER::end($end);
-    $length && $self->SUPER::length($length);
-    $strand && $self->SUPER::strand($strand);
-    $primary && $self->SUPER::primary_tag($primary);
-    $source  && $self->SUPER::source_tag($source);
-    $frame   && $self->SUPER::frame($frame);
-    $score   && $self->SUPER::score($score);
-    $gff_string && $self->SUPER::_from_gff_string($gff_string);
-
-    $allele_ori && $self->SUPER::allele_ori($allele_ori);
-    $allele_mut  && $self->SUPER::allele_mut($allele_mut);
-    $upstreamseq  && $self->SUPER::upstreamseq($upstreamseq);
-    $dnstreamseq  && $self->SUPER::dnstreamseq($dnstreamseq);
+    $start && $self->start($start);
+    $end   && $self->end($end);
+    $length && $self->length($length);
+    $strand && $self->strand($strand);
+    $primary && $self->primary_tag($primary);
+    $source  && $self->source_tag($source);
+    $frame   && $self->frame($frame);
+    $score   && $self->score($score);
+    $gff_string && $self->_from_gff_string($gff_string);
+
+    $allele_ori && $self->allele_ori($allele_ori);
+    $allele_mut  && $self->allele_mut($allele_mut);
+    $upstreamseq  && $self->upstreamseq($upstreamseq);
+    $dnstreamseq  && $self->dnstreamseq($dnstreamseq);
 
     $label  && $self->label($label);
-    $status  && $self->SUPER::status($status);
-    $proof && $self->SUPER::proof($proof);
-    $region  && $self->SUPER::region($region);
-    $region_value  && $self->SUPER::region_value($region_value);
-    $region_dist  && $self->SUPER::region_dist($region_dist);
-    $numbering && $self->SUPER::numbering($numbering);
-    $mut_number && $self->SUPER::mut_number($mut_number);
-    $ismutation && $self->SUPER::isMutation($ismutation);
+    $status  && $self->status($status);
+    $proof && $self->proof($proof);
+    $region  && $self->region($region);
+    $region_value  && $self->region_value($region_value);
+    $region_dist  && $self->region_dist($region_dist);
+    $numbering && $self->numbering($numbering);
+    $mut_number && $self->mut_number($mut_number);
+    $ismutation && $self->isMutation($ismutation);
 
     return $self; # success - we hope!
 }
diff -Naur bioperl-1.0/Bio/Variation/AAReverseMutate.pm bioperl-1.01/Bio/Variation/AAReverseMutate.pm
--- bioperl-1.0/Bio/Variation/AAReverseMutate.pm	Mon Nov 19 21:09:45 2001
+++ bioperl-1.01/Bio/Variation/AAReverseMutate.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Variation::AAReverseMutate
 #
@@ -101,9 +101,7 @@
 
 sub new {
     my($class,@args) = @_;
-    my $self;
-    $self = {};
-    bless $self, $class;
+    my $self = $class->SUPER::new(@args);
 
   my ($aa_ori, $aa_mut, $codon_ori, $codon_table) =
       $self->_rearrange([qw(AA_ORI
diff -Naur bioperl-1.0/Bio/Variation/Allele.pm bioperl-1.01/Bio/Variation/Allele.pm
--- bioperl-1.0/Bio/Variation/Allele.pm	Mon Feb 18 12:17:25 2002
+++ bioperl-1.01/Bio/Variation/Allele.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Variation::Allele
 #
@@ -91,40 +91,22 @@
 
 @ISA = qw( Bio::PrimarySeq Bio::DBLinkContainerI );
 
-sub _initialize {
-    my($self, @args) = @_;
+sub new {
+    my($class, @args) = @_;
+    my $self = $class->SUPER::new(@args);
 
-    my($seq,$id,$acc,$pid,$desc,$alphabet,$given_id, 
-       $is_reference, $repeat_unit, $repeat_count) =
-	   $self->_rearrange([qw(SEQ
-				 DISPLAY_ID
-				 ACCESSION_NUMBER
-				 PRIMARY_ID
-				 DESC
-				 ALPHABET
-				 ID
-				 IS_REFERENCE
+    my($is_reference, $repeat_unit, $repeat_count) =
+	   $self->_rearrange([qw(IS_REFERENCE
 				 REPEAT_UNIT
 				 REPEAT_COUNT
 				 )],
 			     @args);
 
-    my $make = $self->SUPER::_initialize(@args);
-
-    if( defined $given_id ) { $id = $given_id; }
-
-    $seq     && $self->SUPER::seq($seq);
-    $id      && $self->SUPER::display_id($id);
-    $acc     && $self->SUPER::accession_number($acc);
-    $pid     && $self->SUPER::primary_id($pid);
-    $desc    && $self->SUPER::desc($desc);
-    $alphabet && $self->SUPER::alphabet($alphabet);
-
     $is_reference && $self->is_reference($is_reference);
     $repeat_unit && $self->repeat_unit($repeat_unit);
     $repeat_count && $self->repeat_count($repeat_count);
 
-    return $make; # success - we hope!
+    return $self; # success - we hope!
 }
 
 
diff -Naur bioperl-1.0/Bio/Variation/DNAMutation.pm bioperl-1.01/Bio/Variation/DNAMutation.pm
--- bioperl-1.0/Bio/Variation/DNAMutation.pm	Mon Feb 18 12:17:25 2002
+++ bioperl-1.01/Bio/Variation/DNAMutation.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Variation::DNAMutation
 #
@@ -102,9 +102,7 @@
 
 sub new {
     my($class,@args) = @_;
-    my $self;
-    $self = {};
-    bless $self, $class;
+    my $self = $class->SUPER::new(@args);
     
     my ($start, $end, $length, $strand, $primary, $source, 
 	$frame, $score, $gff_string,
@@ -137,34 +135,34 @@
 				  )],
 			      @args);
 
-    $self->SUPER::primary_tag("Variation");
+    $self->primary_tag("Variation");
 
     $self->{ 'alleles' } = [];
 
-    $start && $self->SUPER::start($start);
-    $end   && $self->SUPER::end($end);
-    $length && $self->SUPER::length($length);
-    $strand && $self->SUPER::strand($strand);
-    $primary && $self->SUPER::primary_tag($primary);
-    $source  && $self->SUPER::source_tag($source);
-    $frame   && $self->SUPER::frame($frame);
-    $score   && $self->SUPER::score($score);
-    $gff_string && $self->SUPER::_from_gff_string($gff_string);
+    $start && $self->start($start);
+    $end   && $self->end($end);
+    $length && $self->length($length);
+    $strand && $self->strand($strand);
+    $primary && $self->primary_tag($primary);
+    $source  && $self->source_tag($source);
+    $frame   && $self->frame($frame);
+    $score   && $self->score($score);
+    $gff_string && $self->_from_gff_string($gff_string);
     
-    $allele_ori && $self->SUPER::allele_ori($allele_ori);
-    $allele_mut  && $self->SUPER::allele_mut($allele_mut);
-    $upstreamseq  && $self->SUPER::upStreamSeq($upstreamseq);
-    $dnstreamseq  && $self->SUPER::dnStreamSeq($dnstreamseq);
+    $allele_ori && $self->allele_ori($allele_ori);
+    $allele_mut  && $self->allele_mut($allele_mut);
+    $upstreamseq  && $self->upStreamSeq($upstreamseq);
+    $dnstreamseq  && $self->dnStreamSeq($dnstreamseq);
     
     $label  && $self->label($label);
-    $status  && $self->SUPER::status($status);
-    $proof && $self->SUPER::proof($proof);
-    $region  && $self->SUPER::region($region);
-    $region_value  && $self->SUPER::region_value($region_value);
-    $region_dist  && $self->SUPER::region_dist($region_dist);
-    $numbering && $self->SUPER::numbering($numbering);
-    $mut_number && $self->SUPER::mut_number($mut_number);
-    $ismutation && $self->SUPER::isMutation($ismutation);
+    $status  && $self->status($status);
+    $proof && $self->proof($proof);
+    $region  && $self->region($region);
+    $region_value  && $self->region_value($region_value);
+    $region_dist  && $self->region_dist($region_dist);
+    $numbering && $self->numbering($numbering);
+    $mut_number && $self->mut_number($mut_number);
+    $ismutation && $self->isMutation($ismutation);
 
     $cpg && $self->CpG($cpg);
     
diff -Naur bioperl-1.0/Bio/Variation/RNAChange.pm bioperl-1.01/Bio/Variation/RNAChange.pm
--- bioperl-1.0/Bio/Variation/RNAChange.pm	Mon Feb 18 12:17:25 2002
+++ bioperl-1.01/Bio/Variation/RNAChange.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #
 # BioPerl module for Bio::Variation::RNAChange
 #
@@ -115,13 +115,11 @@
 
 sub new {
     my($class,@args) = @_;
-    my $self;
-    $self = {};
-    bless $self, $class;
-
-    my ($start, $end, $length, $strand, $primary, $source, 
-	$frame, $score, $gff_string,
-	$allele_ori,  $allele_mut,  $upstreamseq,  $dnstreamseq,  
+    my $self = $class->SUPER::new(@args);
+
+    my ($start, $end, $length, $strand, $primary, $source,
+        $frame, $score, $gff_string,
+        $allele_ori,  $allele_mut,  $upstreamseq,  $dnstreamseq,
 	$label,  $status,  $proof,  $region,  $region_value, $region_dist, $numbering,
 	$mut_number,  $isMutation,
 	$codon_ori, $codon_mut, $codon_pos, $codon_table, $cds_end) =
@@ -158,30 +156,30 @@
     
     $self->{ 'alleles' } = [];
     
-    $start && $self->SUPER::start($start);
-    $end   && $self->SUPER::end($end);
-    $length && $self->SUPER::length($length);
-    $strand && $self->SUPER::strand($strand);
-    $primary && $self->SUPER::primary_tag($primary);
-    $source  && $self->SUPER::source_tag($source);
-    $frame   && $self->SUPER::frame($frame);
-    $score   && $self->SUPER::score($score);
-    $gff_string && $self->SUPER::_from_gff_string($gff_string);
+    $start && $self->start($start);
+    $end   && $self->end($end);
+    $length && $self->length($length);
+    $strand && $self->strand($strand);
+    $primary && $self->primary_tag($primary);
+    $source  && $self->source_tag($source);
+    $frame   && $self->frame($frame);
+    $score   && $self->score($score);
+    $gff_string && $self->_from_gff_string($gff_string);
     
-    $allele_ori && $self->SUPER::allele_ori($allele_ori);
-    $allele_mut  && $self->SUPER::allele_mut($allele_mut);
-    $upstreamseq  && $self->SUPER::upStreamSeq($upstreamseq);
-    $dnstreamseq  && $self->SUPER::dnStreamSeq($dnstreamseq);
+    $allele_ori && $self->allele_ori($allele_ori);
+    $allele_mut  && $self->allele_mut($allele_mut);
+    $upstreamseq  && $self->upStreamSeq($upstreamseq);
+    $dnstreamseq  && $self->dnStreamSeq($dnstreamseq);
     
     $label  && $self->label($label);
-    $status  && $self->SUPER::status($status);
-    $proof && $self->SUPER::proof($proof);
+    $status  && $self->status($status);
+    $proof && $self->proof($proof);
     $region  && $self->region($region);
-    $region_value  && $self->SUPER::region_value($region_value);
-    $region_dist  && $self->SUPER::region_dist($region_dist);
-    $numbering && $self->SUPER::numbering($numbering);
-    $mut_number && $self->SUPER::mut_number($mut_number);
-    $isMutation && $self->SUPER::isMutation($isMutation);
+    $region_value  && $self->region_value($region_value);
+    $region_dist  && $self->region_dist($region_dist);
+    $numbering && $self->numbering($numbering);
+    $mut_number && $self->mut_number($mut_number);
+    $isMutation && $self->isMutation($isMutation);
     
     $codon_ori  && $self->codon_ori($codon_ori);
     $codon_mut  && $self->codon_mut($codon_mut);
@@ -220,7 +218,7 @@
     elsif (! $self->{'codon_ori'}) {
 	my $codon_ori = '';
 
-	if ($self->region eq 'coding' and $self->start >= 1) {
+	if ($self->region eq 'coding' && $self->start && $self->start  >= 1) {
 	    
 	    $self->warn('Codon position is not defined') 
 		if not defined $self->codon_pos;
@@ -469,10 +467,10 @@
 	    if not defined $self->cds_end and $self->verbose;
 	
 	$self->region('coding');
-	if ($self->end < 0 ){
+	if ($self->end && $self->end < 0 ){
 	    $self->region('5\'UTR');
 	}
-	elsif ($self->cds_end and $self->start > $self->cds_end ) {
+	elsif ($self->start && $self->cds_end && $self->start > $self->cds_end ) {
 	    $self->region('3\'UTR');
 	}
     }
diff -Naur bioperl-1.0/Bio/Variation/SeqDiff.pm bioperl-1.01/Bio/Variation/SeqDiff.pm
--- bioperl-1.0/Bio/Variation/SeqDiff.pm	Mon Feb 18 12:17:25 2002
+++ bioperl-1.01/Bio/Variation/SeqDiff.pm	Wed Mar 20 08:08:24 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 # bioperl module for Bio::Variation::SeqDiff
 #
 # Cared for by Heikki Lehvaslaiho <heikki@ebi.ac.uk>
@@ -116,9 +116,7 @@
 
 sub new {
     my($class,@args) = @_;
-    my $self;
-    $self = {};
-    bless $self, $class;
+    my $self = $class->SUPER::new(@args);
 
     my($id, $sysname, $trivname, $chr, $gene_symbol, 
        $desc, $alphabet, $numbering, $offset, $rna_offset, $rna_id, $cds_end,
diff -Naur bioperl-1.0/FAQ bioperl-1.01/FAQ
--- bioperl-1.0/FAQ	Fri Mar  8 15:36:25 2002
+++ bioperl-1.01/FAQ	Sat May  4 16:28:06 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 Bioperl FAQ
 -----------
@@ -42,7 +42,7 @@
 ------------------------------------------------------------------------
 This FAQ maintained by those listed below:
 Jason Stajich <jason@bioperl.org>
-Brian Osborne <b_i_osborne@hotmail.com>
+Brian Osborne <brian_osborne@cognia.com>
 
 ------------------------------------------------------------------------
 I. Bioperl in general
@@ -80,41 +80,44 @@
      developer releases.  These are snapshots of the actively
      developed code that at a minimum pass all our tests 
 
+     But really, you should be using version 1.*!
+
   4.  Is it BioPerl, bioperl, bio.perl.org, Bioperl?  What's the deal?
 
-      Well, the perl.org guys granted us use of bio.perl.org.  We
-      prefer to be called Bioperl or BioPerl (unlike our Biopython
-      friends).  We're part of the Open Bioinformatics Foundation
-      (OBF) and so as part of the Bio{*} toolkits we prefer the
-      Bioperl spelling.  But we're not really all that picky so no worries. 
+     Well, the perl.org guys granted us use of bio.perl.org.  We
+     prefer to be called Bioperl or BioPerl (unlike our Biopython
+     friends).  We're part of the Open Bioinformatics Foundation
+     (OBF) and so as part of the Bio{*} toolkits we prefer the
+     Bioperl spelling.  But we're not really all that picky so no worries. 
    
   5.  How do I figure out how to use a module?
 
-      Read the embedded perl documentation (Plain Old Documentation -
-      POD) that is part of every modules.  Do
-      % perldoc MODULE 
-      (careful - spelling and case counts!).
-
-      The bioperl tutorial - bptutorial.pl - provided in the root
-      directory of the bioperl release will also provide a good
-      introduction.  There are links to tutorials off the bioperl
-      website that may provide some additional help.
+     Read the embedded perl documentation (Plain Old Documentation -
+     POD) that is part of every modules.  Do
+     % perldoc MODULE 
+     (careful - spelling and case counts!).
+
+     The bioperl tutorial - bptutorial.pl - provided in the root
+     directory of the bioperl release will also provide a good
+     introduction.  There are links to tutorials off the bioperl
+     website that may provide some additional help.
  
-      There are also many scripts in the examples/ and scripts/
-      directories that could be useful - see bioperl.pod for a brief
-      description of all of them.
-
-      Additionally we have written many tests for our modules, you
-      can see test data and example usage of the modules in these
-      tests - look in the test dir (called 't').
+     There are also many scripts in the examples/ and scripts/
+     directories that could be useful - see bioperl.pod for a brief
+     description of all of them.
+
+     Additionally we have written many tests for our modules, you
+     can see test data and example usage of the modules in these
+     tests - look in the test dir (called 't').
 
   6.  I'm interested in the bleeding edge version of the code, where
       can I get it?
       
-      Go to http://cvs.bioperl.org and you'll see instructions on how
-      to get the CVS code.
+     Go to http://cvs.bioperl.org and you'll see instructions on how
+     to get the CVS code.
+
+     Basically:
 
-      Basically:
       % cvs -d :pserver:cvs@cvs.bioperl.org:/home/repository/bioperl login
       enter 'cvs' for the password
       % cvs -d :pserver:cvs@cvs.bioperl.org:/home/repository/bioperl
@@ -122,25 +125,25 @@
 
   7.  Who uses this toolkit?
 
-      Lots of people.  Sanger Centre, EBI, many large and small
-      academic laboratories, large and small pharmaceutical companies.
-      All the developers on the bioperl list use the toolkit in some
-      capacity on a regular basis.
+     Lots of people.  Sanger Centre, EBI, many large and small
+     academic laboratories, large and small pharmaceutical companies.
+     All the developers on the bioperl list use the toolkit in some
+     capacity on a regular basis.
       
-      The Genquire annotation system (www.bioinformatics.org/Genquire/)
-      and Ensembl (www.ensembl.org) use bioperl as the basis for their
-      implementation. 
+     The Genquire annotation system (www.bioinformatics.org/Genquire/)
+     and Ensembl (www.ensembl.org) use bioperl as the basis for their
+     implementation. 
         
   8.  How should I cite Bioperl?
 
-      For now cite it as "The Bioperl Project, http://www.bioperl.org".      
+     For now cite it as "The Bioperl Project, http://www.bioperl.org".      
       
   9.  What are the License terms for Bioperl?
 
-      Bioperl is licensed under the same terms as Perl itself which is
-      the Perl Artistic License.  You can see more information on that
-      license at http://www.perl.com/pub/a/language/misc/Artistic.html
-      and http://www.opensource.org/licenses/artistic-license.html
+     Bioperl is licensed under the same terms as Perl itself which is
+     the Perl Artistic License.  You can see more information on that
+     license at http://www.perl.com/pub/a/language/misc/Artistic.html
+     and http://www.opensource.org/licenses/artistic-license.html
             
 
 ------------------------------------------------------------------------
@@ -152,7 +155,6 @@
      Use the Bio::SeqIO system.  This will create Bio::Seq objects for
      you.  See the tutorial bptutorial.pl for more information or the
      documentation for Bio::SeqIO (e.g. 'perldoc SeqIO.pm').
-
 
   2. I can't get sequences with Bio::DB::GenBank any more, why not?
 
diff -Naur bioperl-1.0/MANIFEST bioperl-1.01/MANIFEST
--- bioperl-1.0/MANIFEST	Sat Mar 16 19:03:32 2002
+++ bioperl-1.01/MANIFEST	Fri Apr 12 00:06:47 2002
@@ -81,12 +81,12 @@
 Bio/DB/GFF/Adaptor/dbi/mysql.pm
 Bio/DB/GFF/Adaptor/dbi/mysqlopt.pm
 Bio/DB/GFF/Adaptor/memory.pm
+Bio/DB/GFF/Adaptor/memory_iterator.pm
 Bio/DB/GFF/Aggregator.pm
 Bio/DB/GFF/Aggregator/alignment.pm
 Bio/DB/GFF/Aggregator/clone.pm
 Bio/DB/GFF/Aggregator/none.pm
 Bio/DB/GFF/Aggregator/transcript.pm
-Bio/DB/GFF/Aggregator/wormbase_gene.pm
 Bio/DB/GFF/Featname.pm
 Bio/DB/GFF/Feature.pm
 Bio/DB/GFF/Homol.pm
@@ -406,6 +406,7 @@
 FAQ
 INSTALL
 LICENSE
+Makefile.PL
 MANIFEST
 PLATFORMS
 README
diff -Naur bioperl-1.0/MANIFEST.SKIP bioperl-1.01/MANIFEST.SKIP
--- bioperl-1.0/MANIFEST.SKIP	Fri Jun 15 18:00:56 2001
+++ bioperl-1.01/MANIFEST.SKIP	Wed Dec 31 19:00:00 1969
@@ -1,10 +0,0 @@
-\bCVS\b
-^MANIFEST\.
-^blib/
-\.html$
-\.old$
-\.bak$
-\.dist$
-^pm_to_blib
-bioperl.lisp
-Makefile
\ No newline at end of file
diff -Naur bioperl-1.0/Makefile.PL bioperl-1.01/Makefile.PL
--- bioperl-1.0/Makefile.PL	Sat Mar 16 19:00:47 2002
+++ bioperl-1.01/Makefile.PL	Fri Apr 12 00:11:59 2002
@@ -1,6 +1,6 @@
 ## --Makefile.PL for Bioperl core module distribution--##
 ## ----------------------------------------------------##
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 ##----------------------------------------------------
 
 #
@@ -23,11 +23,11 @@
 	     'XML::Writer'              => '0.0/Parsing + writing of XML documents/Bio::Variation code, GAME parser/Bio::SeqIO::game,Bio::Variation::*',
 	     'XML::Parser::PerlSAX'              => '0.0/Parsing of XML documents/Bio::Variation code, GAME parser/Bio::SeqIO::game,Bio::Variation::*',
 	     'XML::Twig'         	=> '0.0/Available on CPAN/parsing of XML documents/Module Bio::Variation::IO::xml.pm',
-	     'File::Temp'               => '0.0/Temporary File creation/Bio::DB::WebDBSeqI, Bio::Seq::LargePrimarySeq',
+	     'File::Temp'               => '0.0/Temporary File creation/Bio::Root::IO uses if present/Bio::DB::WebDBSeqI, Bio::Seq::LargePrimarySeq',
 	     'SOAP::Lite'               => '0.0/SOAP protocol/XEMBL Services (also Bibliographic queries in Biblio::) /Bio::DB::XEMBLService',
-	     'HTML::Parser'             => '0.0/HTML parsing of GDB page/Bio::DB::GDB',
+	     'HTML::Parser'             => '0.0/HTML parsing/HTML parsing of GDB page/Bio::DB::GDB',
 	     'DBD::mysql'               => '0.0/Mysql driver/loading and querying of Mysql-based GFF feature databases/Bio::DB::GFF',
-	     'GD'                       => '1.3/Graphical Drawing Toolkit/Rendering Sequences and Features/Bio::Graphics',
+	     'GD'                       => '1.19/Graphical Drawing Toolkit/Rendering Sequences and Features/Bio::Graphics',
 	     'Storable'                 => '0.0/Persistent object storage and retrieval/Storing sequence objects in local file cache/Bio::DB::FileCache',
 # rare function let's not scare people
 # 	     'srsperl.pm'               => '0.0/Sequence Retrieval System (SRS) perl API/alternative way of retrieving sequences/Bio::LiveSeq::IO::SRS.pm'
@@ -78,15 +78,22 @@
 # Prompt user for BioGFFDB stuff
 #
 
-if(  eval { require DBI } ) {
-    my $proceed = user_prompt("Do you want to run the BioGFFDB tests (requires mysql) y/n",'n');
-    if( $proceed eq 'y' ) {
-	system("touch t/do_biodbgff.tests");
-    } else { 
-	if( -e "t/do_biodbgff.tests" ) {
-	    unlink "t/do_biodbgff.tests";
-	}
+if(  eval { require DBI } && grep {/mysql/} DBI->available_drivers) {
+  my $proceed = user_prompt("Do you want to run the BioGFFDB tests (requires a mysql database) y/n",'n');
+  if( $proceed =~ /^[yY]/) {
+    my $cfg = {dbd_driver => 'mysql'};
+    GFFQueryDb($cfg,{'prompt'=>1,'verbose'=>1});
+    if (open T,">t/do_biodbgff.tests") {
+      foreach (keys %$cfg) {
+	print T $_,"\t",$cfg->{$_},"\n";
+      }
+      close T;
     }
+  } else {
+    if( -e "t/do_biodbgff.tests" ) {
+      unlink "t/do_biodbgff.tests";
+    }
+  }
 }
 
 sub user_prompt ($;$) {
@@ -101,6 +108,79 @@
     return ($ans ne '') ? $ans : $def;
 }
 
+############################################################################
+#
+#   Name:    GFFQueryDb
+#
+#   Purpose: Query user for settings for running the Bio::DB::GFF test suite
+#
+#   Inputs:  $cfg - Config hash ref
+#
+#   Returns: Nothing; creates
+#            $cfg->{$driver}->{test_(db|host|dsn|user|pass)}
+#
+############################################################################
+
+sub GFFQueryDb {
+  my $cfg     = shift;
+  my $options = shift || {};
+  my $db     = $cfg->{'description'} || $cfg->{'dbd_driver'};
+  my $driver = $cfg->{'dbd_driver'};
+
+  my $d = lc $driver;
+  my $prompt = $options->{'prompt'};
+
+  my $test_db =  exists($options->{"$d-test-db"}) ?
+    $options->{"$d-test-db"} : ($cfg->{'test_db'} || 'test');
+  $test_db = user_prompt
+    ("Which database should I use for testing the $db drivers?",
+     $test_db) if $prompt;
+
+  my $test_host = exists($options->{"$d-test-host"}) ?
+    $options->{"$d-test-host"} : ($cfg->{'test_host'} || 'localhost');
+  $test_host = user_prompt
+    ("On which host is database $test_db running (hostname, ip address or host:port)", $test_host) if $prompt;
+
+  my($test_user, $test_pass);
+
+  $test_user = exists($options->{"$d-test-user"}) ?
+    $options->{"$d-test-user"} : ($cfg->{'test_user'} || "undef");
+  $test_user = user_prompt
+    ("User name for connecting to database $test_db?", $test_user)
+      if $prompt;
+  $test_user = undef if $test_user eq 'undef';
+
+  $test_pass = exists($options->{"$d-test-pass"}) ?
+    $options->{"$d-test-pass"} : ($cfg->{'test_pass'} || "undef");
+  $test_pass = user_prompt
+    ("Password for connecting to database $test_db?", $test_pass)
+      if $prompt;
+  $test_pass = undef if $test_pass eq 'undef';
+
+  $cfg->{'test_db'}   = $test_db;
+  $cfg->{'test_host'} = $test_host;
+  $cfg->{'test_user'} = $test_user;
+  $cfg->{'test_pass'} = $test_pass;
+  if ($test_host eq 'undef'  ||  $test_host eq 'localhost') {
+    $test_host = '';
+  }
+  my $test_dsn = "DBI:$driver:database=$test_db";
+  $cfg->{test_dsn} = $test_dsn;
+  if ($test_host) {
+    $cfg->{'test_dsn'} .= ";host=$test_host";
+  }
+
+
+  if ($options->{'verbose'}) {
+    local $^W=0;  # some uninitialized variable warning coming through
+    print("Driver $driver is using the following settings for tests:\n",
+	  "    Database $test_db\n",
+	  "    Host     $test_host\n",
+	  "    DSN      $test_dsn\n",
+	  "    User     $test_user\n",
+	  "    Password $test_pass\n");
+  }
+}
 
 				           
 #
@@ -115,13 +195,11 @@
 $do_autoload_finesse = 0;
 $NAME     = 'Bio';
 $DISTNAME = "bioperl";
-$VERSION  = "1.00";
+$VERSION  = "1.01";
 
 if( $do_autoload_finesse == 1 ) {
     fatal("Autoload finessing does not work at the moment!");
 }
-
-
 
 @BACKUP_FILES = qw(./Seq.pm.bak);
 
diff -Naur bioperl-1.0/biodesign.pod bioperl-1.01/biodesign.pod
--- bioperl-1.0/biodesign.pod	Sun Mar  3 21:00:34 2002
+++ bioperl-1.01/biodesign.pod	Sat May  4 16:28:07 2002
@@ -47,10 +47,13 @@
 give you idea why the person who wrote the module wrote it - and this
 will be the frame work in which you can understand his or her answer.
 
-You might also want to examine the models, or class diagrams, in the models/
+You might also want to examine the models, or class diagrams, in the models
 directory. These diagrams are not guaranteed to include every single class
 but may help you understand the overall layout of Bioperl's modules.
 
+Documentation on Bio::Root can also be found in the form of scripts - check
+the examples/root_object directory for a start.
+
 =head2 Respect people's code (in particular if it works)
 
 If the code does what you want, the fact that it is not written the
@@ -114,27 +117,27 @@
 
 =head1 Bioperl Bio::Root::Root Object
 
-All objects in Bioperl (but for interfaces - see L<Bioperl Interface design>)
-inherit from the Bio::Root::Root. The Bioperl root object allows a number of
-very useful concepts to be provided. In particular.
+All objects in Bioperl (but for interfaces) inherit from the Bio::Root::Root.
+The Bioperl root object allows a number of very useful concepts to be provided.
+In particular.
 
 =over 3
 
 =item exceptions, warning, and debugging
 
-  The Bioperl Root object allows exceptions to be throw on the object
+The Bioperl Root object allows exceptions to be throw on the object
 with very nice debugging output.  These are throw by calling the
 method throw() and passing in the message string.  This will cause the
 execution of the script to die with a stack trace.
-  
-   Similarly the warn() method can be called which will produce a
+
+Similarly the warn() method can be called which will produce a
 warning message - use this instead of print for warning messages to
 the user because if the verbose flag is set to -1 warnings will be
 skipped.  Additionally setting the verbose flag to 1 will print a
 stack trace for every warning in addition to the message and setting
 verbose to 2 will convert warnings into thrown exceptions.
 
-   Finally, the the debug() method prints messages to STDERR when the
+Finally, the the debug() method prints messages to STDERR when the
 verbose flag is set to 1.
 
 =item rearrange
@@ -165,16 +168,15 @@
 
 The full code is given below for a basic skeleton object that uses bioperl.
 
-   # convention is that if you are using the Bio::Root object you
-   # should put it inside the Bio namespace
+  # convention is that if you are using the Bio::Root object you
+  # should put it inside the Bio namespace
 
-   package Bio::MyNewObject;
-   use vars qw(@ISA);
-   use strict;
-
-   use Bio::Root::Root;
-   @ISA = qw(Bio::Root::Root);
+  package Bio::MyNewObject;
+  use vars qw(@ISA);
+  use strict;
 
+  use Bio::Root::Root;
+  @ISA = qw(Bio::Root::Root);
 
   sub new {
      my($class,@args) = @_;
@@ -184,7 +186,7 @@
      # do your own argument processing here
 
      my ($arg1) = $self->_rearrange([qw(NAMEDARGUMENT1)], @args);
-     
+
      # set default attributes etc...
 	
      return $self;
@@ -402,7 +404,8 @@
 the creation of many objects and can perform poorly.  One can work
 around this by creating the hashes directly and NOT chaining the new
 calls.  An example of this is implemented in the Bio::SeqIO::FTHelper
-objects in the treatment of Location objects for features.
+objects in the treatment of Location objects for features. Please see
+L<Bio::SeqIO::FTHelper> for details.
 
 =head1 Getting Started
 
diff -Naur bioperl-1.0/bioperl.lisp bioperl-1.01/bioperl.lisp
--- bioperl-1.0/bioperl.lisp	Mon Jan 28 15:14:14 2002
+++ bioperl-1.01/bioperl.lisp	Wed Dec 31 19:00:00 1969
@@ -1,126 +0,0 @@
-
-;; Perl mode set up
-
-(assoc "\\.pl$" auto-mode-alist)
-(setq auto-mode-alist (cons '("\\.pl$" . perl-mode) auto-mode-alist))
-
-(assoc "\\.pm$" auto-mode-alist)
-(setq auto-mode-alist (cons '("\\.pm$" . perl-mode) auto-mode-alist))
-
-(defun perl-insert-start ()
-  "Places #!..perl at the start of the script"
-  (interactive)
-  (goto-char (point-min))
-  (insert "#!/usr/local/bin/perl\n"))
-
-
-(defun bioperl-object-start (perl-object-name perl-caretaker-name caretaker-email)
-  "Places standard bioperl object notation headers and footers"
-  (interactive "sName of Object: \nsName of caretaker: \nsEmail: ")
-  (insert "# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $\n#\n# BioPerl module for " perl-object-name "\n#\n# Cared for by " perl-caretaker-name " <" caretaker-email ">\n#\n# Copyright " perl-caretaker-name "\n#\n# You may distribute this module under the same terms as perl itself\n\n")
-  (insert "# POD documentation - main docs before the code\n\n")
-  (insert "=head1 NAME\n\n" perl-object-name " - DESCRIPTION of Object\n\n")
-  (insert "=head1 SYNOPSIS\n\nGive standard usage here\n\n")
-  (insert "=head1 DESCRIPTION\n\nDescribe the object here\n\n")
-  (insert "=head1 FEEDBACK\n\n=head2 Mailing Lists\n\n")
-  (insert "User feedback is an integral part of the evolution of this and other\nBioperl modules. Send your comments and suggestions preferably to\nthe Bioperl mailing list.  Your participation is much appreciated.\n\n")
-  (insert "  bioperl-l@bioperl.org              - General discussion\n  http://bioperl.org/MailList.shtml  - About the mailing lists\n\n")
-  (insert "=head2 Reporting Bugs\n\nReport bugs to the Bioperl bug tracking system to help us keep track\nof the bugs and their resolution. Bug reports can be submitted via\nemail or the web:\n\n")
-  (insert "  bioperl-bugs@bioperl.org\n  http://bioperl.org/bioperl-bugs/\n\n")
-  (insert "=head1 AUTHOR - " perl-caretaker-name "\n\nEmail " caretaker-email "\n\nDescribe contact details here\n\n")
-  (insert "=head1 CONTRIBUTORS\n\nAdditional contributors names and emails here\n\n")
-  (insert "=head1 APPENDIX\n\nThe rest of the documentation details each of the object methods.\nInternal methods are usually preceded with a _\n\n=cut\n\n")
-  (insert "\n# Let the code begin...\n\n")
-  (insert "\npackage " perl-object-name ";\n")
-  (insert "use vars qw(@ISA);\n")
-  (insert "use strict;\n")
-  (insert "\n# Object preamble - inherits from Bio::Root::Root\n")
-  (insert "\nuse Bio::Root::Root;\n\n")
-  (insert "\n@ISA = qw(Bio::Root::Root );\n\n")
-  (insert "=head2 new\n\n Title   : new\n Usage   : my $obj = new "
-	  perl-object-name "();\n Function: Builds a new "
-	  perl-object-name " object \n Returns : "
-	  perl-object-name "\n Args    :\n\n\n=cut\n\n")
-  (insert "sub new {\n  my($class,@args) = @_;\n\n  my $self = $class->SUPER::new(@args);\n\n}\n")
-  (insert "\n\n1;")
-  )
-
-(defun bioperl-interface-start (perl-object-name perl-caretaker-name
-						 caretaker-email)
-  "Places standard bioperl object notation headers and footers"
-  (interactive "sName of Object: \nsName of caretaker: \nsEmail: ")
-  (insert "# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $\n#\n# BioPerl module for " perl-object-name "\n#\n# Cared for by " perl-caretaker-name " <" caretaker-email ">\n#\n# Copyright " perl-caretaker-name "\n#\n# You may distribute this module under the same terms as perl itself\n\n")
-  (insert "# POD documentation - main docs before the code\n\n")
-  (insert "=head1 NAME\n\n" perl-object-name " - DESCRIPTION of Interface\n\n")
-  (insert "=head1 SYNOPSIS\n\nGive standard usage here\n\n")
-  (insert "=head1 DESCRIPTION\n\nDescribe the interface here\n\n")
-  (insert "=head1 FEEDBACK\n\n=head2 Mailing Lists\n\n")
-  (insert "User feedback is an integral part of the evolution of this and other\nBioperl modules. Send your comments and suggestions preferably to\nthe Bioperl mailing list.  Your participation is much appreciated.\n\n")
-  (insert "  bioperl-l@bioperl.org              - General discussion\n  http://bioperl.org/MailList.shtml  - About the mailing lists\n\n")
-  (insert "=head2 Reporting Bugs\n\nReport bugs to the Bioperl bug tracking system to help us keep track\nof the bugs and their resolution. Bug reports can be submitted via\nemail or the web:\n\n")
-  (insert "  bioperl-bugs@bioperl.org\n  http://bioperl.org/bioperl-bugs/\n\n")
-  (insert "=head1 AUTHOR - " perl-caretaker-name "\n\nEmail " caretaker-email "\n\nDescribe contact details here\n\n")
-  (insert "=head1 CONTRIBUTORS\n\nAdditional contributors names and emails here\n\n")
-  (insert "=head1 APPENDIX\n\nThe rest of the documentation details each of the object methods.\nInternal methods are usually preceded with a _\n\n=cut\n\n")
-  (insert "\n# Let the code begin...\n\n")
-  (insert "\npackage " perl-object-name ";\n")
-  (insert "use vars qw(@ISA);\n")
-  (insert "use strict;\nuse Carp;\nuse Bio::Root::Root;\n\n")
-  (insert "@ISA = qw( Bio::Root::Root );")
-  )
-
-
-(defun bioperl-method (method-name)
-  "puts in a bioperl method complete with pod boiler-plate"
-  (interactive "smethod name:")
-  (insert "=head2 " method-name "\n\n Title   : " method-name "\n Usage   :\n Function:\n Example :\n Returns : \n Args    :\n\n\n=cut\n\n")
-  (insert "sub " method-name "{\n   my ($self,@args) = @_;\n")
-  (save-excursion 
-    (insert "\n\n}\n"))
-  )
-
-
-(defun bioperl-getset (field-name)
-  "puts in a bioperl method for a get/set method complete with pod boiler-plate"
-  (interactive "sfield name:")
-  (insert "=head2 " field-name "\n\n Title   : " field-name "\n Usage   : $obj->" field-name "($newval)\n Function: \n Example : \n Returns : value of " field-name "\n Args    : newvalue (optional)\n\n\n=cut\n\n")
-  (insert "sub " field-name "{\n   my ($self,$value) = @_;\n   if( defined $value) {\n      $self->{'" field-name "'} = $value;\n    }\n    return $self->{'" field-name "'};\n")
-  (insert "\n}\n"))
-
-
-(defun bioperl-abstract-method (method-name)
-  "puts in a bioperl abstract method for interface classes"
-  (interactive "smethod-name:")
-  (save-excursion 
-  (insert "=head2 " method-name "\n\n Title   : " method-name "\n Usage   :\n Function:\n Example :\n Returns : \n Args    :\n\n\n=cut\n\n")
-  (insert "sub " method-name "{\n   my ($self) = @_;\n\n    $self->throw(\"Abstract method " method-name " implementing class did not provide method\");\n")
-    (insert "\n\n}\n")
-    )
-  )
-
-
-
-(setq perl-mode-hook 
-      '(lambda ()
-	 (define-key perl-mode-map "\C-c\C-h" 'perl-insert-start)
-	 (define-key perl-mode-map "\C-c\C-b" 'bioperl-object-start)
-	 (define-key perl-mode-map "\C-c\C-i" 'bioperl-interface-start)
-	 (define-key perl-mode-map "\C-c\C-v" 'bioperl-getset)
-	 (define-key perl-mode-map "\C-c\C-b" 'bioperl-method)
-	 (define-key perl-mode-map "\C-c\C-z" 'compile)
-	 (define-key perl-mode-map [menu-bar] (make-sparse-keymap))
-	 (define-key perl-mode-map [menu-bar p]
-	   (cons "BioPerl" (make-sparse-keymap "BioPerl")))
-	 (define-key perl-mode-map [menu-bar p perl-script-start]
-	   '("Insert script template" . perl-script-start))
-	 (define-key perl-mode-map [menu-bar p bioperl-object-start]
-	   '("bioperl object template" . bioperl-object-start))
-	 (define-key perl-mode-map [menu-bar p bioperl-interface-start]
-	   '("bioperl interface template" . bioperl-interface-start))
-
-	 (define-key perl-mode-map [menu-bar p bioperl-getset]
-	   '("bioperl field func" . bioperl-getset))
-	 (define-key perl-mode-map [menu-bar p bioperl-method]
-	   '("bioperl method" . bioperl-method))
-	 ))
-
diff -Naur bioperl-1.0/bioperl.pod bioperl-1.01/bioperl.pod
--- bioperl-1.0/bioperl.pod	Fri Mar 15 18:03:23 2002
+++ bioperl-1.01/bioperl.pod	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 ## Should contain general info about the distribution including
 ## links to many modules.
@@ -15,7 +15,6 @@
 
 Read on...
 
-
 =head1 DESCRIPTION
 
 Bioperl contains a number of Perl objects which are useful in biology.
@@ -116,7 +115,7 @@
 I<examples/clustalw.pl> - a demonstration of the various uses of
 Alignment::Clustalw. See L<Bio::Tools::Run::Alignment::Clustalw> for more
 
-I<examples/getGenbank.pl> - retrieving Genbank entries over the Web using
+I<examples/getGenBank.pl> - retrieving Genbank entries over the Web using
 DB::GenBank. See L<Bio::DB::GenBank> for more information
 
 I<examples/gsequence> - create a Protein Sequence Control Panel GUI with Gtk
@@ -168,6 +167,18 @@
 details of the 3D structure of a protein by parsing a PDB file. See
 L<Bio::Structure::IO> for more information.
 
+I<examples/test-genscan.pl> - script for testing and demonstrating Genscan.pm
+
+I<examples/exceptions/test*pl> - scripts that demonstrate how to throw and
+catch Error.pm objects.
+
+I<examples/root_object/vector/vector.pl> - script to test Bio::Root::Vector.pm
+
+I<examples/root_object/*> - scripts that demonstrate uses of Bio::Root modules.
+
+I<examples/use_registry.pl> - script that shows how to use Bio::DB::Registry,
+part of Bioperl's integration with OBDA, the Open Bio Database Access registry
+scheme. See L<Bio::DB::Registry> for more information.
 
 =head1 Scripts/ Directory
 
@@ -196,6 +207,14 @@
 
 I<scripts/bpindex.pl> - indexes local databases, partners with bpfetch.pl
 
+I<scripts/contributed/revcom_dir.pl> - return reverse complement sequences of
+all sequences in the current directory and save them in the same directory,
+using the same names with extension changed from "seq" to "rev"
+
+I<scripts/contributed/expression_analyis/*> - a set of scripts for analysis
+of expression data : discriminative gene selection, leave-out-one cross
+validation, relevance network of gene expression
+
 I<scripts/das/das_server> - sets up a minimal DAS annotation server, requires
 Apache::DBI and Bio::DB::GFF. See L<Bio::DB::GFF> for details
 
@@ -204,6 +223,9 @@
 
 I<scripts/est_tissue_query.pl> - fetch EST sequences from local files or
 Genbank filtered by tissue using Bio::DB* or Bio::Index*
+
+I<scripts/DB/flanks.pl> - fetch a sequence, find the sequences flanking
+a variant or SNP in the sequence given its position
 
 I<scripts/gb_to_gff.pl> - extracts top-level sequence features from Genbank-
 formatted sequence files using Tools::GFF. See L<Bio::Tools::GFF>
diff -Naur bioperl-1.0/bptutorial.pl bioperl-1.01/bptutorial.pl
--- bioperl-1.0/bptutorial.pl	Sun Mar 17 15:19:22 2002
+++ bioperl-1.01/bptutorial.pl	Sat May  4 16:28:08 2002
@@ -1,4 +1,4 @@
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 =head1 NAME
 
@@ -195,7 +195,7 @@
 the software described in Appendix V.1.
 
 For those who prefer more visual descriptions,
-http://doc.bioperl.org/bioperl-live/ also offers links to three
+http://bioperl.org/Core/Lates/modules.html also offers links to three
 PDF files which contain schematics that describe how many of the bioperl
 objects related to one another.
 
@@ -437,7 +437,7 @@
 necessary that the name of local-blast database directory is known
 to bioperl.  This will typically happen automatically, but in case
 of difficulty, refer to the documentation in
-L<Bio::Tools::Run::StandAloneBlast.pm>)
+L<Bio::Tools::Run::StandAloneBlast>)
 
 =back
 
@@ -2293,8 +2293,8 @@
 currently implementing a CORBA interface for bioperl.  With biocorba,
 objects written within bioperl will be able to communicate with
 objects written in biopython and biojava (see the next subsection).
-For more information, se the biocorba project website at
-http://biocorba.org/.
+For more information, see the biocorba project website at
+http://biocorba.org/.  The Bioperl BioCORBA server and client bindings are available in the bioperl-corba-server and bioperl-corba-client bioperl CVS repositories respecitively. (see http://cvs.bioperl.org for more information). 
 
 =head2 IV.2 Biopython and biojava
 
@@ -2458,7 +2458,7 @@
 # PURPOSE  : Demonstrate various uses of the bioperl package
 # AUTHOR   : Peter Schattner schattner@alum.mit.edu
 # CREATED  : Dec 15 2000
-# REVISION : $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# REVISION : $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 use strict;
 use Bio::SimpleAlign;
diff -Naur bioperl-1.0/examples/biblio.pl bioperl-1.01/examples/biblio.pl
--- bioperl-1.0/examples/biblio.pl	Thu Mar  7 12:53:47 2002
+++ bioperl-1.01/examples/biblio.pl	Fri Apr 12 00:10:20 2002
@@ -16,7 +16,7 @@
 #   senger@ebi.ac.uk
 #   February 2002
 #
-#   $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+#   $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 #-----------------------------------------------------------------------------
 
 use strict;
@@ -162,6 +162,14 @@
       ./biblio.pl -f a_file.xml -Oo   ... to Perl objects
       ./biblio.pl -f a_file.xml -Or   ... as a raw hash
 
+Environment variables:
+   HTTPPROXY = <HTTP proxy server>
+      Use this if you use this script on a machine which
+      needs to access remote HTTP targets via a proxy server.
+      For example:
+         export HTTPPROXY=http://128.243.220.41:3128
+         ./biblio.pl -c
+
 END_OF_USAGE
 }
 
@@ -220,10 +228,14 @@
 #      -namespace => '...' (not set-able here, a default value will be used)
 #      -soap               (not set-able here)
 #
+#      Additionally, it uses env. variable HTTPPROXY to create parameter
+#      '-httpproxy'.
+#
 my @location   = ('-location', $opt_l) if defined $opt_l;
 my @collection = ('-collection_id', $opt_i) if defined $opt_i;
 my @destroy    = ('-destroy_on_exit', 0) if $opt_k or $opt_p or $opt_i;
-my $biblio = new Bio::Biblio (@location, @collection, @destroy);
+my @httpproxy  = ('-httpproxy', $ENV{'HTTPPROXY'}) if defined $ENV{'HTTPPROXY'};
+my $biblio = new Bio::Biblio (@location, @collection, @destroy, @httpproxy);
 
 die "Stopped. No success in accessing the bibliographic repository.\n" unless $biblio;
 
diff -Naur bioperl-1.0/examples/use_registry.pl bioperl-1.01/examples/use_registry.pl
--- bioperl-1.0/examples/use_registry.pl	Sun Mar 17 18:10:01 2002
+++ bioperl-1.01/examples/use_registry.pl	Wed Dec 31 19:00:00 1969
@@ -1,14 +0,0 @@
-#!/usr/bin/perl -w
-use strict;
-
-use Bio::DB::Registry;
-use Bio::SeqIO;
-use strict;
-
-my $registry = new Bio::DB::Registry();
-
-print "services are ", join(',', $registry->services), "\n";
-my $db = $registry->get_database("embl");
-my $seq = $db->get_Seq_by_id("J02231");
-my $out = new Bio::SeqIO;
-$out->write_seq($seq);
diff -Naur bioperl-1.0/scripts/render_sequence.pl bioperl-1.01/scripts/render_sequence.pl
--- bioperl-1.0/scripts/render_sequence.pl	Sat Mar 16 20:33:44 2002
+++ bioperl-1.01/scripts/render_sequence.pl	Sat Mar 23 13:09:04 2002
@@ -41,6 +41,7 @@
 			    -keep =>1)
   : Bio::DB::BioFetch->new(-db=>$db);
 
+warn "fetching...\n";
 my $seq = $bf->get_Seq_by_id($accession);
 
 my @features = $seq->all_SeqFeatures;
diff -Naur bioperl-1.0/t/BioDBGFF.t bioperl-1.01/t/BioDBGFF.t
--- bioperl-1.0/t/BioDBGFF.t	Fri Mar  8 09:45:41 2002
+++ bioperl-1.01/t/BioDBGFF.t	Sat Mar 23 14:02:51 2002
@@ -7,7 +7,7 @@
 use strict;
 use ExtUtils::MakeMaker;
 use Bio::Root::IO;
-use constant TEST_COUNT => 116;
+use constant TEST_COUNT => 115;
 use constant FASTA_FILES => Bio::Root::IO->catfile('t','data','dbfa');
 use constant GFF_FILE    => Bio::Root::IO->catfile('t','data',
 						   'biodbgff','test.gff');
@@ -24,32 +24,27 @@
     plan test => TEST_COUNT;
 }
 
-
 sub bail ($;$);
 sub user_prompt ($;$);
 sub fail ($);
 use lib './blib/lib';
 use Bio::DB::GFF;
 
-my %EXCLUDE_DRIVERS    = ('ExampleP' =>1, 'Multiplex'=>1, 'Proxy'=>1);
-my @PREFERRED_DRIVERS  = qw(mysql Pg Oracle Sybase mSQL Solid Informix Illustra CSV);
-my $idx = 1;
-my %PREFERRED_DRIVERS  = map {$_=>$idx++} @PREFERRED_DRIVERS;
-
-my $adaptor = shift || 'dbi::mysqlopt';
+my $adaptor = -e 't/do_biodbgff.tests' ? 'dbi::mysqlopt' : 'memory';
 my @args;
 
-if( ! -e 't/do_biodbgff.tests' ) {
-  bail(TEST_COUNT,'Skipped by user');
-}
-
 if ($adaptor =~ /^dbi/) {
-  eval { require DBI } or bail(TEST_COUNT,'DBI driver is missing');
-  my $cfg = ChooseDrivers() or bail(TEST_COUNT,'Skipped by user');
-  QueryDb($cfg,{'prompt'=>1,'verbose'=>1});
+
+  open T,"t/do_biodbgff.tests" or bail(TEST_COUNT,"Couldn't read configuration");
+  my $cfg = {};
+  while (<T>) {
+    chomp;
+    my ($key,$value) = split "\t";
+    $cfg->{$key}     = $value;
+  }
   @args = ( '-adaptor'  => $adaptor,
-	     '-dsn'     => $cfg->{test_dsn},
-	     );
+	    '-dsn'     => $cfg->{test_dsn},
+	  );
   push @args,('-user' => $cfg->{test_user}) if $cfg->{test_user};
   push @args,('-pass' => $cfg->{test_pass}) if $cfg->{test_pass};
 } else {
@@ -296,12 +291,17 @@
 # testing feature id and group_id
 my $tf = $overlap[0];
 ok(defined $tf->id);
-ok(defined $tf->group_id);
 my $t1 = $db->fetch_feature_by_id($tf->id);
 ok($t1->id,$tf->id);
-my $t2 = $db->fetch_feature_by_gid($tf->group_id);
-ok($t2->group_id,$tf->group_id);
-ok($t2->group_id,$t1->group_id);
+
+if (defined $tf->group_id) {
+  my $t2 = $db->fetch_feature_by_gid($tf->group_id);
+  ok($t2->group_id,$tf->group_id);
+  ok($t2->group_id,$t1->group_id);
+} else {
+  skip("fetch_feature_by_gid() not implemented by this adaptor",1);
+  skip("fetch_feature_by_gid() not implemented by this adaptor",1);
+}
 
 $segment1 = $db->segment('-class' => 'Transcript',
 			 '-name'  => 'trans-4',
@@ -363,110 +363,6 @@
 
 END {
   unlink FASTA_FILES."/directory.index";
-}
-
-############################################################################
-#
-#   Name:    ChooseDrivers
-#
-#   Purpose: Choose drivers for test suite
-#
-#   Inputs:  none
-#
-#   Returns: configuration hash
-#
-############################################################################
-sub ChooseDrivers {
-  my $cfg = shift || {};
-  my @drivers = grep {!$EXCLUDE_DRIVERS{$_}} DBI->available_drivers;
-  my @preferred_drivers = sort {($PREFERRED_DRIVERS{$a}||99) <=> ($PREFERRED_DRIVERS{$b}||99)} @drivers;
-  print STDERR <<END;
-
-*** Bio::DB::GFF TEST SETUP ***
-    Bio::DB::GFF requires a running database server (preferably MySQL).
-    To run this test suite you must provide the name and host of a test database
-    for which you have insert privileges.
-END
-;
-  my $proceed = user_prompt("Do you want to run the tests? y/n",'n');
-  return unless $proceed =~/^[yY]/;
-  my $choice = user_prompt("Which database driver do you wish to use (@preferred_drivers)",$preferred_drivers[0]);
-  $cfg->{dbd_driver} = $choice;
-  $cfg;
-}
-
-############################################################################
-#
-#   Name:    QueryDb
-#
-#   Purpose: Query settings for running the test suite
-#
-#   Inputs:  $cfg - Config hash ref
-#
-#   Returns: Nothing; creates
-#            $cfg->{$driver}->{test_(db|host|dsn|user|pass)}
-#
-############################################################################
-
-sub QueryDb {
-  my $cfg     = shift;
-  my $options = shift || {};
-  my $db     = $cfg->{'description'} || $cfg->{'dbd_driver'};
-  my $driver = $cfg->{'dbd_driver'};
-
-  my $d = lc $driver;
-  my $prompt = $options->{'prompt'};
-
-  my $test_db =  exists($options->{"$d-test-db"}) ?
-    $options->{"$d-test-db"} : ($cfg->{'test_db'} || 'test');
-  $test_db = user_prompt
-    ("Which database should I use for testing the $db drivers?",
-     $test_db) if $prompt;
-
-  my $test_host = exists($options->{"$d-test-host"}) ?
-    $options->{"$d-test-host"} : ($cfg->{'test_host'} || 'localhost');
-  $test_host = user_prompt
-    ("On which host is database $test_db running (hostname, ip address or host:port)", $test_host) if $prompt;
-
-  my($test_user, $test_pass);
-
-  $test_user = exists($options->{"$d-test-user"}) ?
-    $options->{"$d-test-user"} : ($cfg->{'test_user'} || "undef");
-  $test_user = user_prompt
-    ("User name for connecting to database $test_db?", $test_user)
-      if $prompt;
-  $test_user = undef if $test_user eq 'undef';
-
-  $test_pass = exists($options->{"$d-test-pass"}) ?
-    $options->{"$d-test-pass"} : ($cfg->{'test_pass'} || "undef");
-  $test_pass = user_prompt
-    ("Password for connecting to database $test_db?", $test_pass)
-      if $prompt;
-  $test_pass = undef if $test_pass eq 'undef';
-
-  $cfg->{'test_db'}   = $test_db;
-  $cfg->{'test_host'} = $test_host;
-  $cfg->{'test_user'} = $test_user;
-  $cfg->{'test_pass'} = $test_pass;
-  if ($test_host eq 'undef'  ||  $test_host eq 'localhost') {
-    $test_host = '';
-  }
-  my $test_dsn = "DBI:$driver:database=$test_db";
-  $cfg->{test_dsn} = $test_dsn;
-  if ($test_host) {
-    $cfg->{'test_dsn'} .= ";host=$test_host";
-  }
-
-
-  if ($options->{'verbose'}) {
-    local $^W=0;  # some uninitialized variable warning coming through
-    print("Driver $driver is using the following settings for tests:\n",
-	  "    Database $test_db\n",
-	  "    Host     $test_host\n",
-	  "    DSN      $test_dsn\n",
-	  "    User     $test_user\n",
-	  "    Password $test_pass\n");
-  }
 }
 
 sub bail ($;$) {
diff -Naur bioperl-1.0/t/DNAMutation.t bioperl-1.01/t/DNAMutation.t
--- bioperl-1.0/t/DNAMutation.t	Sun Apr  1 13:54:59 2001
+++ bioperl-1.01/t/DNAMutation.t	Wed Mar 20 08:08:24 2002
@@ -1,6 +1,6 @@
 # -*-Perl-*-
 ## Bioperl Test Harness Script for Modules
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 # Before `make install' is performed this script should be runnable with
 # `make test'. After `make install' it should work as `perl test.t'
@@ -16,7 +16,7 @@
     }
     use Test;
 
-    plan tests => 28 }
+    plan tests => 36 }
 
 use Bio::Variation::DNAMutation;
 use Bio::Variation::Allele;
@@ -123,3 +123,24 @@
 $obj->add_Allele($a2);
 
 ok scalar ($obj->each_Allele), 2;
+
+
+$obj = Bio::Variation::DNAMutation->new
+    ('-start'         => 23,
+     '-end'           => 24,
+     '-length'        => 2,
+     '-upStreamSeq'   => 'gt',
+     '-dnStreamSeq'   => 'at',
+     '-proof'         => 'experimental',
+     '-isMutation'    => 1,
+     '-mut_number'    => 2
+     );
+
+ok $obj->start(), 23;
+ok $obj->end(), 24;
+ok $obj->length(), 2;
+ok $obj->upStreamSeq(), 'gt';
+ok $obj->dnStreamSeq(), 'at';
+ok $obj->proof(), 'experimental';
+ok $obj->mut_number(), 2;
+ok $obj->isMutation;
diff -Naur bioperl-1.0/t/SearchIO.t bioperl-1.01/t/SearchIO.t
--- bioperl-1.0/t/SearchIO.t	Thu Mar 14 17:48:51 2002
+++ bioperl-1.01/t/SearchIO.t	Sat May  4 16:28:26 2002
@@ -1,6 +1,6 @@
 # -*-Perl-*-
 ## Bioperl Test Harness Script for Modules
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 # Before `make install' is performed this script should be runnable with
 # `make test'. After `make install' it should work as `perl test.t'
@@ -20,7 +20,7 @@
 	use lib 't';
     }
     use vars qw($NTESTS);
-    $NTESTS = 390;
+    $NTESTS = 539;
     $LASTXMLTEST = 49;
     $error = 0;
 
@@ -546,6 +546,224 @@
     last if( $count++ > @valid );
 } 
 
+#WU-BlastX test
+
+$searchio = new Bio::SearchIO('-format' => 'blast',
+			      '-file'   => Bio::Root::IO->catfile('t','data','dnaEbsub_ecoli.wublastx'));
+
+$result = $searchio->next_result;
+ok($result->database_name, 'ecoli.aa');
+ok($result->database_letters, 1358990);
+ok($result->database_entries, 4289);
+ok($result->algorithm, 'BLASTX');
+ok($result->algorithm_version, '2.0MP-WashU');
+ok($result->query_name, 'gi|142864|gb|M10040.1|BACDNAE B.subtilis dnaE gene encoding DNA primase, complete cds');
+ok($result->query_length, 2001);
+ok($result->get_parameter('matrix'), 'blosum62');
+
+ok($result->get_statistic('lambda'), 0.318);
+ok($result->get_statistic('kappa'), 0.135);
+ok($result->get_statistic('entropy'),0.401 );
+
+ok($result->get_statistic('dbentries'), 4289);
+
+@valid = ( [ 'gi|1789447|gb|AAC76102.1|', 581, 'AAC76102.1', '1.1e-74', 671]);
+$count = 0;
+
+while( my $hit = $result->next_hit ) {
+    my $d = shift @valid;
+    ok($hit->name, shift @$d);
+    ok($hit->length, shift @$d);
+    ok($hit->accession, shift @$d);
+    ok($hit->significance, shift @$d );
+    ok($hit->raw_score, shift @$d );
+
+    if( $count == 0 ) {
+	while( my $hsp = $hit->next_hsp ) {
+	    ok($hsp->query->start, 21);
+	    ok($hsp->query->end, 1265);
+	    ok($hsp->query->strand, 1);
+	    ok($hsp->hit->start, 1);
+	    ok($hsp->hit->end, 413);
+	    ok($hsp->hit->strand, 0);
+	    ok($hsp->length('hsp'), 421);	    
+	    ok($hsp->evalue == '1.1e-74');
+	    ok($hsp->pvalue == '1.1e-74');
+	    ok($hsp->score,671);
+	    ok($hsp->bits,265.8);
+	    ok(sprintf("%.2f",$hsp->percent_identity), 35.87);
+	    ok(sprintf("%.4f",$hsp->frac_identical('query')), 0.1213);	    
+	    ok(sprintf("%.4f",$hsp->frac_identical('hit')), 0.3656);
+	    ok(sprintf("%.4f",$hsp->frac_conserved('hsp')), 0.5297);
+	    ok($hsp->query->frame(), 2);
+	    ok($hsp->hit->frame(), 0);
+	    ok($hsp->gaps('query'), 6);
+	    ok($hsp->gaps('hit'), 8);
+	    ok($hsp->gaps, 14);	    
+	    ok($hsp->query_string, 'MGNRIPDEIVDQVQKSADIVEVIGDYVQLKKQGRNYFGLCPFHGESTPSFSVSPDKQIFHCFGCGAGGNVFSFLRQMEGYSFAESVSHLADKYQIDFPDDITVHSGARP---ESSGEQKMAEAHELLKKFYHHLLINTKEGQEALDYLLSRGFTKELINEFQIGYALDSWDFITKFLVKRGFSEAQMEKAGLLIRREDGSGYFDRFRNRVMFPIHDHHGAVVAFSGRALGSQQPKYMNSPETPLFHKSKLLYNFYKARLHIRKQERAVLFEGFADVYTAVSSDVKESIATMGTSLTDDHVKILRRNVEEIILCYDSDKAGYEATLKASELL---QKKGCKVRVAMIPDGLDPDDYIKKFGGEKFKNDIIDASVTVMAFKMQYFRKGKNLSDEGDRLAYIKDVLKEISTLSGSLEQEVYVKQ');
+	    ok($hsp->hit_string, 'MAGRIPRVFINDLLARTDIVDLIDARVKLKKQGKNFHACCPFHNEKTPSFTVNGEKQFYHCFGCGAHGNAIDFLMNYDKLEFVETVEELAAMHNLEVPFE----AGSGPSQIERHQRQTLYQLMDGLNTFYQQSL-QQPVATSARQYLEKRGLSHEVIARFAIGFAPPGWDNVLKRFGGNPENRQSLIDAGMLVTNDQGRSY-DRFRERVMFPIRDKRGRVIGFGGRVLGNDTPKYLNSPETDIFHKGRQLYGLYEAQQDNAEPNRLLVVEGYMDVVALAQYGINYAVASLGTSTTADHIQLLFRATNNVICCYDGDRAGRDAAWRALETALPYMTDGRQLRFMFLPDGEDPDTLVRKEGKEAFEARM-EQAMPLSAFLFNSLMPQVDLSTPDGRARLSTLALPLISQVPGETLR-IYLRQ');
+	    ok($hsp->homology_string, 'M  RIP   ++ +    DIV++I   V+LKKQG+N+   CPFH E TPSF+V+ +KQ +HCFGCGA GN   FL   +   F E+V  LA  + ++ P +    +G+ P   E    Q + +  + L  FY   L        A  YL  RG + E+I  F IG+A   WD + K       +   +  AG+L+  + G  Y DRFR RVMFPI D  G V+ F GR LG+  PKY+NSPET +FHK + LY  Y+A+    +  R ++ EG+ DV       +  ++A++GTS T DH+++L R    +I CYD D+AG +A  +A E        G ++R   +PDG DPD  ++K G E F+  + + ++ + AF         +LS    R       L  IS + G   + +Y++Q');
+	}
+    }
+    last if( $count++ > @valid );
+} 
+
+#WU-TBlastN test
+
+$searchio = new Bio::SearchIO('-format' => 'blast',
+			      '-file'   => Bio::Root::IO->catfile('t','data','dnaEbsub_ecoli.wutblastn'));
+
+$result = $searchio->next_result;
+ok($result->database_name, 'ecoli.nt');
+ok($result->database_letters, 4662239);
+ok($result->database_entries, 400);
+ok($result->algorithm, 'TBLASTN');
+ok($result->algorithm_version, '2.0MP-WashU');
+ok($result->query_name, 'gi|142865|gb|AAA22406.1| DNA primase');
+ok($result->query_length, 603);
+ok($result->get_parameter('matrix'), 'blosum62');
+
+ok($result->get_statistic('lambda'), '0.320');
+ok($result->get_statistic('kappa'), 0.136);
+ok($result->get_statistic('entropy'),0.387 );
+
+ok($result->get_statistic('dbentries'), 400);
+
+@valid = ( [ 'gi|1789441|gb|AE000388.1|AE000388', 10334, 'AE000388', '1.4e-73', 671]);
+$count = 0;
+
+while( my $hit = $result->next_hit ) {
+    my $d = shift @valid;
+    ok($hit->name, shift @$d);
+    ok($hit->length, shift @$d);
+    ok($hit->accession, shift @$d);
+    ok($hit->significance, shift @$d );
+    ok($hit->raw_score, shift @$d );
+
+    if( $count == 0 ) {
+	while( my $hsp = $hit->next_hsp ) {
+	    ok($hsp->query->start, 1);
+	    ok($hsp->query->end, 415);
+	    ok($hsp->query->strand, 0);
+	    ok($hsp->hit->start, 4778);
+	    ok($hsp->hit->end, 6016);
+	    ok($hsp->hit->strand, 1);
+	    ok($hsp->length('hsp'), 421);	    
+	    ok($hsp->evalue == '1.4e-73');
+	    ok($hsp->pvalue == '1.4e-73');
+	    ok($hsp->score,671);
+	    ok($hsp->bits,265.8);
+	    ok(sprintf("%.2f",$hsp->percent_identity), 35.87);
+	    ok(sprintf("%.4f",$hsp->frac_identical('hit')), 0.1219);	    
+	    ok(sprintf("%.4f",$hsp->frac_identical('query')), 0.3639);
+	    ok(sprintf("%.4f",$hsp->frac_conserved('hsp')), 0.5297);
+	    ok($hsp->query->frame(), 0);
+	    ok($hsp->hit->frame(), 1);
+	    ok($hsp->gaps('query'), 6);
+	    ok($hsp->gaps('hit'), 8);
+	    ok($hsp->gaps, 14);	    
+ok($hsp->query_string, 'MGNRIPDEIVDQVQKSADIVEVIGDYVQLKKQGRNYFGLCPFHGESTPSFSVSPDKQIFHCFGCGAGGNVFSFLRQMEGYSFAESVSHLADKYQIDFPDDITVHSGARP---ESSGEQKMAEAHELLKKFYHHLLINTKEGQEALDYLLSRGFTKELINEFQIGYALDSWDFITKFLVKRGFSEAQMEKAGLLIRREDGSGYFDRFRNRVMFPIHDHHGAVVAFSGRALGSQQPKYMNSPETPLFHKSKLLYNFYKARLHIRKQERAVLFEGFADVYTAVSSDVKESIATMGTSLTDDHVKILRRNVEEIILCYDSDKAGYEATLKASELL---QKKGCKVRVAMIPDGLDPDDYIKKFGGEKFKNDIIDASVTVMAFKMQYFRKGKNLSDEGDRLAYIKDVLKEISTLSGSLEQEVYVKQ');
+	    ok($hsp->hit_string, 'MAGRIPRVFINDLLARTDIVDLIDARVKLKKQGKNFHACCPFHNEKTPSFTVNGEKQFYHCFGCGAHGNAIDFLMNYDKLEFVETVEELAAMHNLEVPFE----AGSGPSQIERHQRQTLYQLMDGLNTFYQQSL-QQPVATSARQYLEKRGLSHEVIARFAIGFAPPGWDNVLKRFGGNPENRQSLIDAGMLVTNDQGRSY-DRFRERVMFPIRDKRGRVIGFGGRVLGNDTPKYLNSPETDIFHKGRQLYGLYEAQQDNAEPNRLLVVEGYMDVVALAQYGINYAVASLGTSTTADHIQLLFRATNNVICCYDGDRAGRDAAWRALETALPYMTDGRQLRFMFLPDGEDPDTLVRKEGKEAFEARM-EQAMPLSAFLFNSLMPQVDLSTPDGRARLSTLALPLISQVPGETLR-IYLRQ');
+	    ok($hsp->homology_string, 'M  RIP   ++ +    DIV++I   V+LKKQG+N+   CPFH E TPSF+V+ +KQ +HCFGCGA GN   FL   +   F E+V  LA  + ++ P +    +G+ P   E    Q + +  + L  FY   L        A  YL  RG + E+I  F IG+A   WD + K       +   +  AG+L+  + G  Y DRFR RVMFPI D  G V+ F GR LG+  PKY+NSPET +FHK + LY  Y+A+    +  R ++ EG+ DV       +  ++A++GTS T DH+++L R    +I CYD D+AG +A  +A E        G ++R   +PDG DPD  ++K G E F+  + + ++ + AF         +LS    R       L  IS + G   + +Y++Q');
+	}
+    }
+    last if( $count++ > @valid );
+}
+
+# WU-BLAST TBLASTX
+$searchio = new Bio::SearchIO('-format' => 'blast',
+			      '-file'   => Bio::Root::IO->catfile('t','data','dnaEbsub_ecoli.wutblastx'));
+
+$result = $searchio->next_result;
+ok($result->database_name, 'ecoli.nt');
+ok($result->database_letters, 4662239);
+ok($result->database_entries, 400);
+ok($result->algorithm, 'TBLASTX');
+ok($result->algorithm_version, '2.0MP-WashU');
+ok($result->query_name, 'gi|142864|gb|M10040.1|BACDNAE B.subtilis dnaE gene encoding DNA primase, complete cds');
+ok($result->query_length, 2001);
+ok($result->get_parameter('matrix'), 'blosum62');
+
+ok($result->get_statistic('lambda'), 0.318);
+ok($result->get_statistic('kappa'), 0.135);
+ok($result->get_statistic('entropy'),0.401 );
+ok($result->get_statistic('dbentries'), 400);
+
+@valid = ( [ 'gi|1789441|gb|AE000388.1|AE000388', 10334, 'AE000388', '6.4e-70', 318],
+	   [ 'gi|2367383|gb|AE000509.1|AE000509', 10589, 'AE000509', '0.9992', 59]
+	   );
+$count = 0;
+
+while( my $hit = $result->next_hit ) {
+    my $d = shift @valid;
+    ok($hit->name, shift @$d);
+    ok($hit->length, shift @$d);
+    ok($hit->accession, shift @$d);
+    ok($hit->significance, shift @$d );
+    ok($hit->raw_score, shift @$d );
+
+    if( $count == 0 ) {
+	my $hspcounter = 0;
+	while( my $hsp = $hit->next_hsp ) {
+	    $hspcounter++;
+	    if( $hspcounter == 3 ) {
+		# let's actually look at the 3rd HSP
+		ok($hsp->query->start, 441);
+		ok($hsp->query->end, 617);
+		ok($hsp->query->strand, 1);
+		ok($hsp->hit->start, 5192);
+		ok($hsp->hit->end, 5368);
+		ok($hsp->hit->strand, 1);
+		ok($hsp->length('hsp'), 59);	    
+		ok($hsp->evalue == '6.4e-70');
+		ok($hsp->pvalue == '6.4e-70');
+		ok($hsp->score,85);
+		ok($hsp->bits,41.8);
+		ok(sprintf("%.2f",$hsp->percent_identity), '32.20');
+		ok(sprintf("%.4f",$hsp->frac_identical('hit')), 0.1073);
+		ok(sprintf("%.4f",$hsp->frac_identical('query')), 0.1073);
+		ok(sprintf("%.4f",$hsp->frac_conserved('hsp')), 0.4746);
+		ok($hsp->query->frame(), 2);
+		ok($hsp->hit->frame(), 1);
+		ok($hsp->gaps('query'), 0);
+		ok($hsp->gaps('hit'), 0);
+		ok($hsp->gaps, 0);	    
+		ok($hsp->query_string, 'ALDYLLSRGFTKELINEFQIGYALDSWDFITKFLVKRGFSEAQMEKAGLLIRREDGSGY');
+	    ok($hsp->hit_string, 'ARQYLEKRGLSHEVIARFAIGFAPPGWDNVLKRFGGNPENRQSLIDAGMLVTNDQGRSY');
+	    ok($hsp->homology_string, 'A  YL  RG + E+I  F IG+A   WD + K       +   +  AG+L+  + G  Y');
+	    }
+	} 
+    } elsif( $count == 1 ) {
+	while( my $hsp = $hit->next_hsp ) {
+	    ok($hsp->query->start, 587);
+	    ok($hsp->query->end, 706);
+	    ok($hsp->query->strand, -1);
+	    ok($hsp->hit->start, 4108);
+	    ok($hsp->hit->end, 4227);
+	    ok($hsp->hit->strand, -1);
+	    ok($hsp->length('hsp'), 40);	    
+	    ok($hsp->evalue == '7.1');
+	    ok($hsp->pvalue == '1.00');
+	    ok($hsp->score,59);
+	    ok($hsp->bits,29.9);
+	    ok(sprintf("%.2f",$hsp->percent_identity), '37.50');
+	    ok(sprintf("%.4f",$hsp->frac_identical('hit')), '0.1250');
+	    ok(sprintf("%.4f",$hsp->frac_identical('query')), '0.1250');
+	    ok(sprintf("%.4f",$hsp->frac_conserved('hsp')), '0.4750');
+	    ok($hsp->query->frame(), 2);
+	    ok($hsp->hit->frame(), 2);
+	    ok($hsp->gaps('query'), 0);
+	    ok($hsp->gaps('hit'), 0);
+	    ok($hsp->gaps, 0);
+	    ok($hsp->query_string, 'WLPRALPEKATTAP**SWIGNMTRFLKRSKYPLPSSRLIR');
+	    ok($hsp->hit_string, 'WLSRTTVGSSTVSPRTFWITRMKVKLSSSKVTLPSTKSTR');
+	    ok($hsp->homology_string, 'WL R     +T +P   WI  M   L  SK  LPS++  R');
+	    last;
+	}       
+    }
+    last if( $count++ > @valid );
+}
+
 # TODO: Flesh this test out!
 $searchio = new Bio::SearchIO ('-format' => 'psiblast',
 			       '-file'   => Bio::Root::IO->catfile('t','data','HUMBETGLOA.tblastx'));
@@ -554,6 +772,7 @@
 
 ok($result);
 $hit = $result->next_hit;
+ok($hit->accession, 'AE000208');
 $hsp = $hit->next_hsp;
 ok($hsp->get_aln->isa('Bio::Align::AlignI'));
 my $writer = Bio::SearchIO::Writer::HitTableWriter->new( 
diff -Naur bioperl-1.0/t/SeqFeature.t bioperl-1.01/t/SeqFeature.t
--- bioperl-1.0/t/SeqFeature.t	Mon Oct 22 04:22:58 2001
+++ bioperl-1.01/t/SeqFeature.t	Sat May  4 16:28:26 2002
@@ -2,7 +2,7 @@
 ## Bioperl Test Harness Script for Modules
 ##
 # CVS Version
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 
 # Before `make install' is performed this script should be runnable with
@@ -20,7 +20,7 @@
     }
     use Test;
 
-    plan tests => 37;
+    plan tests => 41;
 }
 
 use Bio::Seq;
@@ -148,7 +148,7 @@
 
 ok defined ( $comp_obj1 = Bio::SeqFeature::Computation->new('-start' => 1,
 							    '-end'   => 10) );
-ok ( $comp_obj1->computation_id(332) );
+ok ( $comp_obj1->computation_id(332),332 );
 ok ( $comp_obj1->add_score_value('P', 33) );
 {
     $comp_obj2 = Bio::SeqFeature::Computation->new('-start' => 2,
@@ -157,6 +157,23 @@
     ok (@sft = $comp_obj1->all_sub_SeqFeature_types() );
     ok ($sft[0], 'exon');
 }
+
+ok defined ( $comp_obj1 = new Bio::SeqFeature::Computation 
+	     (
+	      -start => 10, -end => 100,
+	      -strand => -1, -primary => 'repeat',
+	      -program_name => 'GeneMark',
+	      -program_date => '12-5-2000',
+	      -program_version => 'x.y',
+	      -database_name => 'Arabidopsis',
+	      -database_date => '12-dec-2000',
+	      -computation_id => 2231,
+	      -score    => { no_score => 334 } )
+	     );
+
+ok ( $comp_obj1->computation_id, 2231 );
+ok ( $comp_obj1->add_score_value('P', 33) );
+ok ( ($comp_obj1->each_score_value('no_score'))[0], '334');
 
 # some tests for bug #947
 
diff -Naur bioperl-1.0/t/TCoffee.t bioperl-1.01/t/TCoffee.t
--- bioperl-1.0/t/TCoffee.t	Mon Mar 18 09:50:34 2002
+++ bioperl-1.01/t/TCoffee.t	Fri Mar 22 15:29:36 2002
@@ -1,6 +1,6 @@
 # -*-Perl-*-
 ## Bioperl Test Harness Script for Modules
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 use strict;
 use vars qw($NUMTESTS);
@@ -107,7 +107,7 @@
 $aln = $factory->profile_align($aln1,$seq);
 ok( $aln->no_sequences, 4);
 if( $version <= 1.22 ) {
-    ok( int($aln->overall_percentage_identity), 18);    
+    ok( $aln->overall_percentage_identity > 18);    
     ok( int($aln->average_percentage_identity), 44);
 } else {
     ok( int($aln->overall_percentage_identity), 21);
diff -Naur bioperl-1.0/t/TreeIO.t bioperl-1.01/t/TreeIO.t
--- bioperl-1.0/t/TreeIO.t	Sat Nov 24 16:12:06 2001
+++ bioperl-1.01/t/TreeIO.t	Sat May  4 16:28:28 2002
@@ -1,6 +1,6 @@
 # -*-Perl-*-
 ## Bioperl Test Harness Script for Modules
-## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+## $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 # Before `make install' is performed this script should be runnable with
 # `make test'. After `make install' it should work as `perl test.t'
@@ -18,7 +18,7 @@
     }
 
     use Test;
-    plan tests => 10; 
+    plan tests => 12; 
 
 #    eval { require XML::Parser::PerlSAX; };
 #    if( $@ ) {
@@ -107,10 +107,30 @@
 }
 
 ok($tree->total_branch_length, 7.12148);
-
 $treeio = new Bio::TreeIO(-verbose => $verbose,
 			  -format => 'newick', 
 			  -file   => ">$FILE2");
 $treeio->write_tree($tree);
 undef $treeio;
 ok(-s $FILE2);
+$treeio = new Bio::TreeIO(-verbose => $verbose,
+			  -format  => 'newick',
+			  -file    => Bio::Root::IO->catfile('t','data','hs_fugu.newick'));
+$tree = $treeio->next_tree();
+@nodes = $tree->get_nodes();
+ok(@nodes, 4);
+# no relable order for the bottom nodes because they have no branchlen
+my @vals = qw(SINFRUP0000006110);
+my $saw = 0;
+foreach my $node ( $tree->get_root_node()->each_Descendent() ) {
+	foreach my $v ( @vals ) {
+	   if( $node->id eq $v ){ $saw = 1; last; }
+	}
+	last if $saw;
+}
+ok($saw, 1, "Did not see $vals[0] as expected\n");
+if( $verbose ) {
+    foreach my $node ( @nodes ) {
+	print "\t", $node->id, "\n";
+    }
+}
diff -Naur bioperl-1.0/t/flat.t bioperl-1.01/t/flat.t
--- bioperl-1.0/t/flat.t	Mon Mar 18 11:32:18 2002
+++ bioperl-1.01/t/flat.t	Tue Mar 19 22:10:23 2002
@@ -1,7 +1,7 @@
 # This is -*-Perl-*- code
 ## Bioperl Test Harness Script for Modules
 ##
-# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
+# $Id: bioperl-1.0.patch,v 1.5 2002-05-04 20:38:26 lstein Exp $
 
 # Before `make install' is performed this script should be runnable with
 # `make test'. After `make install' it should work as `perl test.t'
@@ -88,7 +88,7 @@
 
 
 sub maketmpdir {
-    mkdir $tmpdir;
+    mkdir ($tmpdir,0777);
 }
 sub cleanup {    
     eval { 
