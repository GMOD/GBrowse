diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/README bioperl-1.1/scripts/Bio-DB-GFF/README
--- bioperl-1.0.2/scripts/Bio-DB-GFF/README	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/README	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,14 @@
+These are utilities that go with the Bio::DB::GFF module:
+
+load_gff.pl	      Slow but foolproof GFF table to database loader.
+bulk_load_gff.pl      Fast loader, but wipes database clean each time.
+fast_load_gff.pl      EXPERIMENTAL incremental loader that is as fast
+		       as bulk loader, but only works on Unix platforms.
+generate_histogram.pl Generate histogram of sequence features, for use with
+		       generic genome browser.
+process_gadfly.pl     Tweak GadFly GFF files for loading (drosophila).
+process_wormbase.pl   Tweak WormBase GFF files for loading (elegans)
+process_sgd.pl        Turn SGD feature dumps into GFF files for loading (saccharomyces).
+process_ncbi_human.pl Turn NCBI feature dumps into GFF files for loading (human).
+
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/bulk_load_gff.pl bioperl-1.1/scripts/Bio-DB-GFF/bulk_load_gff.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/bulk_load_gff.pl	Wed Jan 30 11:02:51 2002
+++ bioperl-1.1/scripts/Bio-DB-GFF/bulk_load_gff.pl	Fri Sep 27 11:59:49 2002
@@ -104,7 +104,7 @@
 my $tmpdir = $ENV{TMPDIR} || $ENV{TMP} || '/usr/tmp';
 my @files = (FDATA,FTYPE,FGROUP,FDNA,FATTRIBUTE,FATTRIBUTE_TO_FEATURE);
 foreach (@files) {
-  $FH{$_} = IO::File->new("$tmpdir/$_",">") or die $_,": $!";
+  $FH{$_} = IO::File->new("$tmpdir/$_.$$",">") or die $_,": $!";
   $FH{$_}->autoflush;
 }
 
@@ -183,13 +183,13 @@
 foreach (@files) {
   my $command =<<END;
 ${\MYSQL} $AUTH
--e "lock tables $_ write; delete from $_; load data infile '$tmpdir/$_' replace into table $_; unlock tables"
+-e "lock tables $_ write; delete from $_; load data infile '$tmpdir/$_.$$' replace into table $_; unlock tables"
 $DSN
 END
 ;
   $command =~ s/\n/ /g;
   $success &&= system($command) == 0;
-  unlink "$tmpdir/$_";
+  unlink "$tmpdir/$_.$$";
 }
 warn "done...\n";
 
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/fast_load_gff.pl bioperl-1.1/scripts/Bio-DB-GFF/fast_load_gff.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/fast_load_gff.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/fast_load_gff.pl	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,298 @@
+#!/usr/bin/perl
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+
+use strict;
+use lib './blib/lib';
+use DBI;
+use IO::File;
+use Getopt::Long;
+use Bio::DB::GFF::Util::Binning 'bin';
+use Bio::DB::GFF::Adaptor::dbi::mysqlopt;
+
+use constant MYSQL => 'mysql';
+
+use constant FDATA      => 'fdata';
+use constant FTYPE      => 'ftype';
+use constant FGROUP     => 'fgroup';
+use constant FDNA       => 'fdna';
+use constant FATTRIBUTE => 'fattribute';
+use constant FATTRIBUTE_TO_FEATURE => 'fattribute_to_feature';
+
+my $DO_FAST = eval "use POSIX 'WNOHANG'; 1;";
+
+package Bio::DB::GFF::Adaptor::faux;
+
+use Bio::DB::GFF::Adaptor::dbi::mysqlopt;
+use vars '@ISA';
+@ISA = 'Bio::DB::GFF::Adaptor::dbi::mysqlopt';
+
+sub insert_sequence {
+  my $self = shift;
+  my ($id,$offset,$seq) = @_;
+  print join "\t",$id,$offset,$seq,"\n";
+}
+
+package main;
+
+my ($DSN,$CREATE,$USER,$PASSWORD,$FASTA,$FAILED,$LOCAL,%PID);
+
+if ($DO_FAST) {
+  $SIG{CHLD} = sub {
+    while ((my $child = waitpid(-1,&WNOHANG)) > 0) {
+      delete $PID{$child} or next;
+      $FAILED++ if $? != 0;
+    }
+  }
+};
+
+$SIG{INT} = $SIG{TERM} = sub {cleanup(); exit -1};
+
+GetOptions ('database:s'    => \$DSN,
+	    'create'        => \$CREATE,
+	    'user:s'        => \$USER,
+            'local'         => \$LOCAL,
+	    'password:s'    => \$PASSWORD,
+	    'fasta:s'       => \$FASTA,
+	   ) or die <<USAGE;
+Usage: $0 [options] <gff file 1> <gff file 2> ...
+Fast load a Bio::DB::GFF database from GFF files.
+
+ Options:
+   --database <dsn>      Mysql database name
+   --create              Reinitialize/create data tables (will drop existing data)
+   --local               Try to load a remote database using local data
+   --user                Username to log in as
+   --fasta               File or directory containing fasta files to load
+   --password            Password to use for authentication
+
+Options can be abbreviated.  For example, you can use -d for
+--database.
+
+NOTE: If no arguments are provided, then the input is taken from
+standard input. Compressed files (.gz, .Z, .bz2) are automatically
+uncompressed.  Fasta files must end in .fa optionally followed by a
+compression suffix in order to be recognized.
+
+The nature of the bulk load requires that the database be on the local
+machine and that the indicated user have the "file" privilege to load
+the tables and have enough room in /usr/tmp (or whatever is specified
+by the \$TMPDIR environment variable), to hold the tables transiently.
+
+The --remote option *may* allow you to load remote databases, for
+example:
+
+   fast_load_gff.pl -local -d 'test;host=brie3.cshl.org' test_data.gff
+
+However, for this to work, MySQL must have been compiled with the
+--enable-local-file option, thereby allowing the "load data local
+infile" syntax to work.
+
+The adaptor used is dbi::mysqlopt.  There is currently no way to
+change this.  Note that this script uses very Unix-specific features,
+such as mknode.
+
+USAGE
+;
+
+$DSN ||= 'test';
+
+my (@auth,$AUTH);
+if (defined $USER) {
+  push @auth,(-user=>$USER);
+  $AUTH .= " -u$USER";
+}
+if (defined $PASSWORD) {
+  push @auth,(-pass=>$PASSWORD);
+  $AUTH .= " -p$PASSWORD";
+}
+
+my $db = Bio::DB::GFF->new(-adaptor=>'faux',-dsn => $DSN,@auth)
+  or die "Can't open database: ",Bio::DB::GFF->error,"\n";
+
+$db->initialize(1) if $CREATE;
+
+foreach (@ARGV) {
+  $_ = "gunzip -c $_ |" if /\.gz$/;
+  $_ = "uncompress -c $_ |" if /\.Z$/;
+  $_ = "bunzip2 -c $_ |" if /\.bz2$/;
+}
+
+# initialize state variables
+my $FID     = 1;
+my $GID     = 1;
+my $FTYPEID = 1;
+my $ATTRIBUTEID = 1;
+my %GROUPID     = ();
+my %FTYPEID     = ();
+my %ATTRIBUTEID = ();
+my %DONE        = ();
+my $FEATURES    = 0;
+
+load_tables($db->dbh) unless $CREATE;
+
+# open up pipes to the database
+my (%FH,%COMMAND);
+my $MYSQL = MYSQL;
+my $tmpdir = $ENV{TMPDIR} || $ENV{TMP} || '/usr/tmp';
+my @files = (FDATA,FTYPE,FGROUP,FDNA,FATTRIBUTE,FATTRIBUTE_TO_FEATURE);
+foreach (@files) {
+  my $file = "$tmpdir/$_.$$";
+  print STDERR "creating load file $file...";
+  $DO_FAST &&= (system("mkfifo $file") == 0);  # for system(), 0 = success
+  print STDERR "ok\n";
+  my $delete = $CREATE ? "delete from $_" : '';
+  my $local  = $LOCAL ? 'local' : '';
+  my $command =<<END;
+$MYSQL $AUTH
+-e "lock tables $_ write; $delete; load data $local infile '$file' replace into table $_; unlock tables"
+$DSN
+END
+;
+  $command =~ s/\n/ /g;
+  $COMMAND{$_} = $command;
+
+  if ($DO_FAST) {
+    if (my $pid = fork) {
+      $PID{$pid} = $_;
+      print STDERR "pausing for 0.5 sec..." if $DO_FAST;
+      select(undef,undef,undef,0.50); # work around a race condition
+      print STDERR "ok\n";
+    } else {  # THIS IS IN CHILD PROCESS
+      die "Couldn't fork: $!" unless defined $pid;
+      exec $command || die "Couldn't exec: $!";
+      exit 0;
+    }
+  }
+  print STDERR "opening load file for writing...";
+  $FH{$_} = IO::File->new($file,'>') or die $_,": $!";
+  print STDERR "ok\n";
+  $FH{$_}->autoflush;
+}
+
+print STDERR "Fast loading enabled\n" if $DO_FAST;
+
+my $count;
+while (<>) {
+  chomp;
+  next if /^\#/;
+  my ($ref,$source,$method,$start,$stop,$score,$strand,$phase,$group) = split "\t";
+  $FEATURES++;
+
+  $source = '\N' unless defined $source;
+  $score  = '\N' if $score  eq '.';
+  $strand = '\N' if $strand eq '.';
+  $phase  = '\N' if $phase  eq '.';
+
+  # handle group parsing
+  $group =~ s/\\;/$;/g;  # protect embedded semicolons in the group
+  $group =~ s/( \"[^\"]*);([^\"]*\")/$1$;$2/g;
+  my @groups = split(/\s*;\s*/,$group);
+  foreach (@groups) { s/$;/;/g }
+
+  my ($group_class,$group_name,$target_start,$target_stop,$attributes) = Bio::DB::GFF->_split_group(@groups);
+  $group_class  ||= '\N';
+  $group_name   ||= '\N';
+  $target_start ||= '\N';
+  $target_stop  ||= '\N';
+  $method       ||= '\N';
+  $source       ||= '\N';
+
+  my $fid     = $FID++;
+  my $gid     = $GROUPID{$group_class,$group_name} ||= $GID++;
+  my $ftypeid = $FTYPEID{$source,$method}          ||= $FTYPEID++;
+
+  my $bin = bin($start,$stop,$db->min_bin);
+  $FH{ FDATA()  }->print(    join("\t",$fid,$ref,$start,$stop,$bin,$ftypeid,$score,$strand,$phase,$gid,$target_start,$target_stop),"\n"   );
+  $FH{ FGROUP() }->print(    join("\t",$gid,$group_class,$group_name),"\n"              ) unless $DONE{"fgroup$;$gid"}++;
+  $FH{ FTYPE()  }->print(    join("\t",$ftypeid,$method,$source),"\n"                   ) unless $DONE{"ftype$;$ftypeid"}++;
+
+  foreach (@$attributes) {
+    my ($key,$value) = @$_;
+    my $attributeid = $ATTRIBUTEID{$key}   ||= $ATTRIBUTEID++;
+    $FH{ FATTRIBUTE() }->print( join("\t",$attributeid,$key),"\n"                       ) unless $DONE{"fattribute$;$attributeid"}++;
+    $FH{ FATTRIBUTE_TO_FEATURE() }->print( join("\t",$fid,$attributeid,$value),"\n");
+  }
+
+  if ( $FEATURES % 1000 == 0) {
+    print STDERR "$FEATURES features parsed...";
+    print STDERR -t STDOUT && !$ENV{EMACS} ? "\r" : "\n";
+  }
+}
+
+if ($FASTA) {
+  warn "Loading fasta ",(-d $FASTA?"directory":"file"), " $FASTA\n";
+  my $old = select($FH{FDNA()});
+  my $loaded = $db->load_fasta($FASTA);
+  warn "$FASTA: $loaded records loaded\n";
+  select $old;
+}
+
+my $success = 1;
+$_->close foreach values %FH;
+
+if (!$DO_FAST) {
+  warn "Loading feature data.  You may see duplicate key warnings here...\n";
+  $success &&= system($COMMAND{$_}) == 0 foreach @files;
+}
+
+# wait for children
+while (%PID) {
+  sleep;
+}
+$success &&= !$FAILED;
+
+cleanup();
+
+if ($success) {
+  print "SUCCESS: $FEATURES features successfully loaded\n";
+  exit 0;
+} else {
+  print "FAILURE: Please see standard error for details\n";
+  exit -1;
+}
+
+exit 0;
+
+sub cleanup {
+  foreach (@files) {
+    unlink "$tmpdir/$_.$$";
+  }
+}
+
+# load copies of some of the tables into memory
+sub load_tables {
+  my $dbh = shift;
+  print STDERR "loading normalized group, type and attribute information...";
+  $FID         = 1 + get_max_id($dbh,'fdata','fid');
+  $GID         = 1 + get_max_id($dbh,'fgroup','gid');
+  $FTYPEID     = 1 + get_max_id($dbh,'ftype','ftypeid');
+  $ATTRIBUTEID = 1 + get_max_id($dbh,'fattribute','fattribute_id');
+  get_ids($dbh,\%DONE,\%GROUPID,'fgroup','gid','gclass','gname');
+  get_ids($dbh,\%DONE,\%FTYPEID,'ftype','ftypeid','fsource','fmethod');
+  get_ids($dbh,\%DONE,\%ATTRIBUTEID,'fattribute','fattribute_id','fattribute_name');
+  print STDERR "ok\n";
+}
+
+sub get_max_id {
+  my $dbh = shift;
+  my ($table,$id) = @_;
+  my $sql = "select max($id) from $table";
+  my $result = $dbh->selectcol_arrayref($sql) or die $dbh->errstr;
+  $result->[0];
+}
+
+sub get_ids {
+  my $dbh = shift;
+  my ($done,$idhash,$table,$id,@columns) = @_;
+  my $columns = join ',',$id,@columns;
+  my $sql = "select $columns from $table";
+  my $sth = $dbh->prepare($sql) or die $dbh->errstr;
+  $sth->execute or die $dbh->errstr;
+  while (my($id,@cols) = $sth->fetchrow_array) {
+    my $key = join $;,@cols;
+    $idhash->{$key} = $id;
+    $done->{$table,$id}++;
+  }
+}
+
+__END__
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/gadfly_to_gff.pl bioperl-1.1/scripts/Bio-DB-GFF/gadfly_to_gff.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/gadfly_to_gff.pl	Mon Jan 21 08:53:32 2002
+++ bioperl-1.1/scripts/Bio-DB-GFF/gadfly_to_gff.pl	Wed Dec 31 19:00:00 1969
@@ -1,301 +0,0 @@
-#!/usr/bin/perl
-
-=head1 NAME
-
-gadfly_to_gff.pl - Massage Gadfly's GFF format into a form suitable for Bio::DB::GFF
-
-=head2 SYNOPSIS
-
-   perl gadfly_to_gff.pl /path/to/gadfly/release/files > gadfly.gff
-
-=head2 DESCRIPTION
-
-This script massages the Flybase/Gadfly GFF files located at
-ftp://ftp.fruitfly.org/pub/genomic/gadfly/ into the "correct" version
-of the GFF format for use with Bio::DB::GFF.  This lets you view the
-Drosophila annotations with the generic genome browser
-(http://www.gmod.org).
-
-To use this script, get the Gadfly GFF distribution archive which is
-organized by GenBank accession unit (e.g. "RELEASE2GFF.tar.gz").
-Unpacking it will yield a directory named after the release,
-e.g. RELEASE2.
-
-Give that directory as the argument to this script, and capture the
-script's output to a file:
-
-  % gadfly_to_gff.pl ./RELEASE2 > gadfly.gff
-
-The gadfly.gff file can then be loaded into a Bio::DB::GFF database
-using the following command:
-
-  % bulk_load_gff.pl -d <databasename> gadfly.gff
-
-The resulting database will have the following feature types
-(represented as "method:source"):
-
-  Component:arm              A chromosome arm
-  Component:scaffold	     A chromosome scaffold (accession #)
-  Component:gap	             A gap in the assembly
-  clone:clonelocator         A BAC clone
-  gene:gadfly                A gene accession number
-  transcript:gadfly          A transcript accession number
-  translation:gadfly         A translation
-  codon:gadfly               Significance unknown
-  exon:gadfly                An exon
-  symbol:gadfly              A classical gene symbol
-  similarity:blastn          A BLASTN hit
-  similarity:blastx          A BLASTX hit
-  similarity:sim4            EST->genome using SIM4
-  similarity:groupest        EST->genome using GROUPEST
-  similarity:repeatmasker    A repeat
-
-=head2 AUTHOR
-
-Lincoln Stein E<lt>lstein@cshl.orgE<gt>
-
-=cut
-
-
-if ($ARGV[0]=~/^-?-h/i) {
-print <<'USAGE';
-
-This script massages the Flybase/Gadfly GFF files located at
-ftp://ftp.fruitfly.org/pub/genomic/gadfly/ into the "correct" version
-of the GFF format for use with Bio::DB::GFF.  This lets you view the
-Drosophila annotations with the generic genome browser
-(http://www.gmod.org).
-
-To use this script, get the Gadfly GFF distribution archive which is
-organized by GenBank accession unit (e.g. "RELEASE2GFF.tar.gz").
-Unpacking it will yield a directory named after the release,
-e.g. RELEASE2.
-
-Give that directory as the argument to this script, and capture the
-script's output to a file:
-
-  % gadfly_to_gff.pl ./RELEASE2 > gadfly.gff
-
-The gadfly.gff file can then be loaded into a Bio::DB::GFF database
-using the following command:
-
-  % bulk_load_gff.pl -d <databasename> gadfly.gff
-
-The resulting database will have the following feature types
-(represented as "method:source"):
-
-  Component:arm              A chromosome arm
-  Component:scaffold	     A chromosome scaffold (accession #)
-  Component:gap	             A gap in the assembly
-  clone:clonelocator         A BAC clone
-  gene:gadfly                A gene accession number
-  transcript:gadfly          A transcript accession number
-  translation:gadfly         A translation
-  codon:gadfly               Significance unknown
-  exon:gadfly                An exon
-  symbol:gadfly              A classical gene symbol
-  similarity:blastn          A BLASTN hit
-  similarity:blastx          A BLASTX hit
-  similarity:sim4            EST->genome using SIM4
-  similarity:groupest        EST->genome using GROUPEST
-  similarity:repeatmasker    A repeat
-
-Author: Lincoln Stein <lstein\@cshl.org>
-
-USAGE
-;
-}
-
-use strict;
-my $dir = shift || './RELEASE2/gff';
-my $map = read_map($dir) || die;
-for my $scaffold (sort {
-                       $map->{$a}[0] cmp $map->{$b}[0]
-			 ||
-		       $map->{$a}[1] <=> $map->{$b}[1]
-		     } keys %$map) {
-  convert_scaffold($dir,$scaffold,$map->{$scaffold});
-}
-
-
-sub read_map {
-  my $dir = shift;
-  my ($segments) = <$dir/SEGMENTS*.gff>;
-  my %arms;
-  $segments or die "Can't find SEGMENTS file";
-  open (F,$segments) or die "Can't open $segments: $!";
-  my %position;
-  while (<F>) {
-    chomp;
-    my ($ref,$source,$method,$start,$stop,undef,$strand,undef,$group) = split "\t";
-    $group =~ /name=(\w+)/ or next;
-    $position{$1}=[$ref,$start,$stop,$strand];
-    $arms{$ref}{min} = $start if !defined($arms{$ref}{min}) || $arms{$ref}{min} > $start;
-    $arms{$ref}{max} = $stop  if !defined($arms{$ref}{max}) || $arms{$ref}{max} < $stop;
-  }
-  for my $ref (keys %arms) {
-    print join("\t",$ref,'arm','Component',$arms{$ref}{min},$arms{$ref}{max},'.','+','.',qq(Sequence "$ref")),"\n";
-  }
-  return \%position;
-  close F;
-}
-
-sub convert_scaffold {
-  my ($dir,$scaffold,$pos) = @_;
-  my ($ref,$rstart,$rstop,$rstrand) = @$pos;
-  my ($file) = <$dir/$scaffold*.gff>;
-  unless ($file && -r $file) {
-    warn "$scaffold: Can't find corresponding GFF file.  Skipping.\n";
-    return;
-  }
-
-  print join("\t",$ref,'scaffold','Component',$rstart,$rstop,'.',$rstrand,'.',qq(Sequence "$scaffold")),"\n";
-  open (F,$file) or die "Can't open $file: $!";
-
-  my @resultset  = ();
-  my $oldresultset = '';
-  while (<F>) {
-    next if /^#/;
-    chomp;
-    my ($cref,$csource,$cmethod,$cstart,$cstop,$cscore,$cstrand,$cphase,$cgroup) = split "\t";
-    next if $cstart > $cstop;  # something wrong. Don't bother fixing it.
-
-    if ($cgroup =~ /resultset_id=([^ ;]+)/) { # put aside to deal with later
-      my $resultset = $1;
-      if ($resultset ne $oldresultset && @resultset) {
-	dump_resultset($scaffold,$pos,\@resultset);
-	@resultset = ();
-      }
-      push @resultset,[$cref,$csource,$cmethod,$cstart,$cstop,$cscore,$cstrand,$cphase,$cgroup];
-      $oldresultset = $resultset;
-      next;
-    }
-
-    else {
-      (my $scref = $cref) =~ s/\.\d+$//;  # get rid of version number, if there is one
-      unless ($scref eq $scaffold) {
-	warn "$scaffold: feature uses $cref as reference.  Skipping";
-	next;
-      }
-    }
-
-    my ($start,$stop,$strand) = fix_coordinates($rstart,$rstop,$rstrand,$cstart,$cstop,$cstrand);
-    my $fixed_group = fix_group($csource,$cmethod,$cgroup);
-    print join("\t",$ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$fixed_group),"\n";
-    dump_symbol($ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$cgroup) if $cgroup =~ /symbol/i;
-  }
-  close F;
-  dump_resultset($scaffold,$pos,\@resultset);
-}
-
-# called when a full resultset is found
-sub dump_resultset {
-  my ($scaffold,$pos,$results) = @_;
-  return unless @$results;
-  local $^W = 0;
-  my ($rref,$rstart,$rstop,$rstrand) = @$pos;
-
-  my $genomic;
-  for my $d (@$results,[]) {
-
-    if (index($d->[0],$scaffold) >= 0) {  # bit of the genomic sequence
-      $genomic = $d;
-      next;
-    }
-
-    # if we get here, we're in the target
-    next unless $genomic; # don't know what to do with the thing
-    my ($tref,$tsource,$tmethod,$tstart,$tstop,$tscore,$tstrand,$tphase,$tgroup) = @$d;
-    my ($qref,$qsource,$qmethod,$qstart,$qstop,$qscore,$qstrand,$qphase,$qgroup) = @$genomic;
-
-    # Comments in the reference field are a no-no
-    $tref =~ s/\s+\(\d+ total\)$//;
-
-    # While we're at it, might as well change the EST nomenclature so that the
-    # 5', 3' pairs will automatically match in the viewer...
-    $tstrand = '-' if $tref =~ /revcomp/;
-
-    $tref =~ s/prime(_revcomp)?$//;
-
-    my ($method,$group);
-    ($tstart,$tstop) = ($tstop,$tstart) if $tstrand eq '-';
-
-    if ($qmethod eq 'alignment') {
-      $method = 'similarity';
-      $group = qq(Target "Sequence:$tref" $tstart $tstop);
-    }
-
-    elsif ($qmethod eq 'HSP' && $qsource eq 'blastx') {
-      $method = 'similarity';
-      $group = qq(Target "Protein:$tref" $tstart $tstop);
-    }
-
-    elsif ($qmethod eq 'HSP' && $qsource eq 'blastn') {
-      $method = 'similarity';
-      $group  = qq(Target "Sequence:$tref" $tstart $tstop);
-    }
-
-    elsif ($qsource eq 'clonelocator') {
-      $method  = 'clone';
-      $group   = qq(Target "Clone:$tref" $tstart $tstop);
-    }
-
-    elsif ($qsource eq 'gap') {
-      $method = 'Component';
-      if ($qgroup =~ /span_id=(:\w+)/) {
-	$group = "Gap $1";
-      }
-    }
-
-    elsif (defined $tstart && defined $tstop) {
-      $method = 'similarity';
-      $group = qq(Target "Sequence:$tref" $tstart $tstop);
-    }
-
-    $method ||= $qmethod;
-    next unless $group;
-
-    my ($start,$stop,$strand) = fix_coordinates($rstart,$rstop,$rstrand,$qstart,$qstop,$qstrand);
-
-    print join("\t",$rref,$qsource,$method,$start,$stop,$qscore,$qstrand,$qphase,$group),"\n";
-    undef $genomic;
-  }
-}
-
-sub fix_group {
-  my ($source,$method,$group) = @_;
-  my (@group,$gene);
-  push @group,"Transcript $1" if $group =~ /transgrp=([^; ]+)/;
-  push @group,"Gene $1"       if $method eq 'gene' && $group =~ /genegrp=([^; ]+)/;
-
-  $gene ||= qq(Note "FlyBase $1")  if $group =~ /dbxref=FlyBase:(\w+)/;
-  $gene ||= qq(Note "GadFly $1")   if $group =~ /genegrp=([^; ]+)/;
-  push @group,qq(Note "Symbol $1") if $group =~ /symbol=([^; ]+)/ && "Gene $1" ne $group[0];
-  push @group,$gene;
-  return join ' ; ',@group;
-}
-
-sub fix_coordinates {
-  my ($rstart,$rstop,$rstrand,$cstart,$cstop,$cstrand) = @_;  
-  # Fix the coordinates.  We are going to accomodate (-) strand scaffolds, even though they
-  # don't seem to occur
-  if ($rstrand eq '+') {
-    $cstart += ($rstart - 1);
-    $cstop  += ($rstart - 1);
-  } else {
-    $cstart += ($rstop - $cstart + 1);
-    $cstop  += ($rstop - $cstart + 1);
-    $cstrand = $cstrand eq '+' ? '-' : '+';
-  }
-  return ($cstart,$cstop,$cstrand);
-}
-
-# called when we encounter a gene symbol
-sub dump_symbol {
-  my ($ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$cgroup) = @_;
-  my ($symbol) = $cgroup=~/symbol=([^;]+)/;
-  my ($gene)   = $cgroup=~/genegrp=([^;]+)/;
-  return if $symbol eq $gene;
-  $cmethod = 'symbol';
-  print join("\t",$ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,qq(Symbol "$symbol")),"\n";
-}
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/generate_histogram.pl bioperl-1.1/scripts/Bio-DB-GFF/generate_histogram.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/generate_histogram.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/generate_histogram.pl	Wed Aug 28 10:27:41 2002
@@ -0,0 +1,137 @@
+#!/usr/bin/perl
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+
+use strict;
+use lib '.','./blib','../../blib/lib';
+use Bio::DB::GFF;
+use Getopt::Long;
+
+my $usage = <<USAGE;
+Usage: $0 [options] feature_type1 feature_type2...
+
+Dump out a GFF-formatted histogram of the density of the indicated set
+of feature types.
+
+ Options:
+   --dsn        <dsn>       Data source (default dbi:mysql:test)
+   --adaptor    <adaptor>   Schema adaptor (default dbi::mysqlopt)
+   --user       <user>      Username for mysql authentication
+   --pass       <password>  Password for mysql authentication
+   --bin        <bp>        Bin size in base pairs.
+   --aggregator <list>      Comma-separated list of aggregators
+   --sort                   Sort the resulting list by type and bin
+   --merge                  Merge features with same method but different sources
+USAGE
+;
+
+my ($DSN,$ADAPTOR,$AGG,$USER,$PASSWORD,$BINSIZE,$SORT,$MERGE);
+GetOptions ('dsn:s'         => \$DSN,
+	    'adaptor:s'     => \$ADAPTOR,
+	    'user:s'        => \$USER,
+	    'password:s'    => \$PASSWORD,
+            'aggregators:s' => \$AGG,
+            'bin:i'         => \$BINSIZE,
+	    'sort'          => \$SORT,
+	    'merge'         => \$MERGE,
+	   ) or die $usage;
+
+my @types = @ARGV or die $usage;
+
+# some local defaults
+$DSN     ||= 'dbi:mysql:test';
+$ADAPTOR ||= 'dbi::mysqlopt';
+$BINSIZE ||= 1_000_000;   # 1 megabase bins
+
+my @options;
+push @options,(-user=>$USER)     if defined $USER;
+push @options,(-pass=>$PASSWORD) if defined $PASSWORD;
+push @options,(-aggregator=>[split /\s+/,$AGG]) if defined $AGG;
+
+my $db = Bio::DB::GFF->new(-adaptor=>$ADAPTOR,-dsn => $DSN,@options)
+  or die "Can't open database: ",Bio::DB::GFF->error,"\n";
+
+my @features = $db->features(-binsize=>$BINSIZE,-types=>\@types);
+
+if ($MERGE) {
+  my %MERGE;
+  for my $f (@features) {
+    my $name  = $f->name;
+    my $class = $name->class;
+    $name =~ s/^(.+:.+):.+$/$1/;
+    $f->group(Bio::DB::GFF::Featname->new($class,$name));
+    my $source = $f->source;
+    $source =~ s/:.+$//;
+    $f->source($source);
+    if (my $already_there = $MERGE{$f->source,$f->abs_ref,$f->abs_start}) {
+      $already_there->score($already_there->score + $f->score);
+    } else {
+      $MERGE{$f->source,$f->abs_ref,$f->abs_start} = $f;
+    }
+  }
+  @features = values %MERGE;
+}
+
+# sort features by type, ref and start if requested
+if ($SORT) {
+  @features = sort {
+    $a->type cmp $b->type
+      || $a->abs_ref cmp $b->abs_ref
+	|| $a->start <=> $b->start
+      }
+    @features;
+}
+
+for my $f (@features) {
+  print $f->gff_string,"\n";
+}
+
+
+__END__
+
+=head1 NAME
+
+generate_histogram.pl -- Generate a histogram of Bio::DB::GFF features
+
+=head1 SYNOPSIS
+
+  generate_histogram.pl -d gadfly variation gene:curated
+
+=head1 DESCRIPTION
+
+Use this utility to generate feature density histograms from
+Bio::DB::GFF databases.  The result is a GFF data file that is
+suitable for loading with load_gff.pl.
+
+=head2 OPTIONS
+
+The following options are recognized:
+
+  Option        Description
+  ------        -----------
+
+   --dsn        <dsn>       Data source (default dbi:mysql:test)
+   --adaptor    <adaptor>   Schema adaptor (default dbi::mysqlopt)
+   --user       <user>      Username for mysql authentication
+   --pass       <password>  Password for mysql authentication
+   --aggregator <list>      Comma-separated list of aggregators
+
+=head1 BUGS
+
+Please report them.
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>
+
+=head1 AUTHOR
+
+Lincoln Stein E<lt>lstein@cshl.orgE<gt>
+
+Copyright (c) 2001 Cold Spring Harbor Laboratory
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.  See DISCLAIMER.txt for
+disclaimers of warranty.
+
+=cut
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/load_gff.pl bioperl-1.1/scripts/Bio-DB-GFF/load_gff.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/load_gff.pl	Wed Jan 30 11:02:51 2002
+++ bioperl-1.1/scripts/Bio-DB-GFF/load_gff.pl	Fri Sep 27 11:59:49 2002
@@ -58,7 +58,7 @@
   warn qq(expect to see several "table already exists" messages\n);
   $db->initialize(0);
   my $dbi = $db->dbh;  # get the raw database handle
-  my ($count) = $dbi->selectrow_array('SELECT COUNT(*) FROM FNOTE');
+  my ($count) = $dbi->selectrow_array('SELECT COUNT(*) FROM fnote');
   if (defined($count) && $count > 0) {
     warn qq(fnote table detected.  Translating into fattribute table.  This may take a while.\n);
     $dbi->do("INSERT INTO fattribute VALUES (1,'Note')") or die "failed: ",$dbi->errstr;
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/process_gadfly.pl bioperl-1.1/scripts/Bio-DB-GFF/process_gadfly.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/process_gadfly.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/process_gadfly.pl	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,336 @@
+#!/usr/bin/perl
+
+
+if ($ARGV[0]=~/^-?-h/i) {
+die <<USAGE;
+
+This script massages the Flybase/Gadfly GFF files located at
+ftp://ftp.fruitfly.org/pub/genomic/gadfly/ into the "correct" version
+of the GFF format.
+
+To use this script, download the Gadfly GFF distribution archive which
+are organized by chromosome arm (e.g. "RELEASE2GFF.2L.tar.gz").
+Unpack them will yield a directory named after the release,
+e.g. RELEASE2, containing a directory named after the chromosome arm.
+Do this repeatedly in order to create a directory that contains each
+of the chromosome arms, i.e.:
+
+   RELEASE2/gff/X
+   RELEASE2/gff/2L
+   RELEASE2/gff/2R
+   ...
+
+Give the release directory as the argument to this script, and capture
+the script's output to a file:
+
+  % process_gadfly.pl ./RELEASE2 > fly.gff
+
+The gadfly.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d fly fly.gff
+
+(Where "fly" is the name of the database.  Change it as appropriate.
+The database must already exist and be writable by you!)
+
+The resulting database will have the following feature types
+(represented as "method:source"):
+
+  Component:arm              A chromosome arm
+  Component:scaffold	     A chromosome scaffold (accession #)
+  Component:gap	             A gap in the assembly
+  clone:clonelocator         A BAC clone
+  gene:gadfly                A gene accession number
+  transcript:gadfly          A transcript accession number
+  translation:gadfly         A translation
+  codon:gadfly               Significance unknown
+  exon:gadfly                An exon
+  symbol:gadfly              A classical gene symbol
+  similarity:blastn          A BLASTN hit
+  similarity:blastx          A BLASTX hit
+  similarity:sim4            EST->genome using SIM4
+  similarity:groupest        EST->genome using GROUPEST
+  similarity:repeatmasker    A repeat
+
+NOTE: Loading the DNA:
+
+To load the fly DNA, download the FASTA format file for the
+corresponding release in chromosome arm format
+(e.g. ftp://ftp.fruitfly.org/pub/genomic/fasta/na_arms.dros.RELEASE2.Z),
+and uncompress the file with the "uncompress" command.  This file will
+also need to be converted to fix the names of the chromosome arms.
+Use the following Perl command to do this:
+
+ % perl -pi -e 's/^>Chromosome_arm_(\S+)/>$1/' na_arms.dros.RELEASE2
+
+Now use bulk_load_gff.pl with the -fasta option in order to load the
+DNA as well as the GFF data:
+
+  % bulk_load_gff.pl -d fly -fasta na_arms.dros.RELEASE2 fly.gff
+
+USAGE
+;
+}
+
+use strict;
+my $dir = shift || './RELEASE2';
+$dir   .= "/gff";
+my $map = read_map($dir) || die;
+for my $scaffold (sort {
+                       $map->{$a}[0] cmp $map->{$b}[0]
+			 ||
+		       $map->{$a}[1] <=> $map->{$b}[1]
+		     } keys %$map) {
+  convert_scaffold($dir,$scaffold,$map->{$scaffold});
+}
+
+
+sub read_map {
+  my $dir = shift;
+  my ($segments) = <$dir/*/SEGMENTS*.gff>;
+  my %arms;
+  $segments or die "Can't find SEGMENTS file";
+  open (F,$segments) or die "Can't open $segments: $!";
+  my %position;
+  while (<F>) {
+    chomp;
+    my ($ref,$source,$method,$start,$stop,undef,$strand,undef,$group) = split "\t";
+    $group =~ /name=(\w+)/ or next;
+    $position{$1}=[$ref,$start,$stop,$strand];
+    $arms{$ref}{min} = $start if !defined($arms{$ref}{min}) || $arms{$ref}{min} > $start;
+    $arms{$ref}{max} = $stop  if !defined($arms{$ref}{max}) || $arms{$ref}{max} < $stop;
+  }
+  for my $ref (keys %arms) {
+    print join("\t",$ref,'arm','Component',$arms{$ref}{min},$arms{$ref}{max},'.','+','.',qq(Sequence "$ref")),"\n";
+  }
+  return \%position;
+  close F;
+}
+
+sub convert_scaffold {
+  my ($dir,$scaffold,$pos) = @_;
+  my ($ref,$rstart,$rstop,$rstrand) = @$pos;
+  my ($file) = <$dir/*/$scaffold*.gff>;
+  unless ($file && -r $file) {
+    warn "$scaffold: Can't find corresponding GFF file.  Skipping.\n";
+    return;
+  }
+
+  print join("\t",$ref,'scaffold','Component',$rstart,$rstop,'.',$rstrand,'.',qq(Sequence "$scaffold")),"\n";
+  open (F,$file) or die "Can't open $file: $!";
+
+  my @resultset  = ();
+  my $oldresultset = '';
+  while (<F>) {
+    next if /^#/;
+    chomp;
+    my ($cref,$csource,$cmethod,$cstart,$cstop,$cscore,$cstrand,$cphase,$cgroup) = split "\t";
+    next if $cstart > $cstop;  # something wrong. Don't bother fixing it.
+
+    if ($cgroup =~ /resultset_id=([^ ;]+)/) { # put aside to deal with later
+      my $resultset = $1;
+      if ($resultset ne $oldresultset && @resultset) {
+	dump_resultset($scaffold,$pos,\@resultset);
+	@resultset = ();
+      }
+      push @resultset,[$cref,$csource,$cmethod,$cstart,$cstop,$cscore,$cstrand,$cphase,$cgroup];
+      $oldresultset = $resultset;
+      next;
+    }
+
+    else {
+      (my $scref = $cref) =~ s/\.\d+$//;  # get rid of version number, if there is one
+      unless ($scref eq $scaffold) {
+	warn "$scaffold: feature uses $cref as reference.  Skipping";
+	next;
+      }
+    }
+
+    my ($start,$stop,$strand) = fix_coordinates($rstart,$rstop,$rstrand,$cstart,$cstop,$cstrand);
+    my $fixed_group = fix_group($csource,$cmethod,$cgroup);
+    print join("\t",$ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$fixed_group),"\n";
+    dump_symbol($ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$cgroup),"\n" if $cgroup =~ /symbol/i;
+  }
+  close F;
+  dump_resultset($scaffold,$pos,\@resultset);
+}
+
+# called when a full resultset is found
+sub dump_resultset {
+  my ($scaffold,$pos,$results) = @_;
+  return unless @$results;
+  local $^W = 0;
+  my ($rref,$rstart,$rstop,$rstrand) = @$pos;
+
+  my $genomic;
+  for my $d (@$results,[]) {
+
+    if (index($d->[0],$scaffold) >= 0) {  # bit of the genomic sequence
+      $genomic = $d;
+      next;
+    }
+
+    # if we get here, we're in the target
+    next unless $genomic; # don't know what to do with the thing
+    my ($tref,$tsource,$tmethod,$tstart,$tstop,$tscore,$tstrand,$tphase,$tgroup) = @$d;
+    my ($qref,$qsource,$qmethod,$qstart,$qstop,$qscore,$qstrand,$qphase,$qgroup) = @$genomic;
+
+    # Comments in the reference field are a no-no
+    $tref =~ s/\s+\(\d+ total\)$//;
+
+    # While we're at it, might as well change the EST nomenclature so that the
+    # 5', 3' pairs will automatically match in the viewer...
+    $tstrand = '-' if $tref =~ /revcomp/;
+
+    $tref =~ s/prime(_revcomp)?$//;
+
+    my ($method,$group);
+    ($tstart,$tstop) = ($tstop,$tstart) if $tstrand eq '-';
+
+    if ($qmethod eq 'alignment') {
+      $method = 'similarity';
+      $group = qq(Target "Sequence:$tref" $tstart $tstop);
+    }
+
+    elsif ($qmethod eq 'HSP' && $qsource eq 'blastx') {
+      $method = 'similarity';
+      $group = qq(Target "Protein:$tref" $tstart $tstop);
+    }
+
+    elsif ($qmethod eq 'HSP' && $qsource eq 'blastn') {
+      $method = 'similarity';
+      $group  = qq(Target "Sequence:$tref" $tstart $tstop);
+    }
+
+    elsif ($qsource eq 'clonelocator') {
+      $method  = 'clone';
+      $group   = qq(Target "Clone:$tref" $tstart $tstop);
+    }
+
+    elsif ($qsource eq 'gap') {
+      $method = 'Component';
+      if ($qgroup =~ /span_id=(:\w+)/) {
+	$group = "Gap $1";
+      }
+    }
+
+    elsif (defined $tstart && defined $tstop) {
+      $method = 'similarity';
+      $group = qq(Target "Sequence:$tref" $tstart $tstop);
+    }
+
+    $method ||= $qmethod;
+    next unless $group;
+
+    my ($start,$stop,$strand) = fix_coordinates($rstart,$rstop,$rstrand,$qstart,$qstop,$qstrand);
+
+    print join("\t",$rref,$qsource,$method,$start,$stop,$qscore,$qstrand,$qphase,$group),"\n";
+    undef $genomic;
+  }
+}
+
+sub fix_group {
+  my ($source,$method,$group) = @_;
+  my (@group,$gene);
+  push @group,"Transcript $1" if $group =~ /transgrp=([^; ]+)/;
+  push @group,"Gene $1"       if $method eq 'gene' && $group =~ /genegrp=([^; ]+)/;
+
+  $gene ||= qq(Note "FlyBase $1")  if $group =~ /dbxref=FlyBase:(\w+)/;
+  $gene ||= qq(Note "GadFly $1")   if $group =~ /genegrp=([^; ]+)/;
+  push @group,qq(Note "Symbol $1") if $group =~ /symbol=([^; ]+)/ && "Gene $1" ne $group[0];
+  push @group,$gene;
+  return join ' ; ',@group;
+}
+
+sub fix_coordinates {
+  my ($rstart,$rstop,$rstrand,$cstart,$cstop,$cstrand) = @_;  
+  # Fix the coordinates.  We are going to accomodate (-) strand scaffolds, even though they
+  # don't seem to occur
+  if ($rstrand eq '+') {
+    $cstart += ($rstart - 1);
+    $cstop  += ($rstart - 1);
+  } else {
+    $cstart += ($rstop - $cstart + 1);
+    $cstop  += ($rstop - $cstart + 1);
+    $cstrand = $cstrand eq '+' ? '-' : '+';
+  }
+  return ($cstart,$cstop,$cstrand);
+}
+
+# called when we encounter a gene symbol
+sub dump_symbol {
+  my ($ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,$cgroup) = @_;
+  my ($symbol) = $cgroup=~/symbol=([^;]+)/;
+  my ($gene)   = $cgroup=~/genegrp=([^;]+)/;
+  return if $symbol eq $gene;
+  $cmethod = 'symbol';
+  print join("\t",$ref,$csource,$cmethod,$start,$stop,$cscore,$strand,$cphase,qq(Symbol "$symbol")),"\n";
+}
+
+__END__
+
+=head1 NAME
+
+process_gadfly.pl - Massage Gadfly/FlyBase GFF files into a version suitable for the Generic Genome Browser
+
+=head1 SYNOPSIS
+
+  % process_gadfly.pl ./RELEASE2 > gadfly.gff
+
+=head1 DESCRIPTION
+
+This script massages the Flybase/Gadfly GFF files located at
+ftp://ftp.fruitfly.org/pub/genomic/gadfly/ into the "correct" version
+of the GFF format.
+
+To use this script, get the Gadfly GFF distribution archive which is
+organized by GenBank accession unit (e.g. "RELEASE2GFF.tar.gz").
+Unpacking it will yield a directory named after the release,
+e.g. RELEASE2.
+
+Give that directory as the argument to this script, and capture the
+script's output to a file:
+
+  % process_gadfly.pl ./RELEASE2 > gadfly.gff
+
+The gadfly.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d <databasename> gadfly.gff
+
+The resulting database will have the following feature types
+(represented as "method:source"):
+
+  Component:arm              A chromosome arm
+  Component:scaffold	     A chromosome scaffold (accession #)
+  Component:gap	             A gap in the assembly
+  clone:clonelocator         A BAC clone
+  gene:gadfly                A gene accession number
+  transcript:gadfly          A transcript accession number
+  translation:gadfly         A translation
+  codon:gadfly               Significance unknown
+  exon:gadfly                An exon
+  symbol:gadfly              A classical gene symbol
+  similarity:blastn          A BLASTN hit
+  similarity:blastx          A BLASTX hit
+  similarity:sim4            EST->genome using SIM4
+  similarity:groupest        EST->genome using GROUPEST
+  similarity:repeatmasker    A repeat
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>, L<bulk_load_gff.pl>, L<load_gff.pl>
+
+=head1 AUTHOR
+
+Lincoln Stein <lstein@cshl.org>.
+
+Copyright (c) 2002 Cold Spring Harbor Laboratory
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.  See DISCLAIMER.txt for
+disclaimers of warranty.
+
+=cut
+
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/process_ncbi_human.pl bioperl-1.1/scripts/Bio-DB-GFF/process_ncbi_human.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/process_ncbi_human.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/process_ncbi_human.pl	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,431 @@
+#!/usr/local/bin/perl
+
+=head1 NAME
+
+ncbi_2_gff.pl - Massage NCBI chromosome annotation into GFF-format suitable for Bio::DB::GFF
+
+=head1 VERSION (CVS-info)
+
+ $RCSfile: bioperl-102-1.1.patch,v $
+ $Revision: 1.1 $
+ $Author: lstein $
+ $Date: 2002-10-07 00:22:01 $
+
+
+=head2 SYNOPSIS
+
+   perl ncbi_to_gff.pl [options] /path/to/gzipped/datafile(s)
+
+=head2 DESCRIPTION
+
+This script massages the chromosome annotation files located at
+
+  ftp://ftp.ncbi.nih.gov/genomes/H_sapiens/maps/mapview/chromosome_order/
+
+into the GFF-format recognized by Bio::DB::GFF. If the resulting
+GFF-files are loaded into a Bio::DB:GFF database using the utilities
+described below, the annotation can be viewed in the Generic Genome
+Browser (http://www.gmod.org/ggb/) and interfaced with using the
+Bio::DB:GFF libraries.
+
+  (NB these NCBI-datafiles are dumps from their own mapviewer database
+  backend, according to their READMEs)
+
+To produce the GFF-files, download all the chr*sequence.gz files from
+the FTP-directory above. While in that same directory, run the
+following example command (see also help clause by running script with
+no arguments):
+
+ncbi_to_gff.pl --locuslink [path to LL.out_hs.gz] chr*sequence.gz This
+will unzip all the files on the fly and open an output file with the
+name chrom[$chrom]_ncbiannotation.gff for each, read the LocusLink
+records into an in-memory hash and then read through the NCBI feature
+lines, lookup 'locus' features in the LocusLink hash for details on
+'locus' features and print to the proper GFF files.  
+
+LL.out_hs.gz is accessible here at the time of writing:
+
+  ftp://ftp.ncbi.nih.gov/refseq/LocusLink/LL.out_hs.gz
+
+Note that several of the NCBI features are skipped from the
+reformatting, either because their nature is not fully known at this
+time (TAG,GS_TRAN) or their sheer volume stands in the way of them
+being accessibly in Bio::DB::GFF at this time (EST similarities). You
+can easily change this by modifying the $SKIP variable to your liking
+to add or remove features, but if you add then you will have to add
+handling for those new features.
+
+To bulk-import the GFF-files into a Bio::DB::GFF database, use the
+bulk_load_gff.pl or load_gff.pl utilities provided with Bio::DB::GFF.
+
+Note that this utility contains some code that is specific for the TSC
+database at CSHL.  This code can safely be ignored.
+
+=head2 AUTHOR
+
+Gudmundur Arni Thorisson E<lt>mummi@cshl.orgE<gt>
+
+Copyright (c) 2002 Cold Spring Harbor Laboratory
+
+       This code is free software; you can redistribute it
+       and/or modify it under the same terms as Perl itself.
+
+=cut
+
+use strict;
+use Getopt::Long;
+use IO::File;
+use Bio::DB::GFF::Util::Binning 'bin';
+use File::Basename;
+
+my $self = basename($0);
+my ($doTSCSNP,$doLocuslink);
+my $opt = &GetOptions ('locuslink=s'  => \$doLocuslink,
+		       'tscsnp=s'     => \$doTSCSNP
+		       );
+die <<USAGE if(!defined($opt) || @ARGV == 0);
+Usage: $self [options] <GFF filename or wildcard pattern>
+
+  Massage NCBI chromosome annotation datafiles into GFF-format
+  suitable for importing into Bio::DB::GFF database. Note that the
+  program handles both unzipped datafiles and gzipped, bzipped or
+  compressed ones, so do not bother with unzipping big downloads
+  before running.
+
+  See 'perldoc $self' for more info
+
+Options:
+   --locuslink Path to zipped LocusLink file, currently located at
+               ftp://ftp.ncbi.nih.gov/refseq/LocusLink/LL.out_hs.gz
+               used to lookup gene description and official symbols
+   --tscsnp    DSN string to TSC MySQL database to use for auxiliary
+               SNP feature attributes (CSHL internal use)
+
+  Options can be abbreviated.  For example, you can use -l for
+  --locuslink.
+
+Author: Gudmundur Arni Thorisson <mummi\@cshl.org>
+
+Copyright (c) 2002 Cold Spring Harbor Laboratory This library is free
+software; you can redistribute it and/or modify it under the same
+terms as Perl itself.
+
+USAGE
+;
+
+#Prepare decompression streams for input files, if necessary
+my %FH;
+print "\nPreparing input and output streams:\n";
+foreach (@ARGV) {
+    my ($chrom) = /0?([0-9,XYxy]{1,2})/;
+    unless($chrom)
+    {
+	print "can't get chrom name from filename '$_', SKIPPING";
+	next;
+    }
+    $FH{'Chr'.$chrom} = IO::File->new("chrom$chrom\_ncbiannotation.gff",">") or die $_,": $!";
+    $_ = "gunzip -c $_ |" if /\.gz$/;
+    $_ = "uncompress -c $_ |" if /\.Z$/;
+    $_ = "bunzip2 -c $_ |" if /\.bz2$/;
+}
+
+#If TSC SNP processing is to be performed, connect to db and prepare query
+my $dbh;
+my $tsc_sth;
+if($doTSCSNP)
+{
+    #Is this an argstring or file with the string in it?
+    my $dbistring = -f $doTSCSNP ? `cat $doTSCSNP` : $doTSCSNP;
+    $dbh = &dbConnect($dbistring);
+    print "Connecting to TSC database using '$dbistring'\n";
+    my $query = qq/
+SELECT ta.snp_id,
+       ta.variation,
+       tr.locus_id,
+       tr.gene_symbol,
+       tr.fxn_class,
+       tf.institute_code as lab,
+       tf.pop_type,
+       tf.outcome,
+       tf.pooled_data,
+       tf.num_people_typed,
+       tf.allele_a_freq as A,
+       tf.allele_c_freq as C,
+       tf.allele_g_freq as G,
+       tf.allele_t_freq as T
+FROM tbl_dbsnp_2_tsc dbsnp
+LEFT JOIN tbl_refsnp_gene_fxn tr on tr.refsnp_id=dbsnp.rs_id
+LEFT JOIN tbl_allele_freq tf on tf.dbsnp_id=dbsnp.ss_id
+LEFT JOIN TBL_SNP_ALL ta on ta.snp_id = dbsnp.tsc_id
+WHERE dbsnp.rs_id = ? limit 1/;
+    $tsc_sth = $dbh->prepare($query);
+}
+
+#If Locuslink-processing is to be performed, Read 
+#previously cached data structure from disk
+my $llData;
+
+
+if($doLocuslink)
+{
+    $doLocuslink = "gunzip -c $doLocuslink |" if $doLocuslink =~ /\.gz$/;
+    $doLocuslink = "uncompress -c $doLocuslink |" if $doLocuslink =~ /\.Z$/;
+    $doLocuslink = "bunzip -c $doLocuslink |" if $doLocuslink =~ /\.bz$/;
+    open LL,$doLocuslink || die $!;
+    my $l = 0;
+    while(<LL>)
+    {
+	$l++;
+	print "\r--$l LocusLink records loaded" if $l % 100 ==0;
+	my ($id,$osym,$isym,$mim,$chrom,$loc,$desc,$taxid,$db) = split /\t/;
+	my $name = $osym || $isym;
+	#print "  Loading in Locuslink id='$id',osym='$osym',isym='$isym',name='$name',desc='$desc'\n";
+	$llData->{$id}->{name} = $name;
+	$llData->{$id}->{isym} = $isym;
+	$llData->{$id}->{mim}  = $mim;
+	$llData->{$id}->{chrom}= $chrom;
+	$llData->{$id}->{loc}  = $loc;
+	$llData->{$id}->{desc} = $desc;
+	$llData->{$id}->{taxid}= $taxid;
+	$llData->{$id}->{db}   = $db;
+    }
+    close LL;
+}
+
+
+my %sources     = (snp        => 'dbSNP',
+		   sts        => 'UniSTS',
+		   locus      => 'LocusLink',
+		   transcript => 'RefSeq',
+		   component  => 'Genbank',
+		   contig     => 'RefSeq',
+		   );
+my %classes = (component    => 'Sequence',
+	       sts          => 'STS',
+	       snp          => 'SNP',
+	       locus        => 'Locus',
+	       transcript   => 'Transcript',
+	       contig       => 'Contig',
+	       clone        => 'Clone',
+	       );
+
+my %subcomponents = (transcript => 'exon',
+		     locus      => 'exon',		     
+		     component  => 'subcomponent',
+		     );
+
+
+#And now process all incoming data streams
+my $i = 0;
+my %maxCoords;
+my $SKIP = q/^EST|^TAG|^GS_TRAN|component|clone/;
+my %groups   = (); #aggregate parent features
+my %density  = ();
+my $binSize  = 100000;
+my $max = 0;
+while(<>)
+{
+    chomp;
+    next if /^\#/;
+    my ($type,$objId,$name,$chrom,$start,$stop,$strand) = split "\t";
+    my $score = '.';
+    next if $type =~ /$SKIP/;
+    $i++;
+    #my ($chrom,$ctg) = split /\|/,$chromctg;
+    next if $chrom =~ /NT/; #ambigously placed NT-contig at start of chrom
+    $chrom = "Chr$chrom";
+    $max = $stop if $stop > $max;
+    my $class;
+    unless($class  = $classes{$type})
+    {
+	print "need class for type '$type': '$_' (OR add type to \$SKIP pattern\n";
+	next;
+    }
+    my $method = $type;
+    my $source = $sources{$type} || die "ERROR: need source for type '$type'";
+    $objId = $name if $type =~ /transcript|snp|contig/;
+    my $attributes = qq/$class $objId; Name $name/;
+    my $bin = &bin($start,$stop,$binSize);
+    $bin =~ s/^[10]+\.[0]+//;
+    $bin ||= 0;
+    #print "\$bin='$bin' ($start=>$stop)\n";
+    $density{$chrom}->{$method.'_dens:'.$source}->{$bin}++;
+    
+    #Deduce start/stop for certain parent features to be printed
+    #to output file AFTER we've processed everything. This is 
+    #necessary because NCBI only gives start/stop values for the child
+    #features, like exons in a gene, but not the whole parent feature
+    if($type =~ /transcript|locus/)
+    {
+	$groups{$type}->{$objId}->{$chrom}->{name} = $name;
+	$groups{$type}->{$objId}->{$chrom}->{start} ||= 9999999999999;
+	$groups{$type}->{$objId}->{$chrom}->{stop} ||= 0;
+	$groups{$type}->{$objId}->{$chrom}->{start} = $start 
+	    if  $start < $groups{$type}->{$objId}->{$chrom}->{start};
+	$groups{$type}->{$objId}->{$chrom}->{stop} = $stop 
+	    if $stop > $groups{$type}->{$objId}->{$chrom}->{stop}; 
+	$groups{$type}->{$objId}->{$chrom}->{source} = $source;
+	$groups{$type}->{$objId}->{$chrom}->{strand} = $strand;
+	$groups{$type}->{$objId}->{$chrom}->{method} = $method;
+	$groups{$type}->{$objId}->{$chrom}->{class} = $class;
+	$method  = $subcomponents{$type};
+	next if  $type eq 'locus';
+    }
+    #This is for internal CSHL usage
+    elsif($type =~ /snp/ && $doTSCSNP)
+    {
+	if(my $tscAttributes = &queryTSCdb($dbh,$name))
+	{
+	    $attributes .= $tscAttributes;
+	}
+    }
+
+    #Trying to work around the contig pile-up at the start of a chromosome 
+    if($method eq 'contig' && $stop == 0)
+    {
+	print STDERR "SKIPPING, contig '$name' as stop = $stop and start = $start.\n";
+    }
+
+    #And finally print to the proper output stream
+    $FH{$chrom}->print(qq/$chrom\t$source\t$method\t$start\t$stop\t.\t$strand\t$score\t$attributes\n/);
+
+    #Collect max coordinates, to deduce chromosome sizes
+    $maxCoords{$chrom} ||= 0;
+    $maxCoords{$chrom} = $stop if $stop > $maxCoords{$chrom};
+    
+    #Progress indicator
+    if ( $i % 1000 == 0) 
+    {
+	print STDERR "$i features parsed...";
+	print STDERR -t STDOUT && !$ENV{EMACS} ? "\r" : "\n";
+    }
+}#MAIN LOOP ENDS
+
+
+#Print out group features like transcripts and genes that 
+#were collected before and print to the proper output streams
+print "\nPrinting out collected aggregate features\n";
+foreach my $type(keys %groups)
+{
+    foreach my $objId (keys %{$groups{$type}})
+    {
+	#print "\$name='$name'\n";
+	foreach my $chrom(keys %{$groups{$type}->{$objId}})
+	{
+	    my $name    = $groups{$type}->{$objId}->{$chrom}->{name};
+	    my $start   = $groups{$type}->{$objId}->{$chrom}->{start};
+	    my $stop    = $groups{$type}->{$objId}->{$chrom}->{stop};
+	    my $strand  = $groups{$type}->{$objId}->{$chrom}->{strand};
+	    my $method  = $groups{$type}->{$objId}->{$chrom}->{method};
+	    my $class   = $groups{$type}->{$objId}->{$chrom}->{class};
+	    my $source  = $groups{$type}->{$objId}->{$chrom}->{source};
+	    if($type eq 'locus' && $doLocuslink)
+	    {
+		my $llInfo = '';
+		my $ll    = $llData->{$objId};
+		my $id    = $ll->{id};
+		my $note  = $ll->{desc} ? qq/Note "$name:$ll->{desc}"/ : ' ';
+		$note =~ s/;/\\;/g;
+		$FH{$chrom}->print( qq/$chrom\t$source\t$method\t$start\t$stop\t.\t$strand\t.\tLocus $objId; Name $name; Alias $name; $note\n/);
+	    }
+	    else
+	    {
+		$FH{$chrom}->print(qq/$chrom\t$source\t$method\t$start\t$stop\t.\t$strand\t.\t$class $name; Name $name\n/);
+	    }
+	}
+    }
+}
+
+#   	$density{$method.'_dens:'.$source}->{$bin}++;
+#Print out the collected binned density stats
+print "Printing out density stats\n";
+
+foreach my $chrom(sort keys %density)
+{
+    foreach my $meth(sort keys %{$density{$chrom}})
+    {
+	my $bc = 0;
+	foreach my $bin(sort {$a<=>$b}keys %{$density{$chrom}->{$meth}})
+	{
+	    $bc++;
+	    my $count = $density{$chrom}->{$meth}->{$bin};
+	    my $binstart = $bin*$binSize;
+	    my $binstop  = $binstart+$binSize;
+	    print "  \$bin=$bin,\$binstart=$binstart,\$count=$count\n";
+	    $FH{$chrom}->print(qq/$chrom\tNCBI\t$meth\t$binstart\t$binstop\t$count\t.\t.\t\n/);
+	}
+	print " $bc bins for method $meth\n";
+    }
+}
+
+#Print a line for the reference sequences themselves
+while(my ($chrom,$max) = each %maxCoords)
+{
+    $FH{$chrom}->print(qq/$chrom\tassembly\tchromosome\t1\t$max\t.\t+\t.\tSequence \"$chrom\"\n/);
+}
+
+print "\nDONE. $i features parsed\n\n";
+
+#------------------------------------------------
+# Subroutines
+#------------------------------------------------
+
+#For internal CSHL use. Queries our inhouse MySQL database with 
+#SNP Consortium data for various auxiliary data on some SNPs
+sub queryTSCdb
+{
+    my $dbh   = shift;
+    my $rs_id = shift;
+    my $attributes;
+    $rs_id  =~ s/rs//;
+
+    #Baeat vid herna, na i classification string fra dbSNP
+    my ($tsc_id,$var,$lab,$dbsnp_id,$class,$gene_symbol,$locus_id,$freq);
+    $tsc_sth->execute($rs_id) || die $@;
+    my $tscInfo = $tsc_sth->fetchrow_hashref() || return undef;
+    do{
+	#while(my($k,$v) = each %$tscInfo){print "  '$k'=>'$v'\n";}
+	#dbSNP stuff, may apply to more than just TSC snps
+	$locus_id = $tscInfo->{locus_id};
+	$class = $tscInfo->{fxn_class};
+	$gene_symbol = $tscInfo->{gene_symbol};
+ 	$attributes .= qq/; SNPClass $class/ if $class;
+
+	#TSC specific stuff
+	$tsc_id = $tscInfo->{snp_id} || return $attributes;
+	$tsc_id = sprintf("TSC%7.7d", $tsc_id);
+	$var = lc $tscInfo->{variation};
+	$lab = $tscInfo->{institute_code};
+	$dbsnp_id = $tscInfo->{dbsnp_id};
+	$freq = 1 if $tscInfo->{pop_type} && $tscInfo->{outcome} eq 'S';
+	$attributes .= qq/; Alias $tsc_id/;
+	#$attributes .= qq/; Alias ss$dbsnp_id/ if $dbsnp_id;
+	#$attributes .= qq/; TSCName $tsc_id/;
+	#$attributes .= qq/; Note $tsc_id($var)/;
+	$attributes .= qq/; Variation $var/ if $var;
+	$attributes .= qq/; AllFreq 1/ if $freq;
+    }while($tscInfo = $tsc_sth->fetchrow_hashref());
+    $rs_id = $dbh=$tsc_id=$var=$lab=$dbsnp_id=$class=$gene_symbol=$locus_id= $tscInfo=$freq= undef;
+    return  $attributes;
+}
+
+sub dbConnect
+{
+    my $dsn = shift;
+    my $dbh;
+    use DBI;
+    eval{$dbh = DBI->connect($dsn,
+			     {
+				 RaiseError => 1,
+				 FetchHashKeyName => 'NAME_lc',
+			     }
+                             )
+         };
+    if($@ || !$dbh)
+    {
+        print STDERR "ERROR, cannot connect to DB! $@\n";
+        die $DBI::errstr;
+    }
+    return $dbh;
+}
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/process_sgd.pl bioperl-1.1/scripts/Bio-DB-GFF/process_sgd.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/process_sgd.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/process_sgd.pl	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# This script will convert from SGD format to GFF format
+# See http://genome-www4.stanford.edu/Saccharomyces/SGD/doc/db_specifications.html
+
+use strict;
+
+# hard-coded length data that I couldn't get directly
+my %CHROMOSOMES = (I => 230_203,
+		   II => 813_139,
+		   III => 316_613,
+		   IV  => 1_531_929,
+		   V   => 576_869,
+		   VI => 270_148,
+		   VII => 1_090_937,
+		   VIII => 562_639,
+		   IX => 439_885,
+		   X => 745_444,
+		   XI => 666_445,
+		   XII => 1_078_173,
+		   XIII => 924_430,
+		   XIV => 784_328,
+		   XV  => 1_091_284,
+		   XVI => 948_061,
+		   Mit => 85_779);
+my @ROMAN = qw(I II III IV V VI VII VIII IX X
+	       XI XII XIII XIV XV XVI Mit);
+
+if ($ARGV[0] =~ /^--?h/) {
+  die <<USAGE;
+ Usage: $0 <SGD features file>
+
+This script massages the SGD sequence annotation flat files located at
+ftp://genome-ftp.stanford.edu/pub/yeast/data_dump/feature/chromosomal_features.tab
+into a version of the GFF format suitable for display by the generic
+genome browser.
+
+To use this script, get the SGD chromosomal_features.tab file from the
+FTP site listed above, and run the following command:
+
+  % process_sgd.pl chromosomal_features.tab > yeast.gff
+
+The yeast.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d <databasename> yeast.gff
+
+USAGE
+;
+}
+
+# first print out chromosomes
+# We hard coded the lengths because they are not available in the features table.
+for my $chrom (sort keys %CHROMOSOMES) {
+  print join("\t",$chrom,'chromosome','Component',1,$CHROMOSOMES{$chrom},'.','.','.',qq(Sequence "$chrom")),"\n";
+}
+
+# this is hard because the SGD idea of a feature doesn't really map onto the GFF idea.
+while (<>) {
+  chomp;
+  my($id,$gene,$aliases,$type,$chromosome,$start,$stop,$strand,$sgdid,$sgdid2,$description,$date) = split "\t";
+  my $ref = $ROMAN[$chromosome-1];
+  $description =~ s/"/\\"/g;
+  $description =~ s/;/\\;/g;
+
+  $strand = $strand eq 'W' ? '+' : '-';
+  ($start,$stop) = ($stop,$start) if $strand eq '-';
+  die "Strand logic is messed up" if $stop < $start;
+
+  if ($gene) {
+     my @aliases = split(/\|/,$aliases);
+     my $aliases = join " ; ",map {qq(Alias "$_")} @aliases;
+     my $group = qq(Gene "$gene" ; Note "$description");
+     $group .= " ; $aliases" if $aliases;
+     print join("\t",$ref,'sgd','gene',$start,$stop,'.',$strand,'.',$group),"\n";
+     $description .= "\\; AKA @aliases" if @aliases;
+  }
+
+  print join("\t",$ref,'sgd',$type,$start,$stop,'.',$strand,'.',qq($type "$id" ; Note "$description")),"\n";
+}
+
+__END__
+
+=head1 NAME
+
+process_sgd.pl - Massage SGD annotation flat files into a version suitable for the Generic Genome Browser
+
+=head1 SYNOPSIS
+
+  % process_sgd.pl chromosomal_features.tab > yeast.gff
+
+=head1 DESCRIPTION
+
+This script massages the SGD sequence annotation flat files located at
+ftp://genome-ftp.stanford.edu/pub/yeast/data_dump/feature/chromosomal_features.tab
+into a version of the GFF format suitable for display by the generic
+genome browser.
+
+To use this script, get the SGD chromosomal_features.tab file from the
+FTP site listed above, and run the following command:
+
+  % process_sgd.pl chromosomal_features.tab > yeast.gff
+
+The yeast.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d <databasename> yeast.gff
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>, L<bulk_load_gff.pl>, L<load_gff.pl>
+
+=head1 AUTHOR
+
+Lincoln Stein <lstein@cshl.org>.
+
+Copyright (c) 2002 Cold Spring Harbor Laboratory
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.  See DISCLAIMER.txt for
+disclaimers of warranty.
+
+=cut
+
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/process_wormbase.pl bioperl-1.1/scripts/Bio-DB-GFF/process_wormbase.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/process_wormbase.pl	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/scripts/Bio-DB-GFF/process_wormbase.pl	Fri Sep 27 11:59:49 2002
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+use strict;
+use Ace;
+
+my $db = Ace->connect(-host=>'www.wormbase.org',
+		      -port=>2007) or die "Can't open ace database:",Ace->error;
+
+my @framework = qw(mex-3 spe-15 lin-17 unc-11 dhc-1 unc-40 smg-5
+		   unc-13 unc-29 eat-16 lin-11 spe-9 par-6 unc-59 unc-54 mab-9 lin-42
+		   sri-71 smu-2 vab-1 bli-2 dpy-10 him-14 mig-5 unc-4 bli-1 sqt-1 rol-1
+		   his-14 unc-52 unc-45 par-2 let-805 sel-8 mab-21 daf-4 sma-3 lin-39
+		   unc-32 tax-4 ced-9 tra-1 nob-1 daf-1 ced-2 lin-1 unc-17 dpy-13 unc-5
+		   smg-7 dif-1 lin-49 elt-1 daf-14 dpy-20 dpy-26 unc-30 tra-3 sup-24
+		   rho-1 egl-8 unc-60 srh-36 apx-1 unc-62 let-418 dpy-11 let-413 sel-9
+		   unc-42 egl-9 sma-1 sqt-3 odr-3 hda-1 unc-76 gcy-20 skr-5 par-4 unc-51
+		   egl-17 lim-6 fox-1 fax-1 lon-2 unc-97 unc-6 unc-18 mec-10 sop-1 mab-18
+		   sdc-2 odr-7 unc-9 unc-3 gas-1 ace-1);
+my %framework = map {$_=>1} @framework;
+my %framework_seen = ();
+
+my $USAGE = <<USAGE;
+This script massages the Wormbase GFF files located at
+ftp://www.wormbase.org/pub/wormbase/GENE_DUMPS into a version of the
+GFF format suitable for display by the generic genome browser.  It
+mainly adds comments to the annotations and designates certain
+well-spaced genetic loci as framework landmarks.
+
+This script requires the AcePerl distribution, which is available on
+CPAN (look for the "Ace" module).
+
+To use this script, get the WormBase GFF files from the FTP site
+listed above and place them in a directory.  It might be a good idea
+to name the directory after the current release, such as WS61.  You do
+not need to uncompress the files.
+
+Then give that directory as the argument to this script and capture
+the script's output to a file:
+
+  % process_wormbase.pl ./WS61 > wormbase.gff
+
+It may take a while before you see output from this script, since it
+must first fetch gene and protein database from the remote AceDB
+running at www.wormbase.org.
+The wormbase.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d <databasename> wormbase.gff
+USAGE
+;
+#'
+
+die $USAGE if $ARGV[0]=~/^-?-h/i;
+
+if (-d $ARGV[0]) {
+  @ARGV = <$ARGV[0]/*.gff.gz>;
+}
+
+@ARGV || die $USAGE;
+
+foreach (@ARGV) { # GFF FILES
+  $_ = "gunzip -c $_ |" if /\.gz$/;
+}
+
+my (%NOTES,%LOCUS,%GENBANK);
+get_genbank($db,\%GENBANK);
+get_loci($db,\%LOCUS);
+get_notes($db,\%NOTES);
+#parse_notes(SEQUENCE2LOCUS,\%LOCUS);
+#parse_notes(SEQUENCE2BRIEFID,\%NOTES);
+
+while (<>) {
+  chomp;
+  next if /^\#/;
+  my ($ref,$source,$method,$start,$stop,$score,$strand,$phase,$group) = split /\t/;
+  next if $source eq 'assembly_tag';  # don't want 'em, don't need 'em
+  $ref    =~ s/^CHROMOSOME_//;
+  $group  =~ s/CHROMOSOME_//;
+
+  if ($method eq 'Sequence' && ($source eq 'curated' || $source eq 'RNA') && $group =~ /Sequence "(\w+\.\d+[a-z]?)"/) {
+    my @notes;
+    push @notes,map { qq(Note "$_") } @{$NOTES{$1}} if $NOTES{$1};
+    push @notes,map { qq(Note "$_") } @{$LOCUS{$1}} if $LOCUS{$1};
+    $group = join ' ; ',$group,@notes;
+    if (my $loci = $LOCUS{$1}) {
+      foreach (@$loci) {
+	print join("\t",$ref,$source,'gene',$start,$stop,$score,$strand,$phase,"Locus $_"),"\n";
+	print join("\t",$ref,'framework','gene',$start,$stop,$score,$strand,$phase,"Locus $_"),"\n" 
+	  if $framework{$_} && !$framework_seen{$_}++;
+      }
+    }
+  }
+
+  if ($method eq 'Sequence' && $source eq 'Genomic_canonical' && $group =~ /Sequence "(\w+)"/) {
+    if (my $accession = $GENBANK{$1}) {
+      $group .= qq( ; Note "Genbank $accession");
+      print join("\t",$ref,'Genbank',$method,$start,$stop,$score,$strand,$phase,"Genbank \"$accession\""),"\n";
+    }
+  }
+
+  # fix variant fields: Variant "T" => Note "T"
+  $group =~ s/(?:Variant|Insert) "(\w+)"/Note "$1"/;
+
+  print join("\t",$ref,$source,$method,$start,$stop,$score,$strand,$phase,$group),"\n";
+}
+
+sub get_loci {
+  my ($db,$hash) = @_;  # hash keys are predicted gene names, values are one or more loci names
+  my @genes = $db->fetch(-query=>'find Locus Genomic_sequence',-filltag=>'Genomic_sequence');
+  foreach my $obj (@genes) {
+    my @genomic = $obj->Genomic_sequence or next;
+    foreach (@genomic) {
+      push @{$hash->{$_}},$obj;
+    }
+  }
+}
+
+sub get_notes {
+  my ($db,$hash) = @_;  # hash keys are predicted gene names, values are one or more brief identifications
+  my @genes = $db->fetch(-query=>'find Sequence Brief_identification',-filltag=>'Brief_identification');
+  foreach my $obj (@genes) {
+    my @notes = $obj->Brief_identification or next;
+    $hash->{$obj} = \@notes;
+  }
+}
+
+sub get_genbank {
+  my ($db,$hash) = @_;   # hash keys are cosmid names, values are genbank accessions (1 to 1)
+  my @cosmids = $db->fetch(-query=>'find Genome_Sequence Database',-filltag=>'Database');
+  for my $cosmid (@cosmids) {
+    my ($database,undef,$accession) = $cosmid->Database(1)->row;
+    next unless $accession;
+    $hash->{$cosmid} = $accession;
+  }
+}
+
+sub parse_notes {
+  my ($file,$notes) = @_;
+  my $s;
+  open S,$file or die "$file: $!\n";
+  while (<S>) {
+    chomp;
+    if (/Sequence : "(\S+)"/) {
+      $s = $1;
+      next;
+    }
+    if (/^\w+\s+"(.+?)"$/) {
+      my $id = $1;
+      $id =~ s/\\//g;
+      next unless $s;
+      push @{$notes->{$s}},$id;
+    }
+  }
+  close S;
+}
+
+__END__
+
+=head1 NAME
+
+process_wormbase.pl - Massage WormBase GFF files into a version suitable for the Generic Genome Browser
+
+=head1 SYNOPSIS
+
+  % process_wormbase.pl ./WS61 > wormbase.gff
+
+=head1 DESCRIPTION
+
+This script massages the Wormbase GFF files located at
+ftp://www.wormbase.org/pub/wormbase/GENE_DUMPS into a version of the
+GFF format suitable for display by the generic genome browser.  It
+mainly adds comments to the annotations and designates certain
+well-spaced genetic loci as framework landmarks.
+
+This script requires the AcePerl distribution, which is available on
+CPAN (look for the "Ace" module).
+
+To use this script, get the WormBase GFF files from the FTP site
+listed above and place them in a directory.  It might be a good idea
+to name the directory after the current release, such as WS61.  You do
+not need to uncompress the files.
+
+Then give that directory as the argument to this script and capture
+the script's output to a file:
+
+  % process_wormbase.pl ./WS61 > wormbase.gff
+
+It may take a while before you see output from this script, since it
+must first fetch gene and protein database from the remote AceDB
+running at www.wormbase.org.
+The wormbase.gff file can then be loaded into a Bio::DB::GFF database
+using the following command:
+
+  % bulk_load_gff.pl -d <databasename> wormbase.gff
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>, L<bulk_load_gff.pl>, L<load_gff.pl>
+
+=head1 AUTHOR
+
+Lincoln Stein <lstein@cshl.org>.
+
+Copyright (c) 2002 Cold Spring Harbor Laboratory
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.  See DISCLAIMER.txt for
+disclaimers of warranty.
+
+=cut
+
+
diff -Naur bioperl-1.0.2/scripts/Bio-DB-GFF/sgd_to_gff.pl bioperl-1.1/scripts/Bio-DB-GFF/sgd_to_gff.pl
--- bioperl-1.0.2/scripts/Bio-DB-GFF/sgd_to_gff.pl	Mon Jan 21 08:53:32 2002
+++ bioperl-1.1/scripts/Bio-DB-GFF/sgd_to_gff.pl	Wed Dec 31 19:00:00 1969
@@ -1,117 +0,0 @@
-#!/usr/bin/perl
-
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
-# This script will convert from SGD format to GFF format
-# See http://genome-www4.stanford.edu/Saccharomyces/SGD/doc/db_specifications.html
-
-=head1 NAME
-
-sgd_to_gff.pl - Massage SGD's feature dump format into a form suitable for Bio::DB::GFF
-
-=head2 SYNOPSIS
-
-   perl sgd_to_gff.pl chromosomal_features.tab > sgd.gff
-
-=head2 DESCRIPTION
-
-This script massages the SGD yeast sequence feature file located at
-ftp://genome-ftp.stanford.edu/pub/yeast/data_dump/feature/chromosomal_feature.tab
-into a GFF format suitable for use with Bio::DB::GFF.  This lets you
-view the yeast annotations with the generic genome browser
-(http://www.gmod.org).
-
-To use this script, get the SGD features file at the above URL.  Then
-run this command:
-
-  sgd_to_gff.pl chromosomal_feature.tab > sgd.gff
-
-The resulting database will have the following feature types
-(represented as "method:source"):
-
-  Component:chromosome       A chromosome
-  gene:sgd                   A named gene
-  rRNA:sgd		     A ribosomal RNA
-  ARS:sgd		     An origin of replication
-  CEN:sgd		     Centromere
-  snRNA:sgd		     Small nuclear RNA
-  RNA:sgd		     An RNA gene
-  ORF:sgd		     An open reading frame
-  ORF|Pseudogene:sgd	     A probably pseudogene
-  LTR:sgd		     A long terminal repeat
-  Ty ORF:sgd		     ??
-  Transposon:sgd	     A transposon
-  Pseudogene|Ty ORF:sgd	     ??
-  snoRNA:sgd		     Small nucleolar RNA
-  tRNA:sgd		     Transfer RNA
-
-=head2 AUTHOR
-
-Lincoln Stein E<lt>lstein@cshl.orgE<gt>
-
-=cut
-
-use strict;
-
-# hard-coded length data that I couldn't get directly
-my %CHROMOSOMES = (I => 230_203,
-		   II => 813_139,
-		   III => 316_613,
-		   IV  => 1_531_929,
-		   V   => 576_869,
-		   VI => 270_148,
-		   VII => 1_090_937,
-		   VIII => 562_639,
-		   IX => 439_885,
-		   X => 745_444,
-		   XI => 666_445,
-		   XII => 1_078_173,
-		   XIII => 924_430,
-		   XIV => 784_328,
-		   XV  => 1_091_284,
-		   XVI => 948_061,
-		   Mit => 85_779);
-my @ROMAN = qw(I II III IV V VI VII VIII IX X
-	       XI XII XIII XIV XV XVI Mit);
-
-if ($ARGV[0] =~ /^--?h/) {
-  die <<USAGE;
- Usage: $0 <SGD features file>
-
-Converts "chromosomal_features.tab" file from SGD into a GFF file
-suitable for loading into Bio::DB::GFF.  You can get this file at
-ftp://genome-ftp.stanford.edu/pub/yeast/data_dump/feature/chromosomal_feature.tab
-
-The output of running this script is suitable for loading using
-load_gff.pl or bulk_load_gff.pl.
-USAGE
-;
-}
-
-# first print out chromosomes
-# We hard coded the lengths because they are not available in the features table.
-for my $chrom (sort keys %CHROMOSOMES) {
-  print join("\t",$chrom,'chromosome','Component',1,$CHROMOSOMES{$chrom},'.','.','.',qq(Sequence "$chrom")),"\n";
-}
-
-# this is hard because the SGD idea of a feature doesn't really map onto the GFF idea.
-while (<>) {
-  chomp;
-  my($id,$gene,$aliases,$type,$chromosome,$start,$stop,$strand,$sgdid,$sgdid2,$description,$date) = split "\t";
-  my $ref = $ROMAN[$chromosome-1];
-  $description =~ s/"/\\"/g;
-  $description =~ s/;/\\;/g;
-
-  $strand = $strand eq 'W' ? '+' : '-';
-  ($start,$stop) = ($stop,$start) if $strand eq '-';
-  die "Strand logic is messed up" if $stop < $start;
-
-  if ($gene) {
-    my @genes = ($gene,split/\|/,$aliases);
-    foreach (@genes) {
-      print join("\t",$ref,'sgd','gene',$start,$stop,'.',$strand,'.',qq(Gene "$_" ; Note "$description")),"\n";
-    }
-    $description = "$gene\\; $description";
-  }
-
-  print join("\t",$ref,'sgd',$type,$start,$stop,'.',$strand,'.',qq($type "$id" ; Note "$description")),"\n";
-}
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/iterator.pm bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/iterator.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/iterator.pm	Mon Nov  5 08:19:04 2001
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/iterator.pm	Thu Sep 26 21:36:49 2002
@@ -1,3 +1,38 @@
+=head1 NAME
+
+Bio::DB::GFF::Adaptor::dbi::iterator - iterator for Bio::DB::GFF::Adaptor::dbi
+
+=head1 SYNOPSIS
+
+For internal use only
+
+=head1 DESCRIPTION
+
+This is an internal module that is used by the Bio::DB::GFF DBI
+adaptor to return an iterator across a sequence feature query.  The
+object has a single method, next_feature(), that returns the next
+feature from the query.  The method next_seq() is an alias for
+next_feature().
+
+=head1 BUGS
+
+None known yet.
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>,
+
+=head1 AUTHOR
+
+Lincoln Stein E<lt>lstein@cshl.orgE<gt>.
+
+Copyright (c) 2001 Cold Spring Harbor Laboratory.
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.
+
+=cut
+
 package Bio::DB::GFF::Adaptor::dbi::iterator;
 use strict;
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/mysql.pm bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/mysql.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/mysql.pm	Wed Jul 10 23:45:51 2002
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/mysql.pm	Tue Sep  3 15:51:06 2002
@@ -16,7 +16,7 @@
 use Bio::DB::GFF::Util::Rearrange; # for rearrange()
 use vars qw($VERSION @ISA);
 @ISA = qw(Bio::DB::GFF::Adaptor::dbi);
-$VERSION = '0.50';
+$VERSION = '0.80';
 
 use constant MAX_SEGMENT => 100_000_000;  # the largest a segment can get
 use constant DEFAULT_CHUNK => 2000;
@@ -370,8 +370,8 @@
   my $self = shift;
   my ($name,$class,$refseq) = @_;
   my $query = GETSEQCOORDS;
-  if ($name =~ /\*/) {
-    $name =~ tr/*/%/;
+  if ($name =~ s/(?<!\\)([*?])/$1 eq '*' ? '%' : '_'/ge) {
+    $name =~ tr/\\//d;
     $query =~ s/gname=\?/gname LIKE ?/;
   }
   defined $refseq ? $self->dbh->do_query(GETFORCEDSEQCOORDS,$name,$class,$refseq) 
@@ -384,23 +384,30 @@
   my ($name,$class,$refseq)  = @_;
 
   my $result = $self->SUPER::get_abscoords(@_);
-  return $result if $result;
 
+  # Return the result if we got a non-empty response
+  # AND no wildcard match was requested.  Otherwise we do
+  # an alias search.
+  return $result if $result && $name !~ /(?<!\\)[*?]/;
+  $result ||= [];
+
+  # handle aliases
   my $sth;
-  if ($name =~ s/\*/%/g) {
+  if ($name =~ s/(?<!\\)([*?])/$1 eq '*' ? '%' : '_'/ge) {
+    $name =~ tr/\\//d;
     $sth = $self->dbh->do_query(GETALIASLIKE,$name,$class);
   } else {
     $sth = $self->dbh->do_query(GETALIASCOORDS,$name,$class);
   }
-  my @result;
-  while (my @row = $sth->fetchrow_array) { push @result,\@row }
+
+  while (my @row = $sth->fetchrow_array) { push @$result,\@row }
   $sth->finish;
 
-  if (@result == 0) {
+  if (@$result == 0) {
     $self->error("$name not found in database");
     return;
   } else {
-    return \@result;
+    return $result;
   }
 
 }
@@ -419,14 +426,36 @@
 sub make_features_by_name_where_part {
   my $self = shift;
   my ($class,$name) = @_;
-  if ($name =~ /\*/) {
-    $name =~ s/\*/%/g;
+  if ($name =~ /[*?]/) {
+    $name =~ tr/*?/%_/;
     return ("fgroup.gclass=? AND fgroup.gname LIKE ?",$class,$name);
   } else {
     return ("fgroup.gclass=? AND fgroup.gname=?",$class,$name);
   }
 }
 
+=head2 make_features_by_alias_where_part
+
+ Title   : make_features_by_alias_where_part
+ Usage   : $db->make_features_by_alias_where_part
+ Function: create the SQL fragment needed to select a feature by its alias & group class
+ Returns : a SQL fragment and bind arguments
+ Args    : see below
+ Status  : Protected
+
+=cut
+
+sub make_features_by_alias_where_part {
+  my $self = shift;
+  my ($class,$name) = @_;
+  if ($name =~ /[*?]/) {
+    $name =~ tr/*?/%_/;
+    return ("fgroup.gclass=? AND fattribute_to_feature.fattribute_value LIKE ?",$class,$name);
+  } else {
+    return ("fgroup.gclass=? AND  fattribute_to_feature.fattribute_value=?",$class,$name);
+  }
+}
+
 sub make_features_by_attribute_where_part {
   my $self = shift;
   my $attributes = shift;
@@ -492,9 +521,26 @@
 sub make_features_select_part {
   my $self = shift;
   my $options = shift || {};
-  my $s = <<END;
+  my $s;
+  if (my $b = $options->{bin_width}) {
+
+    $s = <<END;
+fref,
+  1+$b*floor(fstart/$b)   as fstart,
+  $b*(1+floor(fstart/$b)) as fstop,
+  IF(ISNULL(fsource),fmethod,concat(fmethod,':',fsource)),'bin',
+  count(*) as fscore,
+  '.','.','bin',
+  IF(ISNULL(fsource),concat(fref,':',fmethod),concat(fref,':',fmethod,':',fsource)),
+  NULL,NULL,NULL,NULL
+END
+;
+  } else {
+    $s = <<END;
 fref,fstart,fstop,fsource,fmethod,fscore,fstrand,fphase,gclass,gname,ftarget_start,ftarget_stop,fdata.fid,fdata.gid
 END
+;
+}
   $s .= ",count(fdata.fid)" if $options->{attributes} && keys %{$options->{attributes}}>1;
   $s;
 }
@@ -548,6 +594,34 @@
 END2
 }
 
+=head2 make_features_by_alias_join_part
+
+ Title   : make_features_by_alias_join_part
+ Usage   : $string = $db->make_features_by_alias_join_part()
+ Function: make join part of the features query
+ Returns : a string
+ Args    : none
+ Status  : Abstract
+
+This abstract method creates the part of the features query that
+immediately follows the WHERE keyword.  It is combined with the output
+of make_feautres_where_part() to form the full WHERE clause.  If you
+do not need to join, return "1".
+
+=cut
+
+sub make_features_by_alias_join_part {
+  my $self = shift;
+  return <<END;
+  fgroup.gid = fdata.gid
+  AND fattribute.fattribute_name='Alias'
+  AND fattribute_to_feature.fattribute_id=fattribute.fattribute_id
+  AND fattribute_to_feature.fid=fdata.fid
+  AND ftype.ftypeid = fdata.ftypeid
+END
+}
+
+
 =head2 make_features_order_by_part
 
  Title   : make_features_order_by_part
@@ -587,13 +661,17 @@
 sub make_features_group_by_part {
   my $self = shift;
   my $options = shift || {};
-  my $att = $options->{attributes} or return;
-  my $key_count = keys %$att;
-  return unless $key_count > 1;
-  return ("fdata.fid,fref,fstart,fstop,fsource,
+  if (my $att = $options->{attributes}) {
+    my $key_count = keys %$att;
+    return unless $key_count > 1;
+    return ("fdata.fid,fref,fstart,fstop,fsource,
            fmethod,fscore,fstrand,fphase,gclass,gname,ftarget_start,
-           ftarget_stop,fdata.gid 
+           ftarget_stop,fdata.gid
      HAVING count(fdata.fid) > ?",$key_count-1);
+  }
+  elsif (my $b = $options->{bin_width}) {
+    return "fref,fstart,fdata.ftypeid";
+  }
 }
 
 =head2 refseq_query
@@ -1029,7 +1107,7 @@
  Status  : protected
 
 This method lists the tables known to the module, namely qw(fdata fref
-fgroup ftype fdna fnote fmeta).
+fgroup ftype fdna fattribute fattribute_to_feature fmeta).
 
 =cut
 
@@ -1063,7 +1141,7 @@
     fstop        int unsigned   not null,
     ftypeid      int not null,
     fscore        float,
-    fstrand       enum('+','-'),
+    fstrand       enum('+','-','.'),
     fphase        enum('0','1','2'),
     gid          int not null,
     ftarget_start int unsigned,
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/mysqlopt.pm bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/mysqlopt.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi/mysqlopt.pm	Thu Feb 21 18:20:01 2002
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/dbi/mysqlopt.pm	Wed Aug 28 10:26:52 2002
@@ -85,7 +85,7 @@
 
 use vars qw($VERSION @ISA);
 @ISA = qw(Bio::DB::GFF::Adaptor::dbi::mysql);
-$VERSION = 0.80;
+$VERSION = 0.85;
 
 # this is the largest that any reference sequence can be (100 megabases)
 use constant MAX_BIN    => 100_000_000;
@@ -294,7 +294,7 @@
     # then generate a bogus Homology object (for future compatability??)
     if ($start ne '') {
       require Ace::Sequence::Homol;
-      return Ace::Sequence::Homol->new($class,$name,$db,$start,$stop);
+      return Ace::Sequence::Homol->new_homol($class,$name,$db,$start,$stop);
     }
 
     # General case:
@@ -313,8 +313,8 @@
 # WHETHER OR NOT THIS WORKS IS CRITICALLY DEPENDENT ON THE RELATIVE MAGNITUDE OF THE
 sub make_features_from_part {
   my $self = shift;
-  my $sparse = shift;
   my $options = shift || {};
+  my $sparse = shift;
   my $index = $sparse ? ' USE INDEX(ftypeid)': '';
   return $options->{attributes} ? "fdata${index},ftype,fgroup,fattribute,fattribute_to_feature\n"
                                 : "fdata${index},ftype,fgroup\n";
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi.pm bioperl-1.1/Bio/DB/GFF/Adaptor/dbi.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/dbi.pm	Sat Mar 23 14:05:32 2002
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/dbi.pm	Wed Aug 28 10:26:51 2002
@@ -69,8 +69,10 @@
   if (!ref($features_db)) {
     my $dsn = $features_db;
     my @args;
-    push @args,$username if defined $username;
-    push @args,$auth     if defined $auth;
+    if (defined $username or defined $auth) {
+      push @args,$username;
+      push @args,$auth;
+    }
     $features_db = Bio::DB::GFF::Adaptor::dbi::caching_handle->new($dsn,@args)
       || $class->throw("new(): Failed to connect to $dsn: "
 		       . Bio::DB::GFF::Adaptor::dbi::caching_handle->errstr);
@@ -227,7 +229,8 @@
 			       @{$options}{qw(
 					      sparse
 					      sort_by_group
-					      ATTRIBUTES)}) or return;
+					      ATTRIBUTES
+					      BINSIZE)}) or return;
 
   my $count = 0;
   while (my @row = $sth->fetchrow_array) {
@@ -324,6 +327,46 @@
   return $count;
 }
 
+=head2 _feature_by_alias
+
+ Title   : _feature_by_alias
+ Usage   : $db->get_features_by_alias($name,$class,$callback)
+ Function: get a list of features by name and class
+ Returns : count of number of features retrieved
+ Args    : name of feature, class of feature, and a callback
+ Status  : protected
+
+This method is used internally.  The callback arguments are those used
+by make_feature().  Internally, it invokes the following abstract procedures:
+
+ make_features_select_part
+ make_features_from_part
+ make_features_by_name_where_part
+ make_features_join_part
+
+=cut
+
+sub _feature_by_alias {
+  my $self = shift;
+  my ($class,$name,$callback) = @_;
+  $callback || $self->throw('must provide a callback argument');
+
+  my $select         = $self->make_features_select_part;
+  my $from           = $self->make_features_from_part({attributes=>1});
+  my ($where,@args)  = $self->make_features_by_alias_where_part($class,$name);
+  my $join           = $self->make_features_by_alias_join_part;
+  my $query  = "SELECT $select FROM $from WHERE $where AND $join";
+  my $sth    = $self->dbh->do_query($query,@args);
+
+  my $count = 0;
+  while (my @row = $sth->fetchrow_array) {
+    $callback->(@row);
+    $count++;
+  }
+  $sth->finish;
+  return $count;
+}
+
 =head2 _feature_by_id
 
  Title   : _feature_by_id
@@ -373,7 +416,7 @@
   $callback || $self->throw('must provide a callback argument');
 
   my $select         = $self->make_features_select_part;
-  my $from           = $self->make_features_from_part(undef,{attributes=>$attributes});
+  my $from           = $self->make_features_from_part({attributes=>$attributes},undef);
   my ($where,@args)  = $self->make_features_by_range_where_part('',{attributes=>$attributes});
   my $join           = $self->make_features_join_part({attributes=>$attributes});
   my $query          = "SELECT $select FROM $from WHERE $where AND $join";
@@ -455,7 +498,7 @@
 =head2 range_query
 
  Title   : range_query
- Usage   : $db->range_query($range_type,$refseq,$refclass,$start,$stop,$types,$order_by_group)
+ Usage   : $db->range_query($range_type,$refseq,$refclass,$start,$stop,$types,$order_by_group,$attributes,$binsize)
  Function: create statement handle for range/overlap queries
  Returns : a DBI statement handle
  Args    : see below
@@ -465,7 +508,7 @@
 query: given a range and/or a list of feature types, fetch their GFF
 records.
 
-The six positional arguments are as follows:
+The positional arguments are as follows:
 
   Argument               Description
 
@@ -487,6 +530,10 @@
   $order_by_group        A flag indicating that statement handler should group
                          the features by group id (handy for iterative fetches)
 
+  $attributes            A hash containing select attributes.
+
+  $binsize               A bin size for generating tables of feature density.
+
 If successful, this method returns a statement handle.  The handle is
 expected to return the fields described for get_features().
 
@@ -514,15 +561,15 @@
 
 sub range_query {
   my $self = shift;
-  my($rangetype,$refseq,$class,$start,$stop,$types,$sparse,$order_by_group,$attributes) = @_;
+  my($rangetype,$refseq,$class,$start,$stop,$types,$sparse,$order_by_group,$attributes,$bin) = @_;
 
   my $dbh = $self->features_db;
 
   # NOTE: straight_join is necessary in some database to force the right index to be used.
-  my %a             = (refseq=>$refseq,class=>$class,start=>$start,stop=>$stop,types=>$types,attributes=>$attributes);
+  my %a             = (refseq=>$refseq,class=>$class,start=>$start,stop=>$stop,types=>$types,attributes=>$attributes,bin_width=>$bin);
   my $straight      = $self->do_straight_join(\%a) ? 'straight_join' : '';
   my $select        = $self->make_features_select_part(\%a);
-  my $from          = $self->make_features_from_part($sparse,\%a);
+  my $from          = $self->make_features_from_part(\%a,$sparse);
   my $join          = $self->make_features_join_part(\%a);
   my ($where,@args) = $self->make_features_by_range_where_part($rangetype,\%a);
   my ($group_by,@more_args) = $self->make_features_group_by_part(\%a);
@@ -814,7 +861,8 @@
 			       @{$options}{qw(
 					      sparse
 					      sort_by_group
-					      ATTRIBUTES)}) or return;
+					      ATTRIBUTES
+					      BINSIZE)}) or return;
   return Bio::DB::GFF::Adaptor::dbi::iterator->new($sth,$callback);
 }
 
@@ -902,11 +950,14 @@
 
 =head2 make_features_from_part
 
- Title   : make_features_from_part
+ Title   : make_features_from_part($atributes,$sparse)
  Usage   : $string = $db->make_features_from_part()
  Function: make from part of the features query
  Returns : a string
- Args    : none
+ Args    : $attributes is a hash containing attributes to match
+           (see get_by_attribute), and $sparse is a flag indicating
+           that there are relatively few of this type of feature
+           in the data table.
  Status  : Abstract
 
 This abstract method creates the part of the features query that
@@ -938,6 +989,26 @@
   shift->throw("make_features_join_part(): must be implemented by subclass");
 }
 
+=head2 make_features_by_alias_join_part
+
+ Title   : make_features_by_alias_join_part
+ Usage   : $string = $db->make_features_by_alias_join_part()
+ Function: make join part of the features query
+ Returns : a string
+ Args    : none
+ Status  : Abstract
+
+This abstract method creates the part of the features query that
+immediately follows the WHERE keyword.  It is combined with the output
+of make_feautres_where_part() to form the full WHERE clause.  If you
+do not need to join, return "1".
+
+=cut
+
+sub make_features_by_alias_join_part {
+  shift->throw("make_features_by_alias_join_part(): must be implemented by subclass");
+}
+
 =head2 make_features_order_by_part
 
  Title   : make_features_order_by_part
@@ -975,6 +1046,24 @@
   my ($class,$name) = @_;
   shift->throw('make_features_by_name_where_part(): must be implemented by subclass');
 }
+
+=head2 make_features_by_alias_where_part
+
+ Title   : make_features_by_alias_where_part
+ Usage   : $db->make_features_by_alias_where_part
+ Function: create the SQL fragment needed to select a feature by its alias & group class
+ Returns : a SQL fragment and bind arguments
+ Args    : see below
+ Status  : Protected
+
+=cut
+
+sub make_features_by_alias_where_part {
+  my $self = shift;
+  my ($class,$name) = @_;
+  shift->throw('make_features_by_name_where_part(): must be implemented by subclass');
+}
+
 
 =head2 make_features_by_id_where_part
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/memory.pm bioperl-1.1/Bio/DB/GFF/Adaptor/memory.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/memory.pm	Wed Jul 10 23:02:16 2002
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/memory.pm	Wed Jul 10 23:02:03 2002
@@ -1,6 +1,6 @@
 package Bio::DB::GFF::Adaptor::memory;
 use strict;
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 # AUTHOR: Shulamit Avraham
 # This module needs to be cleaned up and documented
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Adaptor/memory_iterator.pm bioperl-1.1/Bio/DB/GFF/Adaptor/memory_iterator.pm
--- bioperl-1.0.2/Bio/DB/GFF/Adaptor/memory_iterator.pm	Wed Jun 19 17:57:27 2002
+++ bioperl-1.1/Bio/DB/GFF/Adaptor/memory_iterator.pm	Thu Sep 26 21:36:48 2002
@@ -1,6 +1,41 @@
+=head1 NAME
+
+Bio::DB::GFF::Adaptor::memory_iterator - iterator for Bio::DB::GFF::Adaptor::memory
+
+=head1 SYNOPSIS
+
+For internal use only
+
+=head1 DESCRIPTION
+
+This is an internal module that is used by the Bio::DB::GFF in-memory
+adaptor to return an iterator across a sequence feature query.  The
+object has a single method, next_feature(), that returns the next
+feature from the query.  The method next_seq() is an alias for
+next_feature().
+
+=head1 BUGS
+
+None known yet.
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>,
+
+=head1 AUTHOR
+
+Lincoln Stein E<lt>lstein@cshl.orgE<gt>.
+
+Copyright (c) 2001 Cold Spring Harbor Laboratory.
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.
+
+=cut
+
 package Bio::DB::GFF::Adaptor::memory_iterator;
 use strict;
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 # this module needs to be cleaned up and documented
 
 #use constant STH         => 0;
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Aggregator/alignment.pm bioperl-1.1/Bio/DB/GFF/Aggregator/alignment.pm
--- bioperl-1.0.2/Bio/DB/GFF/Aggregator/alignment.pm	Fri Apr 12 07:56:25 2002
+++ bioperl-1.1/Bio/DB/GFF/Aggregator/alignment.pm	Fri Aug  2 18:51:01 2002
@@ -12,6 +12,11 @@
 				   -aggregator => ['alignment'],
 				 );
 
+ -----------------------------
+ Aggregator method: alignment
+ Main method:       -none-
+ Sub methods:       similarity
+ -----------------------------
 
 =head1 DESCRIPTION
 
@@ -59,7 +64,7 @@
 
   my (%alignments,%targets,@result);
 
-  warn "running aligner aggregator" if $factory->debug;
+  warn "running alignment aggregator" if $factory->debug;
   for my $feature (@$features) {
 
     if ($matchsub->($feature)) {
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Aggregator/clone.pm bioperl-1.1/Bio/DB/GFF/Aggregator/clone.pm
--- bioperl-1.0.2/Bio/DB/GFF/Aggregator/clone.pm	Wed Jan 30 11:02:50 2002
+++ bioperl-1.1/Bio/DB/GFF/Aggregator/clone.pm	Tue Jul 23 18:07:22 2002
@@ -12,6 +12,11 @@
 				   -aggregator => ['transcript','clone'],
 				 );
 
+ ----------------------------------------------------------------------------
+ Aggregator method: clone
+ Main method:       -none-
+ Sub methods:       Clone_left_end Clone_right_end Sequence:Genomic_canonical
+ ----------------------------------------------------------------------------
 
 =head1 DESCRIPTION
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Aggregator/transcript.pm bioperl-1.1/Bio/DB/GFF/Aggregator/transcript.pm
--- bioperl-1.0.2/Bio/DB/GFF/Aggregator/transcript.pm	Sun Jan 27 13:42:34 2002
+++ bioperl-1.1/Bio/DB/GFF/Aggregator/transcript.pm	Tue Jul 23 18:07:22 2002
@@ -12,6 +12,11 @@
 				   -aggregator => ['transcript','clone'],
 				 );
 
+ -------------------------------------------------
+ Aggregator method: transcript
+ Main method:       transcript
+ Sub methods:       exon CDS 5'UTR 3'UTR TSS PolyA
+ -------------------------------------------------
 
 =head1 DESCRIPTION
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Aggregator.pm bioperl-1.1/Bio/DB/GFF/Aggregator.pm
--- bioperl-1.0.2/Bio/DB/GFF/Aggregator.pm	Fri Apr 12 07:56:25 2002
+++ bioperl-1.1/Bio/DB/GFF/Aggregator.pm	Tue Jul 23 18:07:21 2002
@@ -566,7 +566,11 @@
 
 =head1 SEE ALSO
 
-L<Bio::DB::GFF>
+L<Bio::DB::GFF>,
+L<Bio::DB::GFF::Aggregator::alignment>,
+L<Bio::DB::GFF::Aggregator::clone>,
+L<Bio::DB::GFF::Aggregator::transcript>,
+L<Bio::DB::GFF::Aggregator::none>
 
 =head1 AUTHOR
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Feature.pm bioperl-1.1/Bio/DB/GFF/Feature.pm
--- bioperl-1.0.2/Bio/DB/GFF/Feature.pm	Wed Jun 19 17:57:27 2002
+++ bioperl-1.1/Bio/DB/GFF/Feature.pm	Mon Sep 30 21:54:34 2002
@@ -77,7 +77,7 @@
 use vars qw($VERSION @ISA $AUTOLOAD);
 @ISA = qw(Bio::DB::GFF::RelSegment Bio::SeqFeatureI Bio::LocationI Bio::Root::Root);
 
-$VERSION = '0.60';
+$VERSION = '0.61';
 #' 
 
 *segments = \&sub_SeqFeature;
@@ -358,8 +358,6 @@
     return Bio::DB::GFF::RelSegment::_to_strand($self->{fstrand});
   }
   return $self->SUPER::strand;
-#  return 0 unless defined $self->{start};
-#  return $self->{start} < $self->{stop} ? '+1' : '-1';
 }
 
 =head2 group
@@ -383,6 +381,20 @@
   $d;
 }
 
+=head2 display_id
+
+ Title   : display_id
+ Usage   : $display_id = $f->display_id([$display_id])
+ Function: get or set the feature display id
+ Returns : a Bio::DB::GFF::Featname object
+ Args    : a new display_id (optional)
+ Status  : Public
+
+This method is an alias for group().  It is provided for
+Bio::SeqFeatureI compatibility.
+
+=cut
+
 =head2 info
 
  Title   : info
@@ -397,7 +409,8 @@
 
 =cut
 
-*info   = \&group;
+*info         = \&group;
+*display_id   = \&group;
 
 =head2 target
 
@@ -641,25 +654,34 @@
   my $truename = overload::StrVal($self);
 
   return @{$self->{merged_segs}{$type}} if exists $self->{merged_segs}{$type};
-  my @segs = sort {
-                $a->start <=> $b->start
-		  ||
-                $a->type cmp  $b->type
-		 } $self->sub_SeqFeature($type);
+  my @segs = map  { $_->[0] } 
+             sort { $a->[1] <=> $b->[1] ||
+		    $a->[2] cmp $b->[2] }
+             map  { [$_, $_->start, $_->type] } $self->sub_SeqFeature($type);
 
   # attempt to merge overlapping segments
   my @merged = ();
   for my $s (@segs) {
     my $previous = $merged[-1] if @merged;
-    if (defined($previous) && $previous->stop+1 >= $s->start){
-      $previous->{stop} = $s->{stop};
+    my ($pscore,$score) = (eval{$previous->score}||0,eval{$s->score}||0);
+    if (defined($previous) 
+	&& $previous->stop+1 >= $s->start
+	&& $previous->score == $s->score
+       ) {
+      if ($self->absolute && $self->strand < 0) {
+	$previous->{start} = $s->{start};
+      } else {
+	$previous->{stop} = $s->{stop};
+      }
       # fix up the target too
       my $g = $previous->{group};
       if ( ref($g) &&  $g->isa('Bio::DB::GFF::Homol')) {
 	my $cg = $s->{group};
 	$g->{stop} = $cg->{stop};
       }
-    } elsif (defined($previous) && $previous->start == $s->start && $previous->stop == $s->stop) {
+    } elsif (defined($previous) 
+	     && $previous->start == $s->start 
+	     && $previous->stop == $s->stop) {
       next;
     } else {
       my $copy = $s->clone;
@@ -916,8 +938,14 @@
   my $strand = $self->strand or return;
   my $subfeat = $self->{subfeatures} or return;
   for my $type (keys %$subfeat) {
-    $subfeat->{$type} = [sort {$a->start<=>$b->start} @{$subfeat->{$type}}] if $strand > 0;
-    $subfeat->{$type} = [sort {$b->start<=>$a->start} @{$subfeat->{$type}}] if $strand < 0;
+      $subfeat->{$type} = [map { $_->[0] }
+			   sort {$a->[1] <=> $b->[1] }
+			   map { [$_,$_->start] }
+			   @{$subfeat->{$type}}] if $strand > 0;
+      $subfeat->{$type} = [map { $_->[0] }
+			   sort {$b->[1] <=> $a->[1]}
+			   map { [$_,$_->start] }
+			   @{$subfeat->{$type}}] if $strand < 0;
   }
 }
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/RelSegment.pm bioperl-1.1/Bio/DB/GFF/RelSegment.pm
--- bioperl-1.0.2/Bio/DB/GFF/RelSegment.pm	Wed Jul 10 22:10:50 2002
+++ bioperl-1.1/Bio/DB/GFF/RelSegment.pm	Sun Sep  8 23:39:03 2002
@@ -63,12 +63,12 @@
 coordinates of this segment and maintains the source sequence and the
 absolute coordinates relative to the source sequence.  We can see this 
 information using sourceseq() (inherited from Bio::DB::GFF::Segment)
-and the abs_start() and abs_stop() methods:
+and the abs_start() and abs_end() methods:
 
   print $seg->sourceseq;
   => CHROMOSOME_I
 
-  print $seg->abs_start,' - ',$seg->abs_stop;
+  print $seg->abs_start,' - ',$seg->abs_end;
   => 14839545 - 14873326
 
 We can also put the segment into absolute mode, so that it behaves
@@ -350,8 +350,30 @@
 
 sub length {
   my $self = shift;
-  return unless defined $self->abs_stop;
-  abs($self->abs_stop - $self->abs_start) + 1;
+  return unless defined $self->abs_end;
+  abs($self->abs_end - $self->abs_start) + 1;
+}
+
+sub abs_start {
+  my $self = shift;
+  if ($self->absolute) {
+    my ($a,$b) = ($self->SUPER::abs_start,$self->SUPER::abs_end);
+    return ($a<$b) ? $a : $b;
+  }
+  else {
+    return $self->SUPER::abs_start(@_);
+  }
+}
+sub abs_end {
+  my $self = shift;
+  if ($self->absolute) {
+    my ($a,$b) = ($self->SUPER::abs_start,$self->SUPER::abs_end);
+    return ($a>$b) ? $a : $b;
+  }
+
+  else {
+    return $self->SUPER::abs_end(@_);
+  }
 }
 
 =head2 refseq
@@ -400,7 +422,7 @@
     my ($refsource,undef,$refstart,$refstop,$refstrand);
     if ($newref->isa('Bio::DB::GFF::RelSegment')) {
       ($refsource,undef,$refstart,$refstop,$refstrand) =
-	($newref->sourceseq,undef,$newref->abs_start,$newref->abs_stop,$newref->abs_strand >= 0 ? '+' : '-');
+	($newref->sourceseq,undef,$newref->abs_start,$newref->abs_end,$newref->abs_strand >= 0 ? '+' : '-');
     } else {
       my $coords = $self->factory->abscoords($newref,$newclass);
       foreach (@$coords) { # find the appropriate one
@@ -435,7 +457,7 @@
 
 sub abs_low {
   my $self = shift;
-  my ($a,$b) = ($self->abs_start,$self->abs_stop);
+  my ($a,$b) = ($self->abs_start,$self->abs_end);
   return ($a<$b) ? $a : $b;
 }
 
@@ -455,7 +477,7 @@
 
 sub abs_high {
   my $self = shift;
-  my ($a,$b) = ($self->abs_start,$self->abs_stop);
+  my ($a,$b) = ($self->abs_start,$self->abs_end);
   return ($a>$b) ? $a : $b;
 }
 
@@ -487,7 +509,7 @@
   if (ref($label) && overload::StrVal($self) eq overload::StrVal($label->ref)) {
     $label = $self->abs_ref;
     $start = $self->abs_start;
-    $stop  = $self->abs_stop;
+    $stop  = $self->abs_end;
   }
   return "$label:$start,$stop";
 }
@@ -566,6 +588,13 @@
 
   -iterator  Whether to return an iterator across the features.
 
+  -binsize   A true value will create a set of artificial features whose
+             start and stop positions indicate bins of the given size, and
+             whose scores are the number of features in the bin.  The
+             class and method of the feature will be set to "bin",
+             its source to "method:source", and its group to "bin:method:source".
+             This is a handy way of generating histograms of feature density.
+
 -merge is a boolean flag that controls whether the adaptor's
 aggregators wll be applied to the features returned by this method.
 
@@ -971,8 +1000,6 @@
   return +1 if $s eq '+';
   return 0;
 }
-
-sub primary_tag { "Segment" }
 
 =head2 Bio::RangeI Methods
 
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Segment.pm bioperl-1.1/Bio/DB/GFF/Segment.pm
--- bioperl-1.0.2/Bio/DB/GFF/Segment.pm	Wed Jun  5 05:50:51 2002
+++ bioperl-1.1/Bio/DB/GFF/Segment.pm	Sat Sep  7 10:39:42 2002
@@ -25,11 +25,12 @@
 use Bio::Root::Root;
 use Bio::Annotation::Collection;
 use Bio::RangeI;
+use Bio::Das::SegmentI;
 use Bio::SeqI;
 
 use vars qw($VERSION @ISA);
-@ISA = qw(Bio::Root::Root Bio::RangeI Bio::SeqI);
-$VERSION = '0.30';
+@ISA = qw(Bio::Root::Root Bio::RangeI Bio::SeqI Bio::Das::SegmentI);
+$VERSION = '0.31';
 
 use overload 
   '""'     => 'asString',
@@ -178,7 +179,7 @@
 
 sub strand {
   my $self = shift;
-  return $self->stop <=> $self->start;
+  0;
 }
 
 =head2 low
@@ -239,17 +240,22 @@
 =head2 class
 
  Title   : class
- Usage   : $s->class
+ Usage   : $s->class([$newclass])
  Function: get the source sequence class
  Returns : a string
- Args    : none
+ Args    : new class (optional)
  Status  : Public
 
-Returns the class for the source sequence for this segment.
+Gets or sets the class for the source sequence for this segment.
 
 =cut
 
-sub class     { shift->{class}     }
+sub class     { 
+  my $self = shift;
+  my $d = $self->{class};
+  $self->{class} = shift if @_;
+  $d;
+}
 
 =head2 subseq
 
@@ -423,10 +429,10 @@
 
 *abs_start  = \&start;
 
-=head2 abs_stop
+=head2 abs_end
 
- Title   : abs_stop
- Usage   : $s->abs_stop
+ Title   : abs_end
+ Usage   : $s->abs_end
  Function: the absolute stop of the segment
  Returns : an integer
  Args    : none
@@ -456,7 +462,7 @@
 
 sub abs_strand {
   my $self = shift;
-  return $self->abs_stop <=> $self->abs_start;
+  return $self->abs_end <=> $self->abs_start;
 }
 
 =head2 abs_ref
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Typename.pm bioperl-1.1/Bio/DB/GFF/Typename.pm
--- bioperl-1.0.2/Bio/DB/GFF/Typename.pm	Thu Oct 25 11:12:39 2001
+++ bioperl-1.1/Bio/DB/GFF/Typename.pm	Sat Sep  7 10:39:42 2002
@@ -26,12 +26,16 @@
 package Bio::DB::GFF::Typename;
 
 use strict;
+use Bio::Root::Root;
+use Bio::Das::FeatureTypeI;
 use overload 
   '""'     => 'asString',
   fallback => 1;
 
-use vars '$VERSION';
+use vars '$VERSION','@ISA';
 $VERSION=1.1;
+
+@ISA = qw(Bio::Root::Root Bio::Das::FeatureTypeI);
 
 # cut down on the number of equivalent objects we have to create
 my %OBJECT_CACHE;
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Util/Binning.pm bioperl-1.1/Bio/DB/GFF/Util/Binning.pm
--- bioperl-1.0.2/Bio/DB/GFF/Util/Binning.pm	Mon Feb  4 22:06:42 2002
+++ bioperl-1.1/Bio/DB/GFF/Util/Binning.pm	Thu Sep 26 21:36:50 2002
@@ -1,3 +1,28 @@
+=head1 NAME
+
+Bio::DB::GFF::Util::Binning - binning utility for Bio::DB::GFF index
+
+=head1 SYNOPSIS
+
+ use Bio::DB::GFF::Util::Binning qw(bin bin_bot bin_top);
+ my $tier = bin($start,$stop,$min);
+
+=head1 DESCRIPTION
+
+This is a utility module that exports the functions bin(), bin_bot()
+and bin_top().  These functions translate a range on the genome into a
+named bin that is used as an index in the Bio::DB::GFF schema.  The
+index makes certain range retrieval queries much faster.
+
+=head1 API
+
+The remainder of the document describes the function calls.  No calls
+are exported by default, but must be imported explicitly.
+
+=over 4
+
+=cut
+
 package Bio::DB::GFF::Util::Binning;
 
 use strict;
@@ -7,6 +32,14 @@
 @EXPORT_OK = qw(bin bin_bot bin_top);
 @EXPORT = @EXPORT_OK;
 
+=item $bin_name = bin($start,$stop,$bin_size)
+
+Given a start, stop and bin size on the genome, translate this
+location into a bin name.  In a list context, returns the bin tier
+name and the position that the bin begins.
+
+=cut
+
 sub bin {
   my ($start,$stop,$min) = @_;
   my $tier = $min;
@@ -20,11 +53,26 @@
   return wantarray ? ($tier,$bin_start) : bin_name($tier,$bin_start);
 }
 
+=item $bottom = bin_bot($tier,$start)
+
+Given a tier name and a range start position, returns the lower end of
+the bin range.
+
+=cut
+
 sub bin_bot {
   my $tier = shift;
   my $pos  = shift;
   bin_name($tier,int($pos/$tier));
 }
+
+=item $top = bin_top($tier,$end)
+
+Given a tier name and the end of a range, returns the upper end of the
+bin range.
+
+=cut
+
 *bin_top = \&bin_bot;
 
 sub bin_name { sprintf("%d.%06d",@_) }
@@ -35,3 +83,24 @@
 }
 
 1;
+
+=back
+
+=head1 BUGS
+
+None known yet.
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>,
+
+=head1 AUTHOR
+
+Lincoln Stein E<lt>lstein@cshl.orgE<gt>.
+
+Copyright (c) 2001 Cold Spring Harbor Laboratory.
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.
+
+=cut
diff -Naur bioperl-1.0.2/Bio/DB/GFF/Util/Rearrange.pm bioperl-1.1/Bio/DB/GFF/Util/Rearrange.pm
--- bioperl-1.0.2/Bio/DB/GFF/Util/Rearrange.pm	Mon Jul  9 18:05:14 2001
+++ bioperl-1.1/Bio/DB/GFF/Util/Rearrange.pm	Thu Sep 26 21:36:50 2002
@@ -1,3 +1,58 @@
+=head1 NAME
+
+Bio::DB::GFF::Util::Rearrange - rearrange utility
+
+=head1 SYNOPSIS
+
+ use Bio::DB::GFF::Util::Rearrange 'rearrange';
+
+ my ($arg1,$arg2,$arg3,$others) = rearrange(['ARG1','ARG2','ARG3'],@args);
+
+=head1 DESCRIPTION
+
+This is a different version of the _rearrange() method from
+Bio::Root::Root.  It runs as a function call, rather than as a method
+call, and it handles unidentified parameters slightly differently.
+
+It exports a single function call:
+
+=over 4
+
+=item @rearranged_args = rearrange(\@parameter_names,@parameters);
+
+The first argument is an array reference containing list of parameter
+names in the desired order.  The second and subsequent arguments are a
+list of parameters in the format:
+
+  (-arg1=>$arg1,-arg2=>$arg2,-arg3=>$arg3...)
+
+The function calls returns the parameter values in the order in which
+they were specified in @parameter_names.  Any parameters that were not
+found in @parameter_names are returned in the form of a hash reference
+in which the keys are the uppercased forms of the parameter names, and
+the values are the parameter values.
+
+=back
+
+=head1 BUGS
+
+None known yet.
+
+=head1 SEE ALSO
+
+L<Bio::DB::GFF>,
+
+=head1 AUTHOR
+
+Lincoln Stein E<lt>lstein@cshl.orgE<gt>.
+
+Copyright (c) 2001 Cold Spring Harbor Laboratory.
+
+This library is free software; you can redistribute it and/or modify
+it under the same terms as Perl itself.
+
+=cut
+
 package Bio::DB::GFF::Util::Rearrange;
 
 use strict;
@@ -45,7 +100,7 @@
         }
         push(@return_array,$value);
     }
-    push (@return_array,{%param}) if %param;
+    push (@return_array,\%param) if %param;
     return @return_array;
 }
 
diff -Naur bioperl-1.0.2/Bio/Graphics/Feature.pm bioperl-1.1/Bio/Graphics/Feature.pm
--- bioperl-1.0.2/Bio/Graphics/Feature.pm	Sun Jun 30 22:23:42 2002
+++ bioperl-1.1/Bio/Graphics/Feature.pm	Sun Sep  8 23:39:04 2002
@@ -1,4 +1,110 @@
 package Bio::Graphics::Feature;
+
+=head1 NAME
+
+Bio::Graphics::Feature - A simple feature object for use with Bio::Graphics::Panel
+
+=head1 SYNOPSIS
+
+ use Bio::Graphics::Feature;
+
+ # create a simple feature with no internal structure
+ $f = Bio::Graphics::Feature->new(-start => 1000,
+                                  -stop  => 2000,
+                                  -type  => 'transcript',
+                                  -name  => 'alpha-1 antitrypsin',
+				  -desc  => 'an enzyme inhibitor',
+                                 );
+
+ # create a feature composed of multiple segments, all of type "similarity"
+ $f = Bio::Graphics::Feature->new(-segments => [[1000,1100],[1500,1550],[1800,2000]],
+                                  -name     => 'ABC-3',
+                                  -type     => 'gapped_alignment',
+                                  -subtype  => 'similarity');
+
+ # build up a gene exon by exon
+ $e1 = Bio::Graphics::Feature->new(-start=>1,-stop=>100,-type=>'exon');
+ $e2 = Bio::Graphics::Feature->new(-start=>150,-stop=>200,-type=>'exon');
+ $e3 = Bio::Graphics::Feature->new(-start=>300,-stop=>500,-type=>'exon');
+ $f  = Bio::Graphics::Feature->new(-segments=>[$e1,$e2,$e3],-type=>'gene');
+
+=head1 DESCRIPTION
+
+This is a simple Bio::SeqFeatureI-compliant object that is compatible
+with Bio::Graphics::Panel.  With it you can create lightweight feature
+objects for drawing.
+
+All methods are as described in L<Bio::SeqFeatureI> with the following additions:
+
+=head2 The new() Constructor
+
+ $feature = Bio::Graphics::Feature->new(@args);
+
+This method creates a new feature object.  You can create a simple
+feature that contains no subfeatures, or a hierarchically nested object.
+
+Arguments are as follows:
+
+  -start       the start position of the feature
+  -end         the stop position of the feature
+  -stop        an alias for end
+  -name        the feature name (returned by seqname())
+  -type        the feature type (returned by primary_tag())
+  -source      the source tag
+  -desc        a description of the feature
+  -segments    a list of subfeatures (see below)
+  -subtype     the type to use when creating subfeatures
+  -strand      the strand of the feature (one of -1, 0 or +1)
+  -id          an alias for -name
+  -seqname     an alias for -name
+  -primary_id  an alias for -name
+  -display_id  an alias for -name
+
+The subfeatures passed in -segments may be an array of
+Bio::Graphics::Feature objects, or an array of [$start,$stop]
+pairs. Each pair should be a two-element array reference.  In the
+latter case, the feature type passed in -subtype will be used when
+creating the subfeatures.
+
+If no feature type is passed, then it defaults to "feature".
+
+=head2 Non-SeqFeatureI methods
+
+A number of new methods are provided for compatibility with
+Ace::Sequence, which has a slightly different API from SeqFeatureI:
+
+=over 4
+
+=item add_segment(@segments)
+
+Add one or more segments (a subfeature).  Segments can either be
+Feature objects, or [start,stop] arrays, as in the -segments argument
+to new().  The feature endpoints are automatically adjusted.
+
+=item segments()
+
+An alias for sub_SeqFeature().
+
+=item merged_segments()
+
+Another alias for sub_SeqFeature().
+
+=item stop()
+
+An alias for end().
+
+=item name()
+
+An alias for seqname().
+
+=item exons()
+
+An alias for sub_SeqFeature() (you don't want to know why!)
+
+=back
+
+=cut
+
 use strict;
 use Bio::Root::Root;
 use Bio::SeqFeatureI;
@@ -35,7 +141,7 @@
 
   $arg{-strand} ||= 0;
   $self->{strand}  = $arg{-strand} ? ($arg{-strand} >= 0 ? +1 : -1) : 0;
-  $self->{name}    = $arg{-name};
+  $self->{name}    = $arg{-name}   || $arg{-seqname} || $arg{-display_id} || $arg{-id} || $arg{-primary_id};
   $self->{type}    = $arg{-type}   || 'feature';
   $self->{subtype} = $arg{-subtype} if exists $arg{-subtype};
   $self->{source}  = $arg{-source} || $arg{-source_tag} || '';
@@ -46,6 +152,8 @@
   $self->{class}   = $arg{-class} if exists $arg{-class};
   $self->{url}     = $arg{-url}   if exists $arg{-url};
   $self->{seq}     = $arg{-seq}   if exists $arg{-seq};
+  $self->{phase}   = $arg{-phase} if exists $arg{-phase};
+  $self->{desc}    = $arg{-desc}  if exists $arg{-desc};
 
   # fix start, stop
   if (defined $self->{stop} && defined $self->{start}
@@ -146,7 +254,7 @@
 sub seq {
   my $self = shift;
   my $dna =  exists $self->{seq} ? $self->{seq} : '';
-  $dna .= 'n' x ($self->length - CORE::length($dna));
+  # $dna .= 'n' x ($self->length - CORE::length($dna));
   return $dna;
 }
 *dna = \&seq;
@@ -177,7 +285,7 @@
 
 =cut
 
-sub display_id { shift->seq_id }
+sub display_id { shift->name }
 
 =head2 accession_number
 
@@ -239,7 +347,12 @@
 
 =cut
 
-sub desc { shift }
+sub desc {
+  my $self = shift;
+  my $d    = $self->{desc};
+  $self->{desc} = shift if @_;
+  $d;
+}
 
 sub low {
   my $self = shift;
@@ -294,7 +407,7 @@
   my $high = $self->max_end;
   return "$low..$high";
 }
-sub phase { undef }
+sub phase { shift->{phase} }
 sub class {
   my $self = shift;
   my $d = $self->{class};
@@ -374,107 +487,14 @@
   }
 }
 
+sub each_tag_value { return }
+sub all_tags { return }
+
 sub DESTROY { }
 
 1;
 
 __END__
-
-=head1 NAME
-
-Bio::Graphics::Feature - A simple feature object for use with Bio::Graphics::Panel
-
-=head1 SYNOPSIS
-
- use Bio::Graphics::Feature;
-
- # create a simple feature with no internal structure
- $f = Bio::Graphics::Feature->new(-start => 1000,
-                                  -stop  => 2000,
-                                  -type  => 'transcript',
-                                  -name  => 'alpha-1 antitrypsin'
-                                 );
-
- # create a feature composed of multiple segments, all of type "similarity"
- $f = Bio::Graphics::Feature->new(-segments => [[1000,1100],[1500,1550],[1800,2000]],
-                                  -name     => 'ABC-3',
-                                  -type     => 'gapped_alignment',
-                                  -subtype  => 'similarity');
-
- # build up a gene exon by exon
- $e1 = Bio::Graphics::Feature->new(-start=>1,-stop=>100,-type=>'exon');
- $e2 = Bio::Graphics::Feature->new(-start=>150,-stop=>200,-type=>'exon');
- $e3 = Bio::Graphics::Feature->new(-start=>300,-stop=>500,-type=>'exon');
- $f  = Bio::Graphics::Feature->new(-segments=>[$e1,$e2,$e3],-type=>'gene');
-
-=head1 DESCRIPTION
-
-This is a simple Bio::SeqFeatureI-compliant object that is compatible
-with Bio::Graphics::Panel.  With it you can create lightweight feature
-objects for drawing.
-
-All methods are as described in L<Bio::SeqFeatureI> with the following additions:
-
-=head2 The new() Constructor
-
- $feature = Bio::Graphics::Feature->new(@args);
-
-This method creates a new feature object.  You can create a simple
-feature that contains no subfeatures, or a hierarchically nested object.
-
-Arguments are as follows:
-
-  -start       the start position of the feature
-  -stop        the stop position of the feature
-  -end         an alias for stop
-  -name        the feature name (returned by seqname())
-  -type        the feature type (returned by primary_tag())
-  -source      the source tag
-  -segments    a list of subfeatures (see below)
-  -subtype     the type to use when creating subfeatures
-
-The subfeatures passed in -segments may be an array of
-Bio::Graphics::Feature objects, or an array of [$start,$stop]
-pairs. Each pair should be a two-element array reference.  In the
-latter case, the feature type passed in -subtype will be used when
-creating the subfeatures.
-
-If no feature type is passed, then it defaults to "feature".
-
-=head2 Non-SeqFeatureI methods
-
-A number of new methods are provided for compatibility with
-Ace::Sequence, which has a slightly different API from SeqFeatureI:
-
-=over 4
-
-=item add_segment(@segments)
-
-Add one or more segments (a subfeature).  Segments can either be
-Feature objects, or [start,stop] arrays, as in the -segments argument
-to new().  The feature endpoints are automatically adjusted.
-
-=item segments()
-
-An alias for sub_SeqFeature().
-
-=item merged_segments()
-
-Another alias for sub_SeqFeature().
-
-=item stop()
-
-An alias for end().
-
-=item name()
-
-An alias for seqname().
-
-=item exons()
-
-An alias for sub_SeqFeature() (you don't want to know why!)
-
-=back
 
 =head1 SEE ALSO
 
diff -Naur bioperl-1.0.2/Bio/Graphics/FeatureFile.pm bioperl-1.1/Bio/Graphics/FeatureFile.pm
--- bioperl-1.0.2/Bio/Graphics/FeatureFile.pm	Thu Jul  4 10:40:00 2002
+++ bioperl-1.1/Bio/Graphics/FeatureFile.pm	Tue Oct  1 17:16:29 2002
@@ -1,6 +1,6 @@
 package Bio::Graphics::FeatureFile;
 
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 # This package parses and renders a simple tab-delimited format for features.
 # It is simpler than GFF, but still has a lot of expressive power.
 # See __END__ for the file format
@@ -119,7 +119,7 @@
 use IO::File;
 use Text::Shellwords;
 use vars '$VERSION';
-$VERSION = '1.02';
+$VERSION = '1.03';
 
 # default colors for unconfigured features
 my @COLORS = qw(cyan blue red yellow green wheat turquoise orange);
@@ -129,10 +129,10 @@
 
 =over 4
 
-=item $features = Bio::Graphics::FeatureFile->new(@args)
+=item $features = Bio::Graphics::FeatureFile-E<gt>new(@args)
 
 Create a new Bio::Graphics::FeatureFile using @args to initialize the
-object.  Arguments are -name=>value pairs:
+object.  Arguments are -name=E<gt>value pairs:
 
   Argument         Value
   --------         -----
@@ -222,9 +222,10 @@
 
 # render our features onto a panel using configuration data
 # return the number of tracks inserted
+
 =over 4
 
-=item ($rendered,$panel) = $features->render([$panel])
+=item ($rendered,$panel) = $features-E<gt>render([$panel])
 
 Render features in the data set onto the indicated
 Bio::Graphics::Panel.  If no panel is specified, creates one.
@@ -306,7 +307,7 @@
 
 =over 4
 
-=item $error = $features->error([$error])
+=item $error = $features-E<gt>error([$error])
 
 Get/set the current error message.
 
@@ -323,7 +324,7 @@
 
 =over 4
 
-=item $smart_features = $features->smart_features([$flag]
+=item $smart_features = $features-E<gt>smart_features([$flag]
 
 Get/set the "smart_features" flag.  If this is set, then any features
 added to the featurefile object will have their configurator() method
@@ -398,7 +399,7 @@
      return;
   }
 
-  if (/^([\w ]+?)\s*=\s*(.*)/) {   # key value pair within a configuration section
+  if (/^([\w: -]+?)\s*=\s*(.*)/) {   # key value pair within a configuration section
     my $tag = lc $1;
     my $cc = $self->{current_config} ||= 'general';       # in case no configuration named
     my $value = defined $2 ? $2 : '';
@@ -489,7 +490,7 @@
 				  -type     => $type,
 				  $strand ? (-strand   => make_strand($strand)) : (),
 				  -segments => \@parts,
-				  -source   => $description,
+				  -desc     => $description,
 				  -ref      => $ref,
 				  defined($url) ? (-url      => $url) : (),
 				 );
@@ -505,7 +506,7 @@
 
 =over 4
 
-=item $features->add_feature($feature [=>$type])
+=item $features-E<gt>add_feature($feature [=E<gt>$type])
 
 Add a new Bio::FeatureI object to the set.  If $type is specified, the
 object will be added with the indicated type.  Otherwise, the
@@ -527,10 +528,10 @@
 
 =over 4
 
-=item $features->add_type($type=>$hashref)
+=item $features-E<gt>add_type($type=E<gt>$hashref)
 
 Add a new feature type to the set.  The type is a string, such as
-"EST".  The hashref is a set of key=>value pairs indicating options to
+"EST".  The hashref is a set of key=E<gt>value pairs indicating options to
 set on the type.  Example:
 
   $features->add_type(EST => { glyph => 'generic', fgcolor => 'blue'})
@@ -561,7 +562,7 @@
 
 =over 4
 
-=item $features->set($type,$tag,$value)
+=item $features-E<gt>set($type,$tag,$value)
 
 Change an individual option for a particular type.  For example, this
 will change the foreground color of EST features to my favorite color:
@@ -596,7 +597,7 @@
 
 =over 4
 
-=item $value = $features->setting($stanza => $option)
+=item $value = $features-E<gt>setting($stanza =E<gt> $option)
 
 In the two-element form, the setting() method returns the value of an
 option in the configuration stanza indicated by $stanza.  For example:
@@ -640,7 +641,7 @@
 
 =over 4
 
-=item $value = $features->code_setting($stanza=>$option);
+=item $value = $features-E<gt>code_setting($stanza=E<gt>$option);
 
 This works like setting() except that it is also able to evaluate code
 references.  These are options whose values begin with the characters
@@ -668,7 +669,7 @@
 
 =over 4
 
-=item $flag = $features->safe([$flag]);
+=item $flag = $features-E<gt>safe([$flag]);
 
 This gets or sets and "safe" flag.  If the safe flag is set, then
 calls to setting() will invoke code_setting(), allowing values that
@@ -691,11 +692,11 @@
 
 =over 4
 
-=item @args = $features->style($type)
+=item @args = $features-E<gt>style($type)
 
 Given a feature type, returns a list of track configuration arguments
 suitable for suitable for passing to the
-Bio::Graphics::Panel->add_track() method.
+Bio::Graphics::Panel-E<gt>add_track() method.
 
 =back
 
@@ -715,10 +716,10 @@
 
 =over 4
 
-=item $glyph = $features->glyph($type);
+=item $glyph = $features-E<gt>glyph($type);
 
 Return the name of the glyph corresponding to the given type (same as
-$features->setting($type=>'glyph')).
+$features-E<gt>setting($type=E<gt>'glyph')).
 
 =back
 
@@ -736,7 +737,7 @@
 
 =over 4
 
-=item @types = $features->configured_types()
+=item @types = $features-E<gt>configured_types()
 
 Return a list of all the feature types currently known to the feature
 file set.  Roughly equivalent to:
@@ -756,7 +757,7 @@
 
 =over 4
 
-=item  @types = $features->types()
+=item  @types = $features-E<gt>types()
 
 This is similar to the previous method, but will return *all* feature
 types, including those that are not configured with a stanza.
@@ -774,7 +775,7 @@
 
 =over 4
 
-=item @features = $features->features($type)
+=item @features = $features-E<gt>features($type)
 
 Return a list of all the feature types of type "$type".  If the
 featurefile object was created by parsing a file or text scalar, then
@@ -804,7 +805,7 @@
 
 =over 4
 
-=item @refs = $features->refs
+=item @refs = $features-E<gt>refs
 
 Return the list of reference sequences referred to by this data file.
 
@@ -820,7 +821,7 @@
 
 =over 4
 
-=item  $min = $features->min
+=item  $min = $features-E<gt>min
 
 Return the minimum coordinate of the leftmost feature in the data set.
 
@@ -832,7 +833,7 @@
 
 =over 4
 
-=item $max = $features->max
+=item $max = $features-E<gt>max
 
 Return the maximum coordinate of the rightmost feature in the data set.
 
@@ -955,13 +956,13 @@
 
 =over 4
 
-=item $mtime = $features->mtime
+=item $mtime = $features-E<gt>mtime
 
-=item $atime = $features->atime
+=item $atime = $features-E<gt>atime
 
-=item $ctime = $features->ctime
+=item $ctime = $features-E<gt>ctime
 
-=item $size = $features->size
+=item $size = $features-E<gt>size
 
 Returns stat() information about the data file, for featurefile
 objects created using the -file option.  Size is in bytes.  mtime,
@@ -983,7 +984,7 @@
 
 =over 4
 
-=item $label = $features->feature2label($feature)
+=item $label = $features-E<gt>feature2label($feature)
 
 Given a feature, determines the configuration stanza that bests
 describes it.  Uses the feature's type() method if it has it (DasI
@@ -1004,7 +1005,7 @@
 
 =over 4
 
-=item $link = $features->make_link($feature)
+=item $link = $features-E<gt>make_link($feature)
 
 Given a feature, tries to generate a URL to link out from it.  This
 uses the 'link' option, if one is present.  This method is a
@@ -1028,11 +1029,14 @@
   my $self = shift;
   my ($pattern,$feature) = @_;
   $pattern =~ s/\$(\w+)/
-    $1 eq 'name'   ? $feature->name
+    $1 eq 'ref'        ? $feature->location->seq_id
+      : $1 eq 'name'   ? $feature->display_id
       : $1 eq 'class'  ? $feature->class
       : $1 eq 'type'   ? $feature->method
       : $1 eq 'method' ? $feature->method
       : $1 eq 'source' ? $feature->source
+      : $1 eq 'start'  ? $feature->start
+      : $1 eq 'end'    ? $feature->end
       : $1
        /exg;
   return $pattern;
@@ -1061,7 +1065,7 @@
 
 =over 4
 
-=item $citation = $features->citation($feature)
+=item $citation = $features-E<gt>citation($feature)
 
 Given a feature, tries to generate a citation for it, using the
 "citation" option if one is present.  This method is a convenience for
@@ -1081,7 +1085,7 @@
 
 =over 4
 
-=item $name = $features->name([$feature])
+=item $name = $features-E<gt>name([$feature])
 
 Get/set the name of this feature set.  This is a convenience method
 useful for keeping track of multiple feature sets.
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/Factory.pm bioperl-1.1/Bio/Graphics/Glyph/Factory.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/Factory.pm	Wed Jul  3 22:55:17 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/Factory.pm	Thu Sep 26 21:36:52 2002
@@ -1,3 +1,53 @@
+=head1 NAME
+
+Bio::Graphics::Glyph::Factory - Factory for Bio::Graphics::Glyph objects
+
+=head1 SYNOPSIS
+
+See L<Bio::Graphics::Panel>.
+
+=head1 DESCRIPTION
+
+This class is used internally by Bio::Graphics to generate new Glyph
+objects by combining a list of features with the user's desired
+configuration.  It is intended to be used internally by Bio::Graphics.
+
+=head1 FEEDBACK
+
+=head2 Mailing Lists
+
+User feedback is an integral part of the evolution of this and other
+Bioperl modules. Send your comments and suggestions preferably to one
+of the Bioperl mailing lists.  Your participation is much appreciated.
+
+  bioperl-l@bioperl.org             - General discussion
+  http://bioperl.org/MailList.shtml - About the mailing lists
+
+=head2 Reporting Bugs
+
+Report bugs to the Bioperl bug tracking system to help us keep track
+the bugs and their resolution.  Bug reports can be submitted via
+email or the web:
+
+  bioperl-bugs@bio.perl.org
+  http://bio.perl.org/bioperl-bugs/
+
+=head1 AUTHOR - Lincoln Stein
+
+Email - lstein@cshl.org
+
+=head1 SEE ALSO
+
+L<Bio::Graphics::Panel>
+
+=head1 APPENDIX
+
+The rest of the documentation details each of the object
+methods. Internal methods are usually preceded with an "_"
+(underscore).
+
+=cut
+
 package Bio::Graphics::Glyph::Factory;
 
 use strict;
@@ -15,6 +65,24 @@
 		       bump       => +1,       # bump by default (perhaps a mistake?)
 		       );
 
+=head2 new
+
+  Title   : new
+  Usage   : $f = Bio::Graphics::Glyph::Factory->new(
+                     -stylesheet => $stylesheet,
+		     -glyph_map  => $glyph_map,
+		     -options    => $options);
+  Function : create a new Bio::Graphics::Glyph::Factory object
+  Returns  : the new object
+  Args     : $stylesheet is a Bio::Das::Stylesheet object that can
+                 convert Bio::Das feature objects into glyph names and
+                 associated options.
+             $glyph_map is a hash that maps primary tags to glyph names.
+             $options is a hash that maps option names to their values.
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub new {
   my $class = shift;
   my $panel = shift;
@@ -29,42 +97,203 @@
 		panel      => $panel,
 		},$class;
 }
+
+=head2 clone
+
+  Title    : clone
+  Usage    : $f2 = $f->clone
+  Function : Deep copy of a factory object
+  Returns  : a deep copy of the factory object
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub clone {
   my $self = shift;
   my %new = %$self;
   my $new = bless \%new,ref($self);
   $new;
 }
+
+=head2 stylesheet
+
+  Title    : stylesheet
+  Usage    : $stylesheet = $f->stylesheet
+  Function : accessor for stylesheet
+  Returns  : a Bio::Das::Stylesheet object
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub stylesheet { shift->{stylesheet}  }
+
+=head2 glyph_map
+
+  Title    : glyph_map
+  Usage    : $map = $f->glyph_map
+  Function : accessor for the glyph map
+  Returns  : a hash mapping primary tags to glyphs
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub glyph_map  { shift->{glyph_map}   }
+
+=head2 option_map
+
+  Title    : option_map
+  Usage    : $map = $f->option_map
+  Function : accessor for the option map
+  Returns  : a hash mapping option names to values
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub option_map { shift->{options}     }
+
+=head2 global_opts
+
+  Title    : global_opts
+  Usage    : $map = $f->global_opts
+  Function : accessor for global options
+  Returns  : a hash mapping option names to values
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+This returns a set of defaults for option values.
+
+=cut
+
 sub global_opts{ shift->{global_opts} }
+
+=head2 panel
+
+  Title    : panel
+  Usage    : $panel = $f->panel
+  Function : accessor for Bio::Graphics::Panel
+  Returns  : a Bio::Graphics::Panel
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+This returns the panel with which the factory is associated.
+
+=cut
+
 sub panel      { shift->{panel}       }
+
+=head2 scale
+
+  Title    : scale
+  Usage    : $scale = $f->scale
+  Function : accessor for the scale
+  Returns  : a floating point number
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+This returns the scale, in pixels/bp for glyphs constructed by this
+factory.
+
+=cut
+
 sub scale      { shift->{panel}->scale }
+
+=head2 font
+
+  Title    : font
+  Usage    : $font = $f->font
+  Function : accessor for the font
+  Returns  : a font name
+  Args     : None
+  Status   : Internal to Bio::Graphics
+
+This returns a GD font name.
+
+=cut
+
 sub font       {
   my $self = shift;
   my $glyph = shift;
   $self->option($glyph,'font') || $self->{font};
 }
 
+=head2 map_pt
+
+  Title    : map_pt
+  Usage    : @pixel_positions = $f->map_pt(@bp_positions)
+  Function : map bp positions to pixel positions
+  Returns  : a list of pixel positions
+  Args     : a list of bp positions
+  Status   : Internal to Bio::Graphics
+
+The real work is done by the panel, but factory subclasses can
+override if desired.
+
+=cut
+
 sub map_pt {
   my $self = shift;
   my @result = $self->panel->map_pt(@_);
   return wantarray ? @result : $result[0];
 }
 
+=head2 map_no_trunc
+
+  Title    : map_no_trunc
+  Usage    : @pixel_positions = $f->map_no_trunc(@bp_positions)
+  Function : map bp positions to pixel positions
+  Returns  : a list of pixel positions
+  Args     : a list of bp positions
+  Status   : Internal to Bio::Graphics
+
+Same as map_pt(), but it will NOT clip pixel positions to be within
+the drawing frame.
+
+=cut
+
 sub map_no_trunc {
   my $self = shift;
   my @result = $self->panel->map_no_trunc(@_);
   return wantarray ? @result : $result[0];
 }
 
+=head2 translate_color
+
+  Title    : translate_color
+  Usage    : $index = $f->translate_color($color_name)
+  Function : translate symbolic color names into GD indexes
+  Returns  : an integer
+  Args     : a color name in format "green" or "#00FF00"
+  Status   : Internal to Bio::Graphics
+
+The real work is done by the panel, but factory subclasses can
+override if desired.
+
+=cut
+
 sub translate_color {
   my $self = shift;
   my $color_name = shift;
   $self->panel->translate_color($color_name);
 }
 
+=head2 glyph
+
+  Title    : glyph
+  Usage    : @glyphs = $f->glyph($level,$feature1,$feature2...)
+  Function : transform features into glyphs.
+  Returns  : a list of Bio::Graphics::Glyph objects
+  Args     : a feature "level", followed by a list of FeatureI objects.
+  Status   : Internal to Bio::Graphics
+
+The level is used to track the level of nesting of features that have
+subfeatures.
+
+=cut
+
 # create a glyph
 sub make_glyph {
   my $self  = shift;
@@ -97,6 +326,17 @@
   return wantarray ? @result : $result[0];
 }
 
+=head2 feature_to_glyph
+
+  Title    : feature_to_glyph
+  Usage    : $glyph_name = $f->feature_to_glyph($feature)
+  Function : choose the glyph name given a feature
+  Returns  : a glyph name
+  Args     : a Bio::Seq::FeatureI object
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub feature_to_glyph {
   my $self    = shift;
   my $feature = shift;
@@ -107,6 +347,18 @@
   return $map->{$feature->primary_tag} || 'generic';
 }
 
+
+=head2 set_option
+
+  Title    : set_option
+  Usage    : $f->set_option($option_name=>$option_value)
+  Function : set or change an option
+  Returns  : nothing
+  Args     : a name/value pair
+  Status   : Internal to Bio::Graphics
+
+=cut
+
 sub set_option {
   my $self = shift;
   my ($option_name,$option_value) = @_;
@@ -145,6 +397,18 @@
 
   return $GENERIC_OPTIONS{$option_name};
 }
+
+
+=head2 options
+
+  Title    : options
+  Usage    : @option_names = $f->options
+  Function : return all configured option names
+  Returns  : a list of option names
+  Args     : none
+  Status   : Internal to Bio::Graphics
+
+=cut
 
 # return names of all the options in the option hashes
 sub options {
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/arrow.pm bioperl-1.1/Bio/Graphics/Glyph/arrow.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/arrow.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/arrow.pm	Mon Sep 23 07:51:22 2002
@@ -2,11 +2,17 @@
 # package to use for drawing an arrow
 
 use strict;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
 use Bio::Graphics::Glyph::generic;
+$VERSION = 1.02;
 @ISA = 'Bio::Graphics::Glyph::generic';
 
-my %UNITS = (K => 1000,
+my %UNITS = (n => 1e-12,
+	     n => 1e-9,
+	     u => 1e-6,
+	     m => 0.001,
+	     c => 0.01,
+	     K => 1000,
 	     M => 1_000_000,
 	     G => 1_000_000_000);
 
@@ -94,17 +100,23 @@
     my $offset   = $relative ? $self->feature->start-1 : 0;
     my $reversed = $relative && $self->feature->strand < 0;
 
-    my $units    = $self->option('units') || $self->calculate_units($start,$self->feature->length);
-    my $divisor  = $UNITS{$units} || 1;
-    my $format   = min($self->feature->length,$self->panel->length)/$divisor > 10
-      ? "%d$units" : "%.6g$units";
+    my $unit_label   = $self->option('units') || '';
+    my $unit_divider = $self->option('unit_divider') || 1;
+
+    my $units      = $self->calculate_units($start/$unit_divider,$self->feature->length/$unit_divider);
+    my $divisor    = $UNITS{$units} || 1;
+
+    $divisor *= $unit_divider;
+
+    my $format     = min($self->feature->length,$self->panel->length)/$divisor > 10
+      ? "%d$units%s" : "%.6g$units%s";
 
     my $scale  = $self->option('scale') || 1;  ## Does the user want to override the internal scale?
 
-    my $model  = sprintf("$format ",$stop/($divisor*$scale));
+    my $model  = sprintf("$format ",$stop/($divisor*$scale),$unit_label);
     my $minlen = $width * length($model);
 
-    my ($major_interval,$minor_interval) = $self->panel->ticks($stop-$start+1,$minlen);
+    my ($major_interval,$minor_interval) = $self->panel->ticks(($stop-$start+1)/$unit_divider,$minlen);
 
     my $left  = $sw ? $x1+$height : $x1;
     my $right = $ne ? $x2-$height : $x2;
@@ -126,10 +138,9 @@
 
       $gd->line($tickpos,$center-$a2,$tickpos,$center+$a2,$fg);
       my $label = $scale ? $i / $scale : $i;
-      if ($units) {
-	my $scaled = $label/$divisor;
-	$label = sprintf($format,$scaled);
-      }
+      my $scaled = $label/$divisor;
+      $label = sprintf($format,$scaled,$unit_label);
+
       my $middle = $tickpos - (length($label) * $width)/2;
       next if $middle < $left or $middle > $right;
 
@@ -182,10 +193,15 @@
 sub calculate_units {
   my $self   = shift;
   my ($start,$length) = @_;
-  return ''  if $length <= 1e3;
-  return 'G' if $start >= 1e8 || $length >= 1e9;
-  return 'M' if $start >= 1e7 || $length >= 1e6;
-  return 'K';
+  return 'G' if $length >= 1e9;
+  return 'M' if $length >= 1e6;
+  return 'K' if $length >= 1e3;
+  return ''  if $length >= 1;
+  return 'c' if $length >= 1e-2;
+  return 'm' if $length >= 1e-3;
+  return 'u' if $length >= 1e-6;
+  return 'n' if $length >= 1e-9;
+  return 'p';
 }
 
 sub min { $_[0]<$_[1] ? $_[0] : $_[1] }
@@ -245,39 +261,50 @@
   Option      Description               Default
   ------      -----------               -------
 
-  -tick       Whether to draw major         0
+  -tick       Whether to draw major             0
               and minor ticks.
 	      0 = no ticks
 	      1 = major ticks
 	      2 = minor ticks
 
-  -parallel   Whether to draw the arrow     true
+  -parallel   Whether to draw the arrow         true
 	      parallel to the sequence
 	      or perpendicular to it.
 
-  -northeast  Force a north or east         true
+  -northeast  Force a north or east             true
 	      arrowhead(depending 
 	      on orientation)
 
   -east       synonym of above
 
-  -southwest  Force a south or west         true
+  -southwest  Force a south or west             true
 	      arrowhead(depending 
 	      on orientation)
 
   -west       synonym of above
 
-  -double     force-doubleheaded arrow
+  -double     force-doubleheaded arrow          false
 
-  -base       Draw a vertical base at the   false
+  -base       Draw a vertical base at the       false
               non-arrowhead side
 
-  -scale      Reset the labels on the arrow false
+  -scale      Reset the labels on the arrow     false
               to reflect an externally 
               established scale.
 
-  -arrowstyle "regular" to create a simple arrowhead ->
-              "filled" to create a thick filled arrowhead
+  -arrowstyle "regular" to create a simple      regular
+              arrowhead.  "filled" to create
+              a thick filled arrowhead
+
+  -units      add units to the tick labels      none
+              e.g. bp
+
+  -unit_divider                                 1
+              divide tick labels by the
+              indicated amount prior to
+              displaying (use, for example
+              if you want to display in
+              cR units)
 
 Set -parallel to false to display a point-like feature such as a
 polymorphism, or to indicate an important location.  If the feature
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/cds.pm bioperl-1.1/Bio/Graphics/Glyph/cds.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/cds.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/cds.pm	Mon Sep 30 21:54:33 2002
@@ -6,8 +6,8 @@
 use Bio::Tools::CodonTable;
 use Bio::Graphics::Glyph::translation;
 use vars '@ISA','$VERSION';
-@ISA = qw(Bio::Graphics::Glyph::segments Bio::Graphics::Glyph::translation);
-$VERSION = '1.01';
+@ISA = qw(Bio::Graphics::Glyph::segmented_keyglyph Bio::Graphics::Glyph::translation);
+$VERSION = '1.02';
 
 sub connector   { 0 };
 sub description {
@@ -22,7 +22,7 @@
   my ($gd,$left,$top) = @_;
 
   my @parts = $self->parts;
-
+  @parts    = $self if !@parts && $self->level == 0;
   return $self->SUPER::draw(@_) unless @parts;
 
   my $fits = $self->protein_fits;
@@ -44,14 +44,16 @@
 
   # figure out the colors of each part
   # sort minus strand features backward
-  @parts = sort {$b->left <=> $a->left} @parts if $strand < 0;
+  @parts = map { $_->[0] }
+  sort { $b->[1] <=> $a->[1] }
+  map { [$_, $_->left ] } @parts if $strand < 0;
   my $translate_table = Bio::Tools::CodonTable->new;
 
   for (my $i=0; $i < @parts; $i++) {
     my $part    = $parts[$i];
     my $feature = $part->feature;
     my $pos     = $strand > 0 ? $feature->start : $feature->end;
-    my $phase           = eval {$feature->phase} || 0;
+    my $phase   = eval {$feature->phase} || 0;
     my ($frame,$offset) = frame_and_offset($pos,
 					   $feature->strand,
 					   -$phase);
@@ -128,8 +130,49 @@
   for (my $i=0;$i<@residues;$i++) {
     my $x = $strand > 0 ? $start + $i * $pixels_per_residue
                         : $stop  - $i * $pixels_per_residue;
-    $gd->char($font,$x,$y1,$residues[$i],$color) if $x >= $x1 && $x <= $x2;
+    next unless ($x > $x1 && $x <= $x2);
+    $gd->char($font,$x,$y1,$residues[$i],$color);
   }
+}
+
+sub make_key_feature {
+  my $self = shift;
+  my @gatc = qw(g a t c);
+  my $offset = $self->panel->offset;
+  my $scale = 1/$self->scale;  # base pairs/pixel
+  my $start = $offset;
+  my $stop  = $offset + 100 * $scale;
+  my $seq   = join('',map{$gatc[rand 4]} (1..1500));
+  my $feature =
+    Bio::Graphics::Feature->new(-start=> $start,
+				-end  => $stop,
+				-seq  => $seq,
+				-name => $self->option('key'),
+				-strand=> +1,
+			       );
+  $feature->add_segment(Bio::Graphics::Feature->new(
+						    -start=> $start,
+						    -end => $start + ($stop - $start)/2,
+						    -seq  => $seq,
+						    -name => $self->option('key'),
+						    -strand=> +1,
+						   ),
+			Bio::Graphics::Feature->new(
+						    -start=> $start + ($stop - $start)/2+1,
+						    -end => $stop,
+						    -seq  => $seq,
+						    -name => $self->option('key'),
+						    -phase=> 1,
+						    -strand=> +1,
+						   ));
+  $feature;
+}
+
+# never allow our components to bump
+sub bump {
+  my $self = shift;
+  return $self->SUPER::bump(@_) if $self->all_callbacks;
+  return 0;
 }
 
 1;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/diamond.pm bioperl-1.1/Bio/Graphics/Glyph/diamond.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/diamond.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/diamond.pm	Mon Sep 16 19:15:30 2002
@@ -2,8 +2,10 @@
 # DAS-compatible package to use for drawing a colored diamond
 
 use strict;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
+use Bio::Graphics::Glyph::generic;
 @ISA = 'Bio::Graphics::Glyph::generic';
+$VERSION = 1.01;
 
 sub draw_component {
   my $self = shift;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/dna.pm bioperl-1.1/Bio/Graphics/Glyph/dna.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/dna.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/dna.pm	Mon Aug 26 14:07:19 2002
@@ -2,8 +2,13 @@
 
 use strict;
 use Bio::Graphics::Glyph::generic;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
 @ISA = qw(Bio::Graphics::Glyph::generic);
+$VERSION = '1.00';
+
+my %complement = (g=>'c',a=>'t',t=>'a',c=>'g',
+		  G=>'C',A=>'T',T=>'A',C=>'G');
+
 
 # turn off description
 sub description { 0 }
@@ -21,11 +26,12 @@
 
 sub pixels_per_base {
   my $self = shift;
+  return $self->scale;
 
-  my $width           = $self->width;
-  my $length          = $self->feature->length;
+#  my $width           = $self->width;
+#  my $length          = $self->feature->length;
 
-  return $width/($self->feature->length-1);
+#  return $width/($self->feature->length-1);
 }
 
 sub dna_fits {
@@ -66,21 +72,43 @@
   my ($gd,$dna,$x1,$y1,$x2,$y2) = @_;
   my $pixels_per_base = $self->pixels_per_base;
 
-  my @bases = split '',$dna;
+  my $feature = $self->feature;
+  my @bases = split '',$feature->strand >= 0 ? $dna : reversec($dna);
   my $color = $self->fgcolor;
   my $font  = $self->font;
   my $lineheight = $font->height;
+  my $strands = $self->option('strand') || 'auto';
+
+  my ($forward,$reverse);
+  if ($strands eq 'auto') {
+    $forward = $feature->strand >= 0;
+    $reverse = $feature->strand <= 0;
+  } elsif ($strands eq 'both') {
+    $forward = $reverse = 1;
+  } elsif ($strands eq 'reverse') {
+    $reverse = 1;
+  } else {
+    $forward = 1;
+  }
+
+  my $start  = $self->map_no_trunc($feature->start);
+  my $offset = ($x1-$start-1)/$pixels_per_base;
 
-  my %complement = (g=>'c',a=>'t',t=>'a',c=>'g',
-		    G=>'C',A=>'T',T=>'A',C=>'G');
-  for (my $i=0;$i<@bases;$i++) {
-    my $x = $x1 + $i * $pixels_per_base;
-    $gd->char($font,$x,$y1,$bases[$i],$color);
-    $gd->char($font,$x,$y1+$lineheight,$complement{$bases[$i]}||$bases[$i],$color);
+  for (my $i=$offset;$i<@bases;$i++) {
+    my $x = $start + $i * $pixels_per_base;
+    next if $x+1 < $x1;
+    last if $x > $x2;
+    $gd->char($font,$x,$y1,$bases[$i],$color)                                      if $forward;
+    $gd->char($font,$x,$y1+$lineheight,$complement{$bases[$i]}||$bases[$i],$color) if $reverse;
   }
 
 }
 
+sub reversec {
+  $_[0]=~tr/gatcGATC/ctagCTAG/;
+  return scalar reverse $_[0];
+}
+
 sub draw_gc_content {
   my $self     = shift;
   my $gd       = shift;
@@ -105,17 +133,17 @@
   my $axiscolor  = $self->color('axis_color') || $fgcolor;
 
   $gd->line($x1,  $y1,        $x1,  $y2,        $axiscolor);
-  $gd->line($x2-1,$y1,        $x2-1,$y2,        $axiscolor);
+  $gd->line($x2-2,$y1,        $x2-2,$y2,        $axiscolor);
   $gd->line($x1,  $y1,        $x1+3,$y1,        $axiscolor);
   $gd->line($x1,  $y2,        $x1+3,$y2,        $axiscolor);
   $gd->line($x1,  ($y2+$y1)/2,$x1+3,($y2+$y1)/2,$axiscolor);
-  $gd->line($x2-3,$y1,        $x2-1, $y1,       $axiscolor);
-  $gd->line($x2-3,$y2,        $x2-1, $y2,       $axiscolor);
-  $gd->line($x2-3,($y2+$y1)/2,$x2-1,($y2+$y1)/2,$axiscolor);
+  $gd->line($x2-4,$y1,        $x2-1, $y1,       $axiscolor);
+  $gd->line($x2-4,$y2,        $x2-1, $y2,       $axiscolor);
+  $gd->line($x2-4,($y2+$y1)/2,$x2-1,($y2+$y1)/2,$axiscolor);
   $gd->line($x1+5,$y2,        $x2-5,$y2,        $bgcolor);
   $gd->line($x1+5,($y2+$y1)/2,$x2-5,($y2+$y1)/2,$bgcolor);
   $gd->line($x1+5,$y1,        $x2-5,$y1,        $bgcolor);
-  $gd->string($self->font,$x1+5,$y1,'% gc',$axiscolor);
+  $gd->string($self->font,$x1+5,$y1,'% gc',$axiscolor) if $bin_height > $self->font->height*2;
 
   for (my $i = 0; $i < @bins; $i++) {
     my $bin_start  = $x1+$i*$bin_width;
@@ -129,11 +157,17 @@
 
 sub make_key_feature {
   my $self = shift;
+  my @gatc = qw(g a t c);
   my $offset = $self->panel->offset;
+  my $scale = 1/$self->scale;  # base pairs/pixel
+
+  my $start = $offset+1;
+  my $stop  = $offset+100*$scale;
   my $feature =
-    Bio::Graphics::Feature->new(-start=> $offset,
-				-stop => $offset + 10,
-				-name => 'DNA/GC content',
+    Bio::Graphics::Feature->new(-start=> $start,
+				-stop => $stop,
+				-seq  => join('',map{$gatc[rand 4]} (1..500)),
+				-name => $self->option('key'),
 				-strand => '+1',
 			       );
   $feature;
@@ -206,6 +240,18 @@
 
   -axis_color Color of the vertical axes  fgcolor
               in the GC content graph
+
+  -strand      Show both forward and      auto
+              reverse strand, one of
+              "forward", "reverse",
+              "both" or "auto".
+              In "auto" mode,
+              +1 strand features will
+              show the plus strand
+              -1 strand features will
+              show the reverse complement
+              and strandless features will
+              show both
 
 =head1 BUGS
 
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/dot.pm bioperl-1.1/Bio/Graphics/Glyph/dot.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/dot.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/dot.pm	Sun Oct  6 14:14:50 2002
@@ -39,7 +39,7 @@
 	      $ymid+($r*cos($angle*PI/180)),$fg);
   }
 
-  $self->draw_label($gd,$x1,$y1-$self->height) if $self->option('label');
+  $self->draw_label($gd,@_) if $self->option('label');
 }
 
 1;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/generic.pm bioperl-1.1/Bio/Graphics/Glyph/generic.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/generic.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/generic.pm	Fri Oct  4 20:18:24 2002
@@ -43,15 +43,17 @@
 }
 sub label {
   my $self = shift;
+  return if $self->{overbumped};  # set by the bumper when we have hit bump limit
   return unless $self->{level} == 0;
   return exists $self->{label} ? $self->{label}
-                               : $self->{label} = $self->_label;
+                               : ($self->{label} = $self->_label);
 }
 sub description {
   my $self = shift;
+  return if $self->{overbumped}; # set by the bumper when we have hit bump limit
   return unless $self->{level} == 0;
   return exists $self->{description} ? $self->{description}
-                                     : $self->{description} = $self->_description;
+                                     : ($self->{description} = $self->_description);
 }
 sub _label {
   my $self = shift;
@@ -64,8 +66,8 @@
 
   # figure it out ourselves
   my $f = $self->feature;
-  my $info = eval {$f->info};
-  return $info if $info;
+  return $f->info       if $f->can('info');
+  return $f->display_id if $f->can('display_id');
   return eval {$f->seqname} || eval{$f->primary_tag};
 }
 sub _description {
@@ -84,9 +86,11 @@
 sub get_description {
   my $self = shift;
   my $feature = shift;
-  if (my @notes = eval { $feature->notes }) {
-    return join '; ',@notes;
-  }
+
+  # common places where we can get descriptions
+  return join '; ',$feature->notes if $feature->can('notes');
+  return $feature->desc            if $feature->can('desc');
+
   my $tag = $feature->source_tag;
   return undef if $tag eq '';
   $tag;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/graded_segments.pm bioperl-1.1/Bio/Graphics/Glyph/graded_segments.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/graded_segments.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/graded_segments.pm	Thu Sep 26 09:27:40 2002
@@ -1,9 +1,11 @@
 package Bio::Graphics::Glyph::graded_segments;
+#$Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 
 use strict;
-use Bio::Graphics::Glyph::generic;
-use vars '@ISA';
-@ISA = 'Bio::Graphics::Glyph::generic';
+use Bio::Graphics::Glyph::segments;
+use vars '@ISA','$VERSION';
+@ISA = 'Bio::Graphics::Glyph::segments';
+$VERSION = 1.01;
 
 # override draw method to calculate the min and max values for the components
 sub draw {
@@ -13,6 +15,7 @@
   # handle both das-style and Bio::SeqFeatureI style,
   # which use different names for subparts.
   my @parts = $self->parts;
+  @parts    = $self if !@parts && $self->level == 0;
   return $self->SUPER::draw(@_) unless @parts;
 
   # figure out the colors
@@ -43,15 +46,17 @@
       $part->{partcolor} = $fill;
       next;
     }
-    my($r,$g,$b) = map {(255 - (255-$_) * (($s-$min_score)/$span))}
-			($red,$green,$blue);
+    my($r,$g,$b) = map { 255 - (255-$_) * min(max( ($s-$min_score)/$span, 0), 1) } 
+      ($red,$green,$blue);
     my $idx      = $self->panel->translate_color($r,$g,$b);
     $part->{partcolor} = $idx;
   }
-
   $self->SUPER::draw(@_);
 }
 
+sub min { $_[0] < $_[1] ? $_[0] : $_[1] }
+sub max { $_[0] > $_[1] ? $_[0] : $_[1] }
+
 sub subseq {
   my $class = shift;
   my $feature = shift;
@@ -69,7 +74,6 @@
   # two segments, at pixels 0->50, 60->80
   my $offset = $self->panel->offset;
 
-
   my $feature =
     Bio::Graphics::Feature->new(
 				-segments=>[ [ 0*$scale +$offset,20*$scale+$offset],
@@ -96,31 +100,6 @@
   my $color = $self->{partcolor};
   my @rect = $self->bounds(@_);
   $self->filled_box($gd,@rect,$color,$color);
-}
-
-# group sets connector to 'solid'
-sub connector {
-  my $self = shift;
-  return $self->SUPER::connector(@_) if $self->all_callbacks;
-  return 'solid';
-}
-# group sets connector to 'solid'
-sub bump {
-  my $self = shift;
-  return $self->SUPER::bump(@_) if $self->all_callbacks;
-  return 0;
-}
-# turn off labels
-sub label {
-  my $self = shift;
-  return unless (my @a = $self->feature->sub_SeqFeature) > 0;
-  $self->SUPER::label(@_);
-}
-# turn off and descriptions
-sub description {
-  my $self = shift;
-  return unless (my @a = $self->feature->sub_SeqFeature) > 0;
-  $self->SUPER::description(@_);
 }
 
 1;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/group.pm bioperl-1.1/Bio/Graphics/Glyph/group.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/group.pm	Tue Jun 25 08:36:00 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/group.pm	Fri Oct  4 20:18:24 2002
@@ -10,7 +10,7 @@
   my $self = shift;
   my $super = $self->SUPER::connector(@_);
   return $super if $self->all_callbacks;
-  return 'dashed' unless defined($super) && $super eq 'none';
+  return 'dashed' unless defined($super) && ($super eq 'none' or !$super);
 }
 
 # we don't label group (yet)
@@ -29,8 +29,8 @@
 sub bump {
   my $bump = shift->SUPER::bump(@_);
   return unless defined $bump;
-  return 1  if $bump > 1;
-  return -1 if $bump < 1;
+  return 1  if $bump >  1;
+  return -1 if $bump < -1;
   return $bump;
 }
 
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/heterogeneous_segments.pm bioperl-1.1/Bio/Graphics/Glyph/heterogeneous_segments.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/heterogeneous_segments.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/heterogeneous_segments.pm	Fri Aug 30 07:57:55 2002
@@ -7,6 +7,8 @@
 # -waba_weak   => 'red'
 # -waba_coding => 'green' 
 
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+
 use strict;
 use Bio::Graphics::Glyph::graded_segments;
 use vars '@ISA';
@@ -20,6 +22,7 @@
   # handle both das-style and Bio::SeqFeatureI style,
   # which use different names for subparts.
   my @parts = $self->parts;
+  @parts    = $self if !@parts && $self->level == 0;
   return $self->SUPER::draw(@_) unless @parts;
 
   # figure out the colors
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/segmented_keyglyph.pm bioperl-1.1/Bio/Graphics/Glyph/segmented_keyglyph.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/segmented_keyglyph.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/segmented_keyglyph.pm	Tue Jul  9 21:25:00 2002
@@ -1,6 +1,6 @@
 package Bio::Graphics::Glyph::segmented_keyglyph;
 
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 # Don't use this package.  It's just for inheriting the segmented glyph in the panel key.
 
 use strict;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/segments.pm bioperl-1.1/Bio/Graphics/Glyph/segments.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/segments.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/segments.pm	Fri Oct  4 20:18:24 2002
@@ -1,4 +1,5 @@
 package Bio::Graphics::Glyph::segments;
+#$Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 
 use strict;
 use Bio::Location::Simple;
@@ -14,7 +15,7 @@
 sub connector {
   my $self = shift;
   return $self->SUPER::connector(@_) if $self->all_callbacks;
-  return $self->SUPER::connector(@_) || 'solid';
+  return ($self->SUPER::connector(@_) || 'solid');
 }
 # never allow our components to bump
 sub bump {
@@ -22,18 +23,6 @@
   return $self->SUPER::bump(@_) if $self->all_callbacks;
   return 0;
 }
-sub label {
-  my $self = shift;
-  return $self->SUPER::label(@_) if $self->all_callbacks;
-  return unless $self->{level} == 0;
-  return $self->SUPER::label(@_);
-}
-sub description {
-  my $self = shift;
-  return $self->SUPER::description(@_) if $self->all_callbacks;
-  return unless $self->{level} == 0;
-  return $self->SUPER::description(@_);
-}
 
 # Override _subseq() method to make it appear that a top-level feature that
 # has no subfeatures appears as a feature that has a single subfeature.
@@ -49,7 +38,8 @@
   if ($self->level == 0 && !@subseq && !eval{$feature->compound}) {
     my($start,$end) = ($feature->start,$feature->end);
     ($start,$end) = ($end,$start) if $start > $end; # to keep Bio::Location::Simple from bitching
-    return Bio::Location::Simple->new(-start=>$start,-end=>$end);
+    #    return Bio::Location::Simple->new(-start=>$start,-end=>$end);
+    return $self->feature;
   } else {
     return;
   }
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/transcript.pm bioperl-1.1/Bio/Graphics/Glyph/transcript.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/transcript.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/transcript.pm	Tue Jul  9 21:25:00 2002
@@ -1,5 +1,5 @@
 package Bio::Graphics::Glyph::transcript;
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 
 use strict;
 use Bio::Graphics::Glyph::segments;
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/transcript2.pm bioperl-1.1/Bio/Graphics/Glyph/transcript2.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/transcript2.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/transcript2.pm	Thu Sep 26 21:36:52 2002
@@ -1,6 +1,6 @@
 package Bio::Graphics::Glyph::transcript2;
 
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 
 use strict;
 use Bio::Graphics::Glyph::transcript;
@@ -13,7 +13,7 @@
 sub pad_left  {
   my $self = shift;
   my $pad = $self->Bio::Graphics::Glyph::generic::pad_left;
-  return $pad unless $self->feature->strand < 0;
+  return $pad unless ($self->feature->strand||0) < 0;  #uninitialized var warning
   my $first = ($self->parts)[0] || $self;
   my @rect  = $first->bounds();
   my $width = abs($rect[2] - $rect[0]);
@@ -47,7 +47,7 @@
     my $f = $self->feature;
 
     if ($f->strand < 0
-	&& 
+	&&
 	$self->{partno} == 0) { # first exon, minus strand transcript
       $self->filled_arrow($gd,-1,@rect);
     } elsif ($f->strand >= 0
@@ -76,7 +76,7 @@
 
   my $part;
   if (my @parts  = $self->parts) {
-    $part   = $self->feature->strand > 0 ? $parts[-1] : $parts[0];
+    $part   = $self->feature->strand >= 0 ? $parts[-1] : $parts[0];
   } else {
     # no parts -- so draw an intron spanning whole thing
     my($x1,$y1,$x2,$y2) = $self->bounds(0,0);
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/translation.pm bioperl-1.1/Bio/Graphics/Glyph/translation.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/translation.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/translation.pm	Mon Aug 26 14:07:19 2002
@@ -100,7 +100,7 @@
 sub draw_frame {
   my $self = shift;
   my ($feature,$strand,$base_offset,$phase,$gd,$x1,$y1,$x2,$y2) = @_;
-  my ($seq,$pos) = $strand < 0 ? ($feature->revcom,$feature->end) 
+  my ($seq,$pos) = $strand < 0 ? ($feature->revcom,$feature->end)
                                : ($feature,$feature->start);
   my ($frame,$offset) = frame_and_offset($pos,$strand,$phase);
   ($strand >= 0 ? $x1 : $x2) += $self->pixels_per_base * $offset;
@@ -136,6 +136,8 @@
     my $x = $strand > 0 
       ? $x1 + 3 * $i * $pixels_per_base
       : $x2 - 3 * $i * $pixels_per_base;
+    next if $x+1 < $x1;
+    last if $x > $x2;
     $gd->char($font,$x,$y1,$residues[$i],$color);
   }
 }
@@ -156,6 +158,8 @@
       my $pos = $strand > 0 
 	? $x1 + $stop * $pixels_per_base
         : $x2 - $stop * $pixels_per_base;
+      next if $pos+1 < $x1;
+      last if $pos   > $x2;
       $gd->line($pos,$y1-2,$pos,$y1+2,$color);
     }
   }
@@ -169,6 +173,9 @@
       my $pos = $strand > 0 
 	? $x1 + $start * $pixels_per_base
         : $x2 - $start * $pixels_per_base;
+      next if $pos+1 < $x1;
+      last if $pos   > $x2;
+
       # little arrowheads at the start codons
       $strand > 0 ? $self->arrowhead($gd,$pos-$arrowhead_height,$y1,
 				     $arrowhead_height,+1)
@@ -195,16 +202,17 @@
 
 sub make_key_feature {
   my $self = shift;
+  my @gatc = qw(g a t c);
   my $offset = $self->panel->offset;
   my $scale = 1/$self->scale;  # base pairs/pixel
   my $start = $offset;
   my $stop  = $offset + 100 * $scale;
+  my $seq   = join('',map{$gatc[rand 4]} (1..500));
   my $feature =
     Bio::Graphics::Feature->new(-start=> $start,
-				-stop => $stop,
-				-seq  => join('',map{qw(g a t c)[rand 4]} ($start..$stop)),
-				-name => $self->option('key'),
-				-strand => '+1',
+				-end  => $stop,
+				-seq  => $seq,
+				-name => $self->option('key')
 			       );
   $feature;
 }
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph/triangle.pm bioperl-1.1/Bio/Graphics/Glyph/triangle.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph/triangle.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Glyph/triangle.pm	Tue Jul 23 18:07:25 2002
@@ -2,8 +2,9 @@
 # DAS-compatible package to use for drawing a triangle
 
 use strict;
-use vars '@ISA';
+use vars '@ISA','$VERSION';
 @ISA = 'Bio::Graphics::Glyph::generic';
+$VERSION = 1.02;
 
 sub pad_left {
   my $self = shift;
@@ -32,7 +33,7 @@
   my $xmid = ($x1+$x2)/2;
   my $ymid = ($y1+$y2)/2;
 
-  my ($vx1,$vy1,$vx2,$vy2,$vx3,$vy3) = undef;
+  my ($vx1,$vy1,$vx2,$vy2,$vx3,$vy3);
 
   #make an equilateral
   my ($p,$q) = ($self->option('height'),($x2-$x1)/2);
@@ -42,8 +43,8 @@
     $y1 = $ymid - $q; $y2 = $ymid + $q;
   }
 
-  if   ($orient eq 'S'){$vx1=$xmid-$q;$vy1=$y1;$vx2=$xmid+$q;$vy2=$y1;$vx3=$xmid;$vy3=$y2;}
-  elsif($orient eq 'N'){$vx1=$xmid-$q;$vy1=$y2;$vx2=$xmid+$q;$vy2=$y2;$vx3=$xmid;$vy3=$y1;}
+  if   ($orient eq 'S'){$vx1=$x1;$vy1=$y1;$vx2=$x2;$vy2=$y1;$vx3=$xmid;$vy3=$y2;}
+  elsif($orient eq 'N'){$vx1=$x1;$vy1=$y2;$vx2=$x2;$vy2=$y2;$vx3=$xmid;$vy3=$y1;}
   elsif($orient eq 'W'){$vx1=$x2;$vy1=$y1;$vx2=$x2;$vy2=$y2;$vx3=$x2-$p;$vy3=$ymid;}
   elsif($orient eq 'E'){$vx1=$x1;$vy1=$y1;$vx2=$x1;$vy2=$y2;$vx3=$x1+$p;$vy3=$ymid;}
 
diff -Naur bioperl-1.0.2/Bio/Graphics/Glyph.pm bioperl-1.1/Bio/Graphics/Glyph.pm
--- bioperl-1.0.2/Bio/Graphics/Glyph.pm	Wed Jul  3 22:55:17 2002
+++ bioperl-1.1/Bio/Graphics/Glyph.pm	Fri Oct  4 20:18:24 2002
@@ -9,6 +9,13 @@
 
 my %LAYOUT_COUNT;
 
+# the CM1 and CM2 constants control the size of the hash used to
+# detect collisions.
+use constant CM1 => 200; # big bin, x axis
+use constant CM2 => 50;  # big bin, y axis
+use constant CM3 => 50;  # small bin, x axis
+use constant CM4 => 50;  # small bin, y axis
+
 # a bumpable graphical object that has bumpable graphical subparts
 
 # args:  -feature => $feature_object (may contain subsequences)
@@ -35,7 +42,10 @@
   if (@subfeatures) {
 
     # dynamic glyph resolution
-    @subglyphs = sort { $a->left  <=> $b->left }  $factory->make_glyph($level+1,@subfeatures);
+    @subglyphs = map { $_->[0] }
+    sort { $a->[1] <=> $b->[1] }
+    map { [$_, $_->left ] } 
+    $factory->make_glyph($level+1,@subfeatures);
 
     $self->{parts}   = \@subglyphs;
   }
@@ -44,7 +54,7 @@
   if (defined $start && defined $stop) {
     ($start,$stop) = ($stop,$start) if $start > $stop;  # sheer paranoia
     # the +1 here is critical for allowing features to meet nicely at nucleotide resolution
-    my ($left,$right) = $factory->map_pt($start,$stop+1); 
+    my ($left,$right) = $factory->map_pt($start,$stop+1);
     $self->{left}    = $left;
     $self->{width}   = $right - $left + 1;
   }
@@ -56,18 +66,20 @@
       $self->{width}   = $w if !defined($self->{width}) || $w > $self->{width};
   }
 
+  $self->{point} = $arg{-point} ? $self->height : undef;
   #Handle glyphs that don't actually fill their space, but merely mark a point.
   #They need to have their collision bounds altered.  We will (for now)
   #hard code them to be in the center of their feature.
-  $self->{point} = $arg{-point} ? $self->height : undef;
-  if($self->option('point')){
-    my ($left,$right) = $factory->map_pt($self->start,$self->stop);
-    my $center = int(($left+$right)/2);
-
-    $self->{width} = $self->height;
-    $self->{left}  = $center - ($self->{width});
-    $self->{right} = $center + ($self->{width});
-  }
+# note: this didn't actually seem to work properly, all features were aligned on
+# their right edges.  It works to do it in individual point-like glyphs such as triangle.
+#  if($self->option('point')){
+#    my ($left,$right) = $factory->map_pt($self->start,$self->stop);
+#    my $center = int(($left+$right)/2 + 0.5);
+
+#    $self->{width} = $self->height;
+#    $self->{left}  = $center - ($self->{width});
+#    $self->{right} = $center + ($self->{width});
+#  }
 
   return $self;
 }
@@ -108,6 +120,17 @@
   return $self->{stop}
 }
 sub end     { shift->stop }
+sub length { my $self = shift; $self->stop - $self->start };
+sub score {
+    my $self = shift;
+    return $self->{score} if exists $self->{score};
+    return $self->{score} = ($self->{feature}->score || 0);
+}
+sub strand {
+    my $self = shift;
+    return $self->{strand} if exists $self->{strand};
+    return $self->{strand} = ($self->{feature}->strand || 0);
+}
 sub map_pt  { shift->{factory}->map_pt(@_) }
 sub map_no_trunc { shift->{factory}->map_no_trunc(@_) }
 
@@ -129,8 +152,8 @@
   my $self = shift;
   my @features = ref($_[0]) eq 'ARRAY' ? @{$_[0]} : @_;
   my $f    = Bio::Graphics::Feature->new(
-				     -segments=>\@features,
-				     -type => 'group'
+					 -segments=>\@features,
+					 -type => 'group'
 					);
   $self->add_feature($f);
 }
@@ -143,14 +166,10 @@
 }
 sub left {
   my $self = shift;
-#  return $self->{cache_left} if exists $self->{cache_left};
-#  $self->{cache_left} = $self->{left} - $self->pad_left;
   return $self->{left} - $self->pad_left;
 }
 sub right {
   my $self = shift;
-#  return $self->{cache_right} if exists $self->{cache_right};
-#  $self->{cache_right} = $self->left + $self->layout_width - 1;
   return $self->left + $self->layout_width - 1;
 }
 sub bottom {
@@ -175,7 +194,6 @@
 }
 sub layout_width {
   my $self = shift;
-#  return $self->{layout_width} ||= $self->width + $self->pad_left + $self->pad_right;
   return $self->width + $self->pad_left + $self->pad_right;
 }
 
@@ -204,13 +222,19 @@
 sub unfilled_box {
   my $self = shift;
   my $gd   = shift;
-  my ($x1,$y1,$x2,$y2) = @_;
+  my ($x1,$y1,$x2,$y2,$fg,$bg) = @_;
 
-  my $fg = $self->fgcolor;
-  my $bg = $self->bgcolor;
   my $linewidth = $self->option('linewidth') || 1;
 
+  unless ($fg) {
+      $fg ||= $self->fgcolor;
   $fg = $self->set_pen($linewidth,$fg) if $linewidth > 1;
+  }
+
+  unless ($bg) {
+      $bg ||= $self->bgcolor;
+      $bg = $self->set_pen($linewidth,$bg) if $linewidth > 1;
+  }
 
   # draw a box
   $gd->rectangle($x1,$y1,$x2,$y2,$fg);
@@ -219,8 +243,6 @@
   # the leftmost line
   my ($width) = $gd->getBounds;
 
-  $bg = $self->set_pen($linewidth,$bg) if $linewidth > 1;
-
   $gd->line($x1,$y1+$linewidth,$x1,$y2-$linewidth,$bg)
     if $x1 < $self->panel->pad_left;
 
@@ -237,12 +259,17 @@
   my @result;
 
   $self->layout;
+  my @parts = $self->parts;
+  @parts    = $self if !@parts && $self->option('box_subparts') && $self->level>0;
+
   for my $part ($self->parts) {
-    if (eval{$part->feature->primary_tag} eq 'group') {
-      push @result,$part->boxes($left+$self->left,$top+$self->top);
+    if (eval{$part->feature->primary_tag} eq 'group' or
+	($part->level == 0 && $self->option('box_subparts'))) {
+      push @result,$part->boxes($left+$self->left+$self->pad_left,$top+$self->top+$self->pad_top);
     } else {
       my ($x1,$y1,$x2,$y2) = $part->box;
-      push @result,[$part->feature,$x1,$top+$self->top+$y1,$x2,$top+$self->top+$y2];
+      push @result,[$part->feature,$x1,$top+$self->top+$self->pad_top+$y1,
+		                   $x2,$top+$self->top+$self->pad_top+$y2];
     }
   }
   return wantarray ? @result : \@result;
@@ -327,8 +354,6 @@
 #              0    no bumping
 #              +1   bump down
 #              -1   bump up
-#              +2   simple (hyper) bump up
-#              -2   simple (hyper) bump down
 sub bump {
   my $self = shift;
   return $self->option('bump');
@@ -374,15 +399,70 @@
   $self->color('connector_color') || $self->fgcolor;
 }
 
+sub layout_sort {
+
+    my $self = shift;
+    my $sortfunc;
+
+    my $opt = $self->option("sort_order");
+    if (!$opt) {
+       $sortfunc = eval 'sub { $a->left <=> $b->left }';
+    } elsif (ref $opt eq 'CODE') {
+       $sortfunc = $opt;
+    } elsif ($opt =~ /^sub\s+\{/o) {
+       $sortfunc = eval $opt;
+    } else {
+       # build $sortfunc for ourselves:
+       my @sortbys = split(/\s*\|\s*/o, $opt);
+       $sortfunc = 'sub { ';
+       my $sawleft = 0;
+
+       # not sure I can make this schwartzian transfored
+       for my $sortby (@sortbys) {
+           if ($sortby eq "left" || $sortby eq "default") {
+               $sortfunc .= '($a->left <=> $b->left) || ';
+               $sawleft++;
+           } elsif ($sortby eq "right") {
+               $sortfunc .= '($a->right <=> $b->right) || ';
+           } elsif ($sortby eq "low_score") {
+               $sortfunc .= '($a->score <=> $b->score) || ';
+           } elsif ($sortby eq "high_score") {
+               $sortfunc .= '($b->score <=> $a->score) || ';
+           } elsif ($sortby eq "longest") {
+               $sortfunc .= '(($b->length) <=> ($a->length)) || ';
+           } elsif ($sortby eq "shortest") {
+               $sortfunc .= '(($a->length) <=> ($b->length)) || ';
+           } elsif ($sortby eq "strand") {
+               $sortfunc .= '($b->strand <=> $a->strand) || ';
+           }
+       }
+       unless ($sawleft) {
+           $sortfunc .= ' ($a->left <=> $b->left) ';
+       } else {
+           $sortfunc .= ' 0';
+       }
+       $sortfunc .= '}';
+       $sortfunc = eval $sortfunc;
+    }
+
+    # would be nice to cache this somehow, but won't this override the
+    # settings for other tracks?
+    # $self->factory->set_option(sort_order => $sortfunc);
+
+    return sort $sortfunc @_;
+}
+
 # handle collision detection
 sub layout {
   my $self = shift;
   return $self->{layout_height} if exists $self->{layout_height};
 
-  (my @parts = $self->parts)
-    || return $self->{layout_height} = $self->height + $self->pad_top + $self->pad_bottom;
+  my @parts = $self->parts;
+  return $self->{layout_height}
+    = $self->height + $self->pad_top + $self->pad_bottom unless @parts;
 
   my $bump_direction = $self->bump;
+  my $bump_limit = $self->option('bump_limit') || -1;
 
   $_->layout foreach @parts;  # recursively lay out
 
@@ -396,58 +476,43 @@
     return $self->{layout_height} = $highest + $self->pad_top + $self->pad_bottom;
   }
 
-  if (abs($bump_direction) <= 1) {  # original bump algorithm
+  my (%bin1,%bin2);
+  for my $g ($self->layout_sort(@parts)) {
 
-    my %occupied; # format of occupied: key={top,bottom}, value=right
-    for my $g (sort { $a->left <=> $b->left } @parts) {
-
-      my $pos = 0;
-      my $left   = $g->left;
-      my $right  = $g->right;
-      my $height = $g->{layout_height};
-
-      while (1) {
-	# look for collisions
-	my $bottom = $pos + $height;
-
-	my $collision;
-	for my $key (keys %occupied) {
-	  my ($oldtop,$oldbottom) = split /,/,$key;
-	  my $oldright = $occupied{$key};
-	  next if $oldright+2  < $left;
-	  next if $oldbottom   < $pos;
-	  next if $oldtop      > $bottom;
-	  $collision = [$oldtop,$oldbottom,$oldright];
-	  last;
+    my $pos = 0;
+    my $bumplevel = 0;
+    my $left   = $g->left;
+    my $right  = $g->right;
+    my $height = $g->{layout_height};
+
+    while (1) {
+
+      # stop bumping if we've gone too far down
+      if ($bump_limit > 0 && $bumplevel++ >= $bump_limit) {
+	$g->{overbumped}++;  # this flag can be used to suppress label and description
+	foreach ($g->parts) {
+	  $_->{overbumped}++;
 	}
-	last unless $collision;
+	last;
+      }
 
-	if ($bump_direction > 0) {
-	  $pos += $collision->[1]-$collision->[0] + BUMP_SPACING;    # collision, so bump
+      # look for collisions
+      my $bottom = $pos + $height;
+      $self->collides(\%bin1,CM1,CM2,$left,$pos,$right,$bottom) or last;
+      my $collision = $self->collides(\%bin2,CM3,CM4,$left,$pos,$right,$bottom) or last;
 
-	} else {
-	  $pos -= BUMP_SPACING;
-	}
+      if ($bump_direction > 0) {
+	$pos += $collision->[3]-$collision->[1] + BUMP_SPACING;    # collision, so bump
 
+      } else {
+	$pos -= BUMP_SPACING;
       }
 
-      $g->move(0,$pos);
-      my $key = join ',',$g->top,$g->bottom;
-      $occupied{$key} = $right if !exists $occupied{$key} or $occupied{$key} < $right;
     }
-  }
 
-  else {  # abs(bump) >= 2 -- simple bump algorithm
-    my $pos = 0;
-    my $last;
-    for my $g (sort { $a->left <=> $b->left } @parts) {
-      next if !defined($last);
-      $pos += $bump_direction > 0 ? $last->{layout_height} + BUMP_SPACING 
-                                  : - ($g->{layout_height}+BUMP_SPACING);
-      $g->move(0,$pos);
-    } continue {
-      $last = $g;
-    }
+    $g->move(0,$pos);
+    $self->add_collision(\%bin1,CM1,CM2,$left,$g->top,$right,$g->bottom);
+    $self->add_collision(\%bin2,CM3,CM4,$left,$g->top,$right,$g->bottom);
   }
 
   # If -1 bumping was allowed, then normalize so that the top glyph is at zero
@@ -469,6 +534,48 @@
   return $self->{layout_height} = $self->pad_bottom + $self->pad_top + $bottom - $self->top  + 1;
 }
 
+# the $%occupied structure is a hash of {left,top} = [left,top,right,bottom]
+sub collides {
+  my $self = shift;
+  my ($occupied,$cm1,$cm2,$left,$top,$right,$bottom) = @_;
+  my @keys = $self->_collision_keys($cm1,$cm2,$left,$top,$right,$bottom);
+  my $collides = 0;
+  for my $k (@keys) {
+    next unless exists $occupied->{$k};
+    for my $bounds (@{$occupied->{$k}}) {
+      my ($l,$t,$r,$b) = @$bounds;
+      next unless $right >= $l and $left <= $r and $bottom >= $t and $top <= $b;
+      $collides = $bounds;
+      last;
+    }
+  }
+  $collides;
+}
+
+sub add_collision {
+  my $self = shift;
+  my ($occupied,$cm1,$cm2,$left,$top,$right,$bottom) = @_;
+  my $value = [$left,$top,$right+2,$bottom];
+  my @keys = $self->_collision_keys($cm1,$cm2,@$value);
+  push @{$occupied->{$_}},$value foreach @keys;
+}
+
+sub _collision_keys {
+  my $self = shift;
+  my ($binx,$biny,$left,$top,$right,$bottom) = @_;
+  my @keys;
+  my $bin_left   = int($left/$binx);
+  my $bin_right  = int($right/$binx);
+  my $bin_top    = int($top/$biny);
+  my $bin_bottom = int($bottom/$biny);
+  for (my $x=$bin_left;$x<=$bin_right; $x++) {
+    for (my $y=$bin_top;$y<=$bin_bottom; $y++) {
+      push @keys,join(',',$x,$y);
+    }
+  }
+  @keys;
+}
+
 sub draw {
   my $self = shift;
   my $gd = shift;
@@ -509,6 +616,7 @@
 
 sub draw_connectors {
   my $self = shift;
+  return if $self->{overbumped};
   my $gd = shift;
   my ($dx,$dy) = @_;
   my @parts = sort { $a->left <=> $b->left } $self->parts;
@@ -520,9 +628,9 @@
   if (@parts) {
     my($x1,$y1,$x2,$y2) = $self->bounds(0,0);
     my($xl,$xt,$xr,$xb) = $parts[0]->bounds;
-    $self->_connector($gd,$dx,$dy,$x1,$xt,$x1,$xb,$xl,$xt,$xr,$xb);
+    $self->_connector($gd,$dx,$dy,$x1,$xt,$x1,$xb,$xl,$xt,$xr,$xb)      if $x1 <= $self->panel->left;
     my ($xl2,$xt2,$xr2,$xb2) = $parts[-1]->bounds;
-    $self->_connector($gd,$dx,$dy,$parts[-1]->bounds,$x2,$xt2,$x2,$xb2) if $xr2 >= $xr;
+    $self->_connector($gd,$dx,$dy,$parts[-1]->bounds,$x2,$xt2,$x2,$xb2) if $x2 >= $self->panel->right;
   }
 
 }
@@ -746,7 +854,7 @@
   my $panel = $self->panel;
   return unless $x2 >= $panel->left and $x1 <= $panel->right;
 
-  if ($self->option('strand_arrow')) {
+  if ($self->option('strand_arrow') || $self->option('stranded')) {
     $self->filled_arrow($gd,$self->feature->strand,
 			$x1, $y1,
 			$x2, $y2)
@@ -786,7 +894,8 @@
   my $self = shift;
   my $feature = $self->make_key_feature;
   my $factory = $self->factory->clone;
-  $factory->set_option(label => 1);
+  $factory->set_option(label       => 1);
+  $factory->set_option(description => 0);
   $factory->set_option(bump  => 0);
   $factory->set_option(connector  => 'solid');
   return $factory->make_glyph(0,$feature);
@@ -1138,6 +1247,10 @@
 
   -description  Whether to draw a description  0 (false)
 
+  -sort_order   Specify layout sort order      "default"
+
+  -bump_limit   Maximum number of levels to bump 0 (unlimited)
+
 For glyphs that consist of multiple segments, the -connector option
 controls what's drawn between the segments.  The default is 0 (no
 connector).  Options include "hat", an upward-angling conector,
@@ -1147,16 +1260,20 @@
 
 The label is printed above the glyph.  You may pass an anonymous
 subroutine to -label, in which case the subroutine will be invoked
-with the feature as its single argument.  The subroutine must return a
-string to render as the label.  Otherwise, you may return the number
-"1", in which case the feature's info(), seqname() and primary_tag()
-methods will be called (in that order) until a suitable name is found.
+with the feature as its single argument.  and is expected to return
+the string to use as the description.  If you provide the numeric
+value "1" to -description, the description will be read off the
+feature's seqname(), info() and primary_tag() methods will be called
+until a suitable name is found.  To create a label with the
+text "1", pass the string "1 ".  (A 1 followed by a space).
 
 The description is printed below the glyph.  You may pass an anonymous
-subroutine to -label, in which case the subroutine will be invoked
-with the feature as its single argument.  The subroutine must return a
-string to render as the label.  Otherwise, you may return the number
-"1", in which case the feature's source_tag() method will be invoked.
+subroutine to -description, in which case the subroutine will be
+invoked with the feature as its single argument and is expected to
+return the string to use as the description.  If you provide the
+numeric value "1" to -description, the description will be read off
+the feature's source_tag() method.  To create a description with the
+text "1", pass the string "1 ".  (A 1 followed by a space).
 
 In the case of ACEDB Ace::Sequence feature objects, the feature's
 info(), Brief_identification() and Locus() methods will be called to
@@ -1165,6 +1282,42 @@
 The -strand_arrow option, if true, requests that the glyph indicate
 which strand it is on, usually by drawing an arrowhead.  Not all
 glyphs can respond appropriately to this request.
+
+By default, features are drawn with a layout based only on the
+position of the feature, assuring a maximal "packing" of the glyphs
+when bumped.  In some cases, however, it makes sense to display the
+glyphs sorted by score or some other comparison, e.g. such that more
+"important" features are nearer the top of the display, stacked above
+less important features.  The -sort_order option allows a few
+different built-in values for changing the default sort order (which
+is by "left" position): "low_score" (or "high_score") will cause
+features to be sorted from lowest to highest score (or vice versa).
+"left" (or "default") and "right" values will cause features to be
+sorted by their position in the sequence.  "longer" (or "shorter")
+will cause the longest (or shortest) features to be sorted first, and
+"strand" will cause the features to be sorted by strand: "+1"
+(forward) then "0" (unknown, or NA) then "-1" (reverse).
+
+In all cases, the "left" position will be used to break any ties.  To
+break ties using another field, options may be strung together using a
+"|" character; e.g. "strand|low_score|right" would cause the features
+to be sorted first by strand, then score (lowest to highest), then by
+"right" position in the sequence.  Finally, a subroutine coderef can
+be provided, which should expect to receive two feature objects (via
+the special sort variables $a and $b), and should return -1, 0 or 1
+(see Perl's sort() function for more information); this subroutine
+will be used without further modification for sorting.  For example,
+to sort a set of database search hits by bits (stored in the features'
+"score" fields), scaled by the log of the alignment length (with
+"left" position breaking any ties):
+
+  sort_order = sub { ( $b->score/log($b->length)
+                                      <=>
+                       $a->score/log($a->length) )
+                                      ||
+                     ( $a->start <=> $b->start )
+                   }
+
 
 =head1 SUBCLASSING Bio::Graphics::Glyph
 
diff -Naur bioperl-1.0.2/Bio/Graphics/Panel.pm bioperl-1.1/Bio/Graphics/Panel.pm
--- bioperl-1.0.2/Bio/Graphics/Panel.pm	Tue Jul  9 21:25:09 2002
+++ bioperl-1.1/Bio/Graphics/Panel.pm	Fri Oct  4 20:18:24 2002
@@ -7,7 +7,7 @@
 use GD;
 use vars '$VERSION';
 
-$VERSION = '1.01';
+$VERSION = 1.04;
 
 use constant KEYLABELFONT => gdMediumBoldFont;
 use constant KEYSPACING   => 5; # extra space between key columns
@@ -16,6 +16,7 @@
 use constant KEYSTYLE     => 'bottom';
 use constant KEYALIGN     => 'left';
 use constant GRIDCOLOR    => 'lightcyan';
+use constant MISSING_TRACK_COLOR =>'gray';
 
 my %COLORS;  # translation table for symbolic color names to RGB triple
 
@@ -38,7 +39,8 @@
   my $keyalign = $options{-key_align} || KEYALIGN;
   my $allcallbacks = $options{-all_callbacks} || 0;
   my $gridcolor    = $options{-gridcolor} || GRIDCOLOR;
-  my $grid         = $options{-grid} || 0;
+  my $grid         = $options{-grid}       || 0;
+  my $empty_track_style   = $options{-empty_tracks} || 'key';
 
   $offset   ||= $options{-segment}->start-1 if $options{-segment};
   $length   ||= $options{-segment}->length  if $options{-segment};
@@ -67,6 +69,7 @@
 		key_style => $keystyle,
 		key_align => $keyalign,
 		all_callbacks => $allcallbacks,
+		empty_track_style    => $empty_track_style,
 	       },$class;
 }
 
@@ -95,13 +98,32 @@
   $g;
 }
 
+# values of empty_track_style are:
+#    "suppress" -- suppress empty tracks entirely (default)
+#    "key"      -- show just the key in "between" mode
+#    "line"     -- draw a thin grey line
+#    "dashed"   -- draw a dashed line
+sub empty_track_style {
+  my $self = shift;
+  my $g = $self->{empty_track_style};
+  $self->{empty_track_style} = shift if @_;
+  $g;
+}
+
+sub key_style {
+  my $self = shift;
+  my $g = $self->{key_style};
+  $self->{key_style} = shift if @_;
+  $g;
+}
+
 # numerous direct calls into array used here for performance considerations
 sub map_pt {
   my $self   = shift;
   my $offset = $self->{offset};
   my $scale  = $self->{scale} || $self->scale;
-  my $pl = $self->{pad_left};
-  my $pr = $self->{width} - $self->{pad_right};
+  my $pl     = $self->{pad_left};
+  my $pr     = $self->{width} - $self->{pad_right};
   my @result;
   foreach (@_) {
     my $val = int (0.5 + $pl + ($_-$offset-1) * $scale);
@@ -115,9 +137,8 @@
 sub map_no_trunc {
   my $self   = shift;
   my $offset = $self->{offset};
-  my $scale  = $self->{scale} || $self->scale;
+  my $scale  = $self->scale;
   my $pl = $self->{pad_left};
-  my $pr = $self->{width} - $self->{pad_right};
   my @result;
   foreach (@_) {
     my $val = int (0.5 + $pl + ($_-$offset-1) * $scale);
@@ -149,7 +170,7 @@
 }
 sub right {
   my $self = shift;
-  $self->width - $self->pad_left;
+  $self->width - $self->pad_right;
 }
 
 sub spacing {
@@ -284,24 +305,41 @@
 
 sub height {
   my $self = shift;
-  my $spacing    = $self->spacing;
-  my $key_height = $self->format_key;
+  my $spacing           = $self->spacing;
+  my $key_height        = $self->format_key;
+  my $empty_track_style = $self->empty_track_style;
+  my $key_style         = $self->key_style;
+  my $bottom_key        = $key_style eq 'bottom';
+  my $between_key       = $key_style eq 'between';
+  my $draw_empty        = $empty_track_style =~ /^(line|dashed)$/;
+  my $keyheight         = $self->{key_font}->height;
   my $height = 0;
-  foreach (@{$self->{tracks}}) {
-    next unless $_->parts;
-    $height += $_->layout_height + $spacing;
+  for my $track (@{$self->{tracks}}) {
+    my $draw_between =  $between_key && $track->option('key');
+    my $has_parts = $track->parts;
+    next if !$has_parts && ($empty_track_style eq 'suppress'
+		        or  $empty_track_style eq 'key' && $bottom_key);
+    $height += $keyheight if $draw_between;
+    $height += $self->spacing;
+    $height += $track->layout_height;
   }
+
+  # get rid of spacing under last track
+  $height -= $self->spacing unless $bottom_key;
   return $height + $key_height + $self->pad_top + $self->pad_bottom;
 }
 
 sub gd {
   my $self = shift;
 
+  local $^W = 0;  # can't track down the uninitialized variable warning
+
   return $self->{gd} if $self->{gd};
 
   my $width  = $self->width;
   my $height = $self->height;
 
+
   my $gd = GD::Image->new($width,$height);
   my %translation_table;
   for my $name ('white','black',keys %COLORS) {
@@ -317,21 +355,27 @@
   my $pt = $self->pad_top;
   my $offset = $pt;
   my $keyheight   = $self->{key_font}->height;
+  my $bottom_key  = $self->{key_style} eq 'bottom';
   my $between_key = $self->{key_style} eq 'between';
+  my $left_key    = $self->{key_style} eq 'left';
+  my $right_key   = $self->{key_style} eq 'right';
+  my $empty_track_style = $self->empty_track_style;
   my $spacing = $self->spacing;
 
   # we draw in two steps, once for background of tracks, and once for
   # the contents.  This allows the grid to sit on top of the track background.
   for my $track (@{$self->{tracks}}) {
-    next unless $track->parts;
+    my $draw_between = $between_key && $track->option('key');
+    next if !$track->parts && ($empty_track_style eq 'suppress'
+			   or  $empty_track_style eq 'key' && $bottom_key);
     $gd->filledRectangle($pl,
 			 $offset,
 			 $width-$self->pad_right,
 			 $offset+$track->layout_height
-			 + ($self->{key_style} eq 'between' ? $self->{key_font}->height : 0),
+			 + ($between_key ? $self->{key_font}->height : 0),
 			 $track->tkcolor)
       if defined $track->tkcolor;
-    $offset += $keyheight if $between_key && $track->option('key');
+    $offset += $keyheight if $draw_between;
     $offset += $track->layout_height + $spacing;
   }
 
@@ -339,13 +383,30 @@
 
   $offset = $pt;
   for my $track (@{$self->{tracks}}) {
-    next unless $track->parts;
-    $offset += $self->draw_between_key($gd,$track,$offset) if $between_key && $track->option('key');
+    my $draw_between = $between_key && $track->option('key');
+    my $has_parts = $track->parts;
+    next if !$has_parts && ($empty_track_style eq 'suppress'
+			or  $empty_track_style eq 'key' && $bottom_key);
+
+    if ($draw_between) {
+      $offset += $self->draw_between_key($gd,$track,$offset);
+    }
+
+    elsif ($self->{key_style} =~ /^(left|right)$/) {
+      $self->draw_side_key($gd,$track,$offset,$self->{key_style});
+    }
+
+    $self->draw_empty($gd,$offset,$empty_track_style)
+      if !$has_parts && $empty_track_style=~/^(line|dashed)$/;
+
     $track->draw($gd,0,$offset,0,1);
+    $self->track_position($track,$offset);
     $offset += $track->layout_height + $spacing;
   }
 
+
   $self->draw_bottom_key($gd,$pl,$offset) if $self->{key_style} eq 'bottom';
+
   return $self->{gd} = $gd;
 }
 
@@ -353,19 +414,36 @@
   my $self = shift;
   my @boxes;
   my $offset = 0;
+
   my $pl = $self->pad_left;
   my $pt = $self->pad_top;
-  my $between = $self->{key_style} eq 'between';
+  my $between_key       = $self->{key_style} eq 'between';
+  my $bottom_key        = $self->{key_style} eq 'bottom';
+  my $empty_track_style = $self->empty_track_style;
+  my $keyheight         = $self->{key_font}->height;
+  my $spacing = $self->spacing;
+
   for my $track (@{$self->{tracks}}) {
-    next unless $track->parts;
-    $offset += $self->{key_font}->height if $between && $track->option('key');
+    my $draw_between =  $between_key && $track->option('key');
+    next if !$track->parts && ($empty_track_style eq 'suppress'
+			    or  $empty_track_style eq 'key' && $bottom_key);
+    $offset += $keyheight if $draw_between;
     my $boxes = $track->boxes(0,$offset+$pt);
+    $self->track_position($track,$offset);
     push @boxes,@$boxes;
     $offset += $track->layout_height + $self->spacing;
   }
   return wantarray ? @boxes : \@boxes;
 }
 
+sub track_position {
+  my $self  = shift;
+  my $track = shift;
+  my $d = $self->{_track_position}{$track};
+  $self->{_track_position}{$track} = shift if @_;
+  $d;
+}
+
 # draw the keys -- between
 sub draw_between_key {
   my $self   = shift;
@@ -378,6 +456,16 @@
   return $self->{key_font}->height;
 }
 
+# draw the keys -- left or right side
+sub draw_side_key {
+  my $self   = shift;
+  my ($gd,$track,$offset,$side) = @_;
+  my $key = $track->option('key') or return;
+  my $pos = $side eq 'left' ? $self->pad_left - $self->{key_font}->width * CORE::length($key)-3
+                            : $self->width - $self->pad_right+3;
+  $gd->string($self->{key_font},$pos,$offset,$key,1);
+}
+
 # draw the keys -- bottom
 sub draw_bottom_key {
   my $self = shift;
@@ -395,13 +483,21 @@
 # Format the key section, and return its height
 sub format_key {
   my $self = shift;
+  return 0 unless $self->key_style eq 'bottom';
 
   return $self->{key_height} if defined $self->{key_height};
 
-  if ($self->{key_style} eq 'between') {
-    my @key_tracks = grep {$_->option('key')} @{$self->{tracks}};
+  my $suppress = $self->{empty_track_style} eq 'suppress';
+  my $between  = $self->{key_style}         eq 'between';
+
+  if ($between) {
+    my @key_tracks = $suppress
+      ? grep {$_->option('key') && $_->parts} @{$self->{tracks}}
+      : grep {$_->option('key')} @{$self->{tracks}};
     return $self->{key_height} = @key_tracks * $self->{key_font}->height;
-  } elsif ($self->{key_style} eq 'bottom') {
+  }
+
+  elsif ($self->{key_style} eq 'bottom') {
 
     my ($height,$width) = (0,0);
     my %tracks;
@@ -410,7 +506,9 @@
     # determine how many glyphs become part of the key
     # and their max size
     for my $track (@{$self->{tracks}}) {
+
       next unless $track->option('key');
+      next if $suppress && !$track->parts;
 
       my $glyph;
       if (my @parts = $track->parts) {
@@ -424,12 +522,14 @@
       }
       next unless $glyph;
 
+
       $tracks{$track} = $glyph;
       my ($h,$w) = ($glyph->layout_height,
 		    $glyph->layout_width);
       $height = $h if $h > $height;
       $width  = $w if $w > $width;
       push @glyphs,$glyph;
+
     }
 
     $width += $self->key_spacing;
@@ -475,6 +575,22 @@
   }
 }
 
+sub draw_empty {
+  my $self  = shift;
+  my ($gd,$offset,$style) = @_;
+  $offset  += $self->spacing/2;
+  my $left  = $self->pad_left;
+  my $right = $self->width-$self->pad_right;
+  my $color = $self->translate_color(MISSING_TRACK_COLOR);
+  if ($style eq 'dashed') {
+    $gd->setStyle($color,$color,gdTransparent,gdTransparent);
+    $gd->line($left,$offset,$right,$offset,gdStyled);
+  } else {
+    $gd->line($left,$offset,$right,$offset,$color);
+  }
+  $offset;
+}
+
 # draw a grid
 sub draw_grid {
   my $self = shift;
@@ -525,7 +641,7 @@
   return ($interval,$interval/10);
 }
 
-# reverse of translate(); given index, return rgb tripler
+# reverse of translate(); given index, return rgb triplet
 sub rgb {
   my $self = shift;
   my $idx  = shift;
@@ -938,8 +1054,17 @@
 
   -key_style   Whether to print key at bottom of     none
 	       panel ("bottom"), between each
-	       track ("between"), or not at all
-	       ("none").
+	       track ("between"), to the left of
+               each track ("left"), to the right
+               of each track ("right") or
+               not at all ("none").
+
+  -empty_tracks What to do when a track is empty.    suppress
+              Options are to suppress the track
+              completely ("suppress"), to show just
+              the key in "between" mode ("key"),
+              to draw a thin grey line ("line"),
+              or to draw a dashed line ("dashed").
 
   -all_callbacks Whether to invoke callbacks on      false
                the automatic "track" and "group"
@@ -956,6 +1081,7 @@
 
   -gridcolor   Color of the grid                     lightcyan
 
+
 Typically you will pass new() an object that implements the
 Bio::RangeI interface, providing a length() method, from which the
 panel will derive its scale.
@@ -965,6 +1091,16 @@
 
 new() will return undef in case of an error.
 
+Note that if you use the "left" or "right" key styles, you are
+responsible for allocating sufficient -pad_left or -pad_right room for
+the labels to appear.  The necessary width is the number of characters
+in the longest key times the font width (gdMediumBoldFont by default)
+plus 3 pixels of internal padding.  The simplest way to calculate this
+is to iterate over the possible track labels, find the largest one,
+and then to compute its width using the formula:
+
+  $width = gdMediumBoldFont->width * length($longest_key) +3;
+
 =back
 
 =head2 OBJECT METHODS
@@ -1189,6 +1325,13 @@
 bottomright corners of the glyph, including any space allocated for
 labels.
 
+=item $position = $panel-E<gt>track_position($track)
+
+After calling gd() or boxes(), you can learn the resulting Y
+coordinate of a track by calling track_position() with the value
+returned by add_track() or unshift_track().  This will return undef if
+called before gd() or boxes() or with an invalid track.
+
 =back
 
 =head1 GLYPH OPTIONS
@@ -1221,6 +1364,11 @@
 
   -bump	      Bump direction		   0
 
+  -sort_order Specify layout sort order    "default"
+
+  -bump_limit Maximum number of levels     undef (unlimited)
+              to bump
+
   -connector  Type of connector to         none
 	      use to connect related
 	      features.  Options are
@@ -1234,6 +1382,11 @@
               callbacks for autogenerated
               "track" and "group" glyphs
 
+  -box_subparts Return boxes around feature          false
+               subparts rather than around the
+               feature itself.
+
+
 B<Specifying colors:> Colors can be expressed in either of two ways:
 as symbolic names such as "cyan" and as HTML-style #RRGGBB triples.
 The symbolic names are the 140 colors defined in the Netscape/Internet
@@ -1300,16 +1453,62 @@
 glyphs collide.  By default, they will simply overlap (value 0).  A
 -bump value of +1 will cause overlapping glyphs to bump downwards
 until there is room for them.  A -bump value of -1 will cause
-overlapping glyphs to bump upwards.  Bump values of +2 and -2
-implement a simpler bump algorithm in which each horizontal position
-is occupied by one and only one feature.  The bump argument can also
-be a code reference; see below.
+overlapping glyphs to bump upwards.  The bump argument can also be a
+code reference; see below.
 
 B<Keys:> The -key argument declares that the track is to be shown in a
 key appended to the bottom of the image.  The key contains a picture
 of a glyph and a label describing what the glyph means.  The label is
 specified in the argument to -key.
 
+B<box_subparts:> Ordinarily, when you invoke the boxes() methods to
+retrieve the rectangles surrounding the glyphs (which you need to do
+to create clickable imagemaps, for example), the rectangles will
+surround the top level features.  If you wish for the rectangles to
+surround subpieces of the glyph, such as the exons in a transcript,
+set box_subparts to a true value.
+
+B<sort_order>: By default, features are drawn with a layout based only on the
+position of the feature, assuring a maximal "packing" of the glyphs
+when bumped.  In some cases, however, it makes sense to display the
+glyphs sorted by score or some other comparison, e.g. such that more
+"important" features are nearer the top of the display, stacked above
+less important features.  The -sort_order option allows a few
+different built-in values for changing the default sort order (which
+is by "left" position): "low_score" (or "high_score") will cause
+features to be sorted from lowest to highest score (or vice versa).
+"left" (or "default") and "right" values will cause features to be
+sorted by their position in the sequence.  "longer" (or "shorter")
+will cause the longest (or shortest) features to be sorted first, and
+"strand" will cause the features to be sorted by strand: "+1"
+(forward) then "0" (unknown, or NA) then "-1" (reverse).
+
+In all cases, the "left" position will be used to break any ties.  To
+break ties using another field, options may be strung together using a
+"|" character; e.g. "strand|low_score|right" would cause the features
+to be sorted first by strand, then score (lowest to highest), then by
+"right" position in the sequence.  Finally, a subroutine coderef can
+be provided, which should expect to receive two feature objects (via
+the special sort variables $a and $b), and should return -1, 0 or 1
+(see Perl's sort() function for more information); this subroutine
+will be used without further modification for sorting.  For example,
+to sort a set of database search hits by bits (stored in the features'
+"score" fields), scaled by the log of the alignment length (with
+"left" position breaking any ties):
+
+  sort_order = sub { ( $b->score/log($b->length)
+                                      <=>
+                       $a->score/log($a->length) )
+                                      ||
+                     ( $a->start <=> $b->start )
+                   }
+
+B<bump_limit>: When bumping is chosen, colliding features will
+ordinarily move upward or downward without limit.  When many features
+collide, this can lead to excessively high images.  You can limit the
+number of levels that features will bump by providing a numeric
+B<bump_limit> option.
+
 =head2 Options and Callbacks
 
 Instead of providing a constant value to an option, you may subsitute
@@ -1328,9 +1527,22 @@
 C<$part_no>, an integer index indicating which subpart of the feature
 is being drawn, C<$total_parts>, an integer indicating the total
 number of subfeatures in the feature, and finally C<$glyph>, the Glyph
-object itself.  The latter fields are useful in the common case of
-treating the first or last subfeature differently, such as using a
-different color for the terminal exon of a gene.
+object itself.  The latter fields are useful in the case of treating
+the first or last subfeature differently, such as using a different
+color for the terminal exon of a gene.  Usually you will only need to
+examine the first argument.  This example shows a callback examining
+the score() attribute of a feature (possibly a BLAST hit) and return
+the color "red" for high-scoring features, and "green" for low-scoring
+features:
+
+  sub callback {
+     my $feature = shift;
+     if ($feature->score > 90) {
+       return 'red';
+     else {
+       return 'green';
+    }
+  }
 
 The callback should return a string indicating the desired value of
 the option.  To tell the panel to use the default value for this
diff -Naur bioperl-1.0.2/Bio/Graphics/Util.pm bioperl-1.1/Bio/Graphics/Util.pm
--- bioperl-1.0.2/Bio/Graphics/Util.pm	Thu Jul  4 10:40:00 2002
+++ bioperl-1.1/Bio/Graphics/Util.pm	Thu Jul  4 11:13:55 2002
@@ -1,6 +1,6 @@
 package Bio::Graphics::Util;
 
-# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
+# $Id: bioperl-102-1.1.patch,v 1.1 2002-10-07 00:22:01 lstein Exp $
 # Non object-oriented utilities used here-and-there in Bio::Graphics modules
 
 use strict;
diff -Naur bioperl-1.0.2/t/data/biographics/t1/version1.gif bioperl-1.1/t/data/biographics/t1/version1.gif
--- bioperl-1.0.2/t/data/biographics/t1/version1.gif	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t1/version1.gif	Fri Aug  2 18:51:05 2002
@@ -0,0 +1,34 @@
+GIF87aX     {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +                                                                                                                                                                                                                                                                                                                                                      ,    X   @ 4H@
+&Hq%b9q(+L	J$a2fK8o|&>9hQ5*MbF*RKR:U`*,Y5p>UWvu7nx
+K8pa&x\"+6L%k\P7/gQ@hO=vjGZ}@""Wq.z?^{/<#V}y>{h!Z7 >(U~:KE\~
+-^"$nW(,~97n5.I<&@)FFyqY8"TrEryQ'fN%^IpvqIs'ujfH&y'}zt6ZF*Vjfv*^Z2[% j+k~6lfv	Lkn.n+o+kV;U,V0S/J /,Wgl ,#(Z')0,4l33I>mtHr9tDC4S/muTtYKUcbthlwm{ovwj7[psy8VywdZ#.4_%h'^kNz_fz#>X>QOGo062b]~y.s?q9NxW7Nd(0y6z0TGHBKFK
+W"0U.8gjlN
+}Hqa)vDpPa(*l4dSao[bQhQ4Ha	H:lI;G8Yd)Bnq$d"DE62|"')Jb[&-IL:dP$VPvD)3Jahqe,U9TC Zrf-Q82)Lf.qR^6>t6	hMl4<'9L3<9}|5hP6|hK=Nj2,(/8BJh&J]*mNUSGR>7iGxd }Hu6$A=T{|O\TzZUIWB'hX#Wx`RT+`
+nMXXX.6ucWNe3aENjOYv6`g)aZSmMLso	m8Zwk"v.inqw6h]{u+.~T~<xTp3	Umo`	/.\7LQ1M+XU[v qFa4f)xFqKXG2A KK1ce*kMsfaN3#,h2fl~nWsK OwVs>:]/wFNyw2dz4<=e*I&4L9}^;[@]j9tIkKkzk"ZSuhW<vkBTU6Kla\Fl>JyMXmHoYeMu6Mn{7k$8-p'j~G|\xpC9;>3R"8!lywnKr_rg~<4>+O=B_H/:N>[}Qyt'Zt`g6*BuZ*ykXZ]|)u=n{g,z}O/wa{=/OX;u>?@~}M}yz?s/->[~at~wxDucyd\u
+w""Q}"*,.0284X6x8:<1yd>XFxHJL@'A)TXVxXo4Zb8d\xt8enpHgIiHTxzHsouX5zI&vj8$^xjX8oHITW"w~7;4'a<hx9VDZsOS}8g5gH8Qck(mu{n8gXl8cqmYhaH@lx	LWii(e{Hd|?"zi%y,09j$g3j!9Oh/isGE7?Y;MdF:hUW	<[T9	9ek]iLI-TVqy`rYt	SYyi9XlsO}	p_	F?X<w9y4XgyyiSiRI9lifKICc;9	h(5t	aib98Y 3Hpy	)ruU7weWu4ZUyRImd!J&@ir0*)}#*P:*3Z6JD=57*9ZNJGZQSQ*X:B#gf
+Md
+gZb]7pZF<sbMC9~!wA{OLlY"iT;$hxZqC"%x2	;ja@2?
+	<&ldEjUQ:.jzjv*:|mZZVx:o(yAt
+Q%[+l{kI8Y~&B7;L9E'>3?"Gh
+:|iN;*9&BW;{Ia6eZ?;#lzf[v{Qq
+jR[0
+KXh[{K{;yMf{fx*+Jzu36Aseiu+mZ[:!+.[{[9+~&MJ{|ES l&#g[;6D\YZ&10$\&|(*,.02<4\6|8{L9@B<D\F|/ >NPR<RTZ\Ql<"d\f|h`3ipr|k#sl{<v<)R*[:7-18\\o^[LX<K?\SL8zL8\|x)LM<\an<f9LSlS<DsL5lLs=+`rh0<E)MArc u5*]6H=3)9II_8P8}H3b	$	iYuF+QKE=km/!J}u
+]0Cn=_JHxq]^s{l}=km=---g*i}Pu=`=MPUeY]&m=M-K\}="j9=di:-JJ>MMJ}-c{]|'k"Lm3*ni^	>vNy.pfFv^3N+}	+4NL6^_1->0'AGI@3=&nFD~Ah~O2]T]:INKRaU'iukdo.	v=+#.M<c ">Y{oi,{~e>N7~un]h~rnNV}|r^kn}n~Y-1DY+9/N~ZR^.W_
+_z/~	/](?>/{7_r%->6l<.)~!5tF]7n|7LNVWlJ\yr8F83ks6?~P+sO,H&~oq?.\@oSt*o5/mO_p^?Cib99JiqO[e*jN G\._MO2o8_i C@DPB>P  Tx3bc"MD[$K2G\i3L/q&OB{5Z4RM2}(E^UV~TXdT-l];6nmcrX^iwqKfL%Z=[SkvYvl_[}\pG\mVy<u>]vw+xgo=}P> pc@4l/pB3C
+?$CCDQCK]\"QFo1GwlQy| ihI#drI'qI!kJ%lK)r+/$sL3,3|KL7N-p"M;$97<2ZF5DASI35 &JMK;UM_Q}+UsUXO]SE5\4Ge	_]vVYiuP5eZ`i[EYmqe
+\q}WBu^}%ry7&7_EW.8b'b4^NE #dG&dOF9eWfe_ny[xfmHag:he8L8iYh:jFlZjiohFl=m^y-5{nzo{i8qg|%?/r3r|C\t1WSO]"M}uQw{}ExxKOwNOGJ7F>zvZA%X	_OiM?2_8U,|O}?cH@
+.l =F} .fpSt Sp	[@2\]tC(G.]8E*maEI_cdqdbdF6"qN_9km#XGp|<c8H7v~$ )6D"HIVdFKf2$8IE,eQyJSrl%[JZdb-qI5r(
+<&dL]*VS9MbflLf^'ml&YlYr%7B|g;+Orr
+sMi?L(Pb
+4,(zQI!C@'EiJUf#	9Std{$K[ZQ=i"u
+oGEBFMjT$#TU*EG)S
+ok\Sv%j^yP:bzWuZW.a+YV%G'XfP1Y:BYZDAmE!8c;sikqVAWpkZFVng \6]B=h/UX>7xYZS4:_V|zV!5@}}4E0~&d+<aI<b&1E`C}oa-N0u87c"XCB<!J2m,7O2jIx_e:[2dus}<zMf l|>q;g=r&J[-VAW3m7;56fM.5jus:D+5E`{<U67KlSL6KV?;NsX4U){(Ul;Yww{;7w=Om3We>=)W8n>['{%rgtq=yCB}}>]ts\ynz:.wZ.gMnevndPvL
+o;oD{6;/f?xG(|KxZdz	M]qoS=]{?j]{[[~|R}Gw,ZK?~	~[l~j??
+?s@	?t?
+
+\)ra3!A tIAA,jA<| TAD!"4#$)l$BB(Az#-,\5!|1T)B0,=1LC21h/dC9K@7DC:?cj@C u<T'3	D34>HMZNDA/SsAdEC"H\EEcL[]^,YE&FsBR%d6`4TgblERrFhoceCkljq0p|=_DtEs45Ec|Gc\9y|$|xl.~I,=
+ 4DTdt$4DTdt$4DTdt  4K
+0<T$LKtK|IK,$LTd4HDKttL,KDTK4<\|4LTJ$4DTdtMXHHIDHHPHHILHHNtOO\<IN|OO,%-H4IO}P
+Odu4P]mI%Q5QEQUQ!mQ	U!=H
+QMuQ(%4+R%UQO=R./4m|65HES&]S9S9!S175=ER6312SC-CUSTG>T SGPINOEKSQMU4-%.>%U|=RLeSQ\EU0U&U-GCV%SU.MLeUu KVkln]V|NTrje$5y/|Mx-ZXo@%z5s/O//+]JH%5EO=YuOxM%HYh0JYXTE]UmYZZO$mmZ [}U%Z N[eZM[-
+-6[\-\-\=\E]mZm\]u]]ElX-}"XXXX+Uu ;
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t1/version1.png bioperl-1.1/t/data/biographics/t1/version1.png
--- bioperl-1.0.2/t/data/biographics/t1/version1.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t1/version1.png	Fri Oct  4 20:18:25 2002
@@ -0,0 +1,14 @@
+PNG
+
+   IHDR  X  L   (c  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  IDATx[z8FY`,eviKE 39J'	Fdo; B)JD,8S,1QDdA,=t7m)Xgx^(Rb$m},j;cN<!mG#e9-LSWvpc0j'6.zqx~M'jgJ&K,<Ve>|kvm&?6rB!A,B!A,:"WFK_k bA?D,8U,PwkggA,}|S6P|}m"Q
+SD*%*Tx>kJNqJg]Cy+tlMJ'XJ8>zWMw:{p6_uB*XDa2Sfhi2N,GVbM
+bM~bM~bM~bM~bMg2Sfhc;D,XK
+3W-c.s?5S!lOll+k$c'$*XUp&s:n~UslKiZ755b5q[%?.b#b]=55mb)=uxI"$X".&':IhU,)MD,?4*}i8zQJaDbKXhT,IMb;$*t cGKe~IE;VWbUXGXD#Aj" V5HV2xQw"D,%Nb7ZKXF_D*XObV~UVUJKRivUF*b~Z4QU6At /zQfTE3^hU,)} V5Hu$UM:&b	bUiU,z'bA~X0_[J/0PJS%}Opbq9'wpbI.=3N,3Pc(j5}ztO,XsXsXWb!b!b]=55
+>!bA~X"D,k*JhCa%K+g0Xxbz
+%3N,VBa<6X5bpbM>`A9D9DCxbN bA?D,\,cOt"3XRX~hT,IU4]QJkiD*XMb`%%F*XObsVPX4FR]RxUXD#Aj" V5Hu$UM:UF3^hT,!bb	oE{XVVQ$Wp*Dbq*wqNbI7iT,xVPc?:#2'"BbiO+XGXD#Aj" V5Hu$UMb~gX;"C.0iki`dKbnphKN0IZ^	Z`X439b.b~bXJb+XlKk
+JKZ96&:}XX(VCze?^O,"8"XX&^m*rMbA!bb3_;[d>bC,ozp]2b&<zUJ N'ol[  V~*\^5Q#Bu{hP/}\Jwvubmt(;s-T7Dq),E;Vj?OAfm2N,GVbM
+bM~bM~bM~bM~bMg2Sfhc;D,X+;(Y))mGOJX>OPJwRJJS_EP|U:uYhU:qHBb=
+}LF-&%=N(GhM,Vtb*lJ>EM,h],A,A,B!A,B!A#b|h906"C bA?D,8SQ.-%BVB+PX	2}Ym>o[VB!+7[a%t
++7bz-\J_?(wW>/tBv>ZDobUvgVj)jbKj],A,A,B!A,B!A#b|h906"CSygvP|X(7eCK'&BZ(0ORb*N'oltwt5JgyD(tu{ts~UZxG3_k['@Yh-*NVa(Z>eF{6,~d      }<,Z>eF{>M$0Xe>M,)==Y-9&{6{&F|XX=~bXJb+XlKk:GKZ96&:y}XX(VCze?^O,"8"XX&^m*rMbA!bb	or{VACbIS't_F,O*V4F4*XJbGb1VyQTTD3^hU,q V5Hu$UM:&b	bUiU,z'bA~X0X[D,VxUU:iT,IU:I4*ViWiU*1QQ$VhWiT-6E
+ZkCI<GbGKaFLU;VWbUXGXD#Aj" V5HV2xQw"D,kUJb	S4P1XdZJ'wxbq)'$3.=sO%1Vbh1XgG,8;55u ""XsXsOps8"D,!bA~X0h+1XF>VB`8$zJ9'+0XX	=b%kCIUZ,q's<,55u ""XsXsOps8"D,%aNbf7ZKJ%F4*Vi-WiUZ1QQ$hWiTBx.XJ?:F=X
+K/*ru$UM:&b	bUXGX*w bA?D,\,hOt"tX*4**NhT,xV7iT,I7oXJbGb1VyQTTD3^hU,)} V5Hu$UM:&b	bUiU,z'bA~XX0>c-#~ivB,mf6_KK!Alk`fXY#Y>G,E,OlkCIUpe7MbiMAuxI"&^5:okqkjHK\GzkqkRzmVEI,? bA?D,8U,PwkggA,}|3Mn[kBFGQJ6}-V|$jb?_VO&JtDyOhn^-X!^Uinp\neygJ&2b(1%(sG6J)343lMAIA)4aA)4aA)4aA)4aA),yXFRq}|l^!bb~gU:+%I	?K'	#JBU)1Vp*<}HjvJN;mJ'n;)Yh#V~Y^aixdD7]G>t	h-*N<Vea2Z]=Q]]9 XCX5$XCX5$uD,RbX:&bA~XC "CXdH	b!A,2$E$=?"1S"MIjiO"-IW)]$"=~*D,%*y{i-^ +^y'CXdH	b!YgogY~C&=R?7f:FbrsA+<?+E~%O=?^d:@S[#~>jYP=89+_Ewu>w)?6fc)r^nxgH=uM1nNw}q{vd}~~]GJfG#_tFvE,G9#b-/b-A%XX#XCw)LM&CXdH	b!A,2$r'~D    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t1/version2.png bioperl-1.1/t/data/biographics/t1/version2.png
--- bioperl-1.0.2/t/data/biographics/t1/version2.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t1/version2.png	Thu Aug 22 13:02:11 2002
@@ -0,0 +1,19 @@
+PNG
+
+   IHDR  X     >gP
+  PLTE   {h      _k/  d p+ p     d /OOp @  cG 2? H= ""piii k#U  ijZ.W\\EE < wFf  **r  ""i22 p     zAi K    z| 2 PUk/H ` <q   R- i#  IDATxQv8EU9mOmbrHf*T$E)2-\>[:WK=XXlX<}c0 .?l%[X]g]gn3gr^O7b8~*:Txtczq>81.?_cmu:+U]nXg&V#m*SwGb	%X.A,r	b!KkF,2_J(>bbRk#I!Z`aplfbBK!duJ,.X.z.GA=.CSNqz]:Xwb|Xp^\!]:ObcF95_O	+X'%X.A,r	b!K,M#XJ
++XkKT}q<=cbcX<=!kt
+UaucQXAhVMZgB,@{d?*'Vq bDR{l?*BXX("Ej*V"{.B%&\V,%f\RbRQgRQgV6dRXUL*VH}@gFY.X3Aa"Lk5&bX3Aaf+igFID,XPx)Z"bb5tT^PIuQafk]o)&=*(/VbfkCn4(R@,n*2X1Cf+&bX3Aa"Lk5&bU& bA"D,WFN,/VLz%z;kC!!bYzbSXN,X>]SSXdB,VXW'f],xv\XB, b%uX3X"!bA:D,:tB#gXtB#>NhB2&kb:28<1\O%X.A,r	b!K\X'U.1\N,XPPGJt5f
+KIvp*bRz4-~TpYAo%V&zTP^~#<:*hPXUdRK?3**Vty\?5L	bfXD 0k&5L	b3XI?3*L*T'bA:D,X\KJ.5fbt8*1X<FY7L*OQgRx:!k"bRdRBjb?3**VtI_?5L	bfXD 0k&5L	b3XI?3*L*T'bA:D,(!Vc<6v4{A,<}rS!\]ziXX^bK]!kt
+UbucQXAEsVMZNhB,@{d?*'Vq bDR{l?*BXTZsv0b=lUodzSX2sMT{)-G XyOUmOTxabB=X{3X,}EmWv
+kW?,u$}J18a=KUjG6]vrAXB, b%uX&VDs`D,XP+vlt<x):ls_czdQqup*|nV*u KB.q<YSu:'=xb2]W|E+U]1b&)2zl?%LJ4.VA, b%X.A,r	bEXI%G{ bA"D,CuXLjW?B6b5:XtBC{^tBCs[:XtBC{^mzyOb	m6ea*+d45L	bfXD 0k&5L	bSka(X"ObQ ZaapPm{ T*gkj
+A^/Gn^"Tob\#<]A>EazIzu
+"I"D, )D,%VOz~m3"!bA:SW/X@iCb8B>5^	0,8mNpCb=VeC]s-
+Z:DQJN(E,rI=Gzb^b!K$
+1A D,XPPGFE^YjTaR:eB%&kXb)1X2bRh,SgRh,SgV6dRXUL*VH@gFYX3Aa"Lk5&bX3Aaf+igFID,XPPGFEKYji3XSkj*ST~WX_O)UH5bZ%~fTUZ~k5&bX3Aa"Lk5fV&~fTT,NuXJ/`6Lzz;kXF*bYzb\SXN,+X>]XdB,VXp'f]zv\XB, b%uX3X"[2rc+4c5eUVk,\X|j,CCQ'e{fra
+<YxB,cZ%f6NZ~KXX:D,B,!b!XI3 bA"D,5?e	bk?L:e'!<sZX=WE/~wCsXN|hB,#FZ$f6NZ~KXX:D,B,!b!XI3 bA"D,CuX\Of	b	 bNh!"%H'4bpXN|F,#F$f6NbKXX:D,+ibf bA"D,CFf/zo\A2*e}z{2Ke/J1u+PxRX.V!'UeRb]+bKXX:D,+ibf bA"D,CG#y'A,;]V^;X4i-=gt!=yFbX4i!w4> 1YUn,'PzbEWtB, b%X.A,r	b$Vs9 bAa"D,CjT"(QD,ZUD,&PI5iQafkUiL*VI+zTP^oX]Y[L*V@PgFYX3Aa"Lk5&bX3Aaf+igFID,XPPGFEKYji3X/NJL*RgVxF83T,bmZHXTb
+]+bfXD 0k&5L	bfX*V
+X"XJ<6IvA,<}rIS!\]XX&-b]I!kt
+UducQXAVMZjB,@{d?*'Vq bDR{l?*BXeeG=./vYaM\S!<mkXWTx% "+<Mwk]$}J18*EIOz)N!bA2	bBe:Imw"bA:D,XP??b]*=W6V,xKS!<vX(Sb\_xVbP_h6|/hXGSa
+#Aa"Lk5&bX3Aa"LknJ7L_CDuX q	b q	b q	b q?/BfnM"\H,r$A+r(HE,|*D,bGU<!/v(.tpKKb[#qyB.Xi#{>{n?a5r}[W..[/n;h]Qvj786~*|z?#Qhu*w]"
+o{.iUg5r~4;]w=Fno~*P=]/}w])Kw6y?li~vOE,Z?XyE{^{a2OE,Z?XA,r	NuPL\X%E\X%E\fC3    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t1.png bioperl-1.1/t/data/biographics/t1.png
--- bioperl-1.0.2/t/data/biographics/t1.png	Sun Jun 30 21:24:03 2002
+++ bioperl-1.1/t/data/biographics/t1.png	Wed Dec 31 19:00:00 1969
@@ -1,24 +0,0 @@
-PNG
-
-   IHDR  X     >gP
-  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  IIDATx[z`/`v-2/ gRJ'	f)!tIsxZ(W%&O#YKu8FvbguI%^?+I%9~8J@myN|rF#rqB;
-d*O^aqL{8P/wX:T?8ZDob=rsUiioC]ibiWWb9b! bM	b! bM	bWFKX"\*X(;J"\Bq)-^,y_w]i8g?QJ#
-~/w Wu<{1oKg{D(]:>.f|S/xiwXp\CeygGhM,tQYvPfiv}KXXKhv<xLb-ZB1-v%O~\B=&bA~XX0sXe>,'Xp~Y
-afX=~bX=~`XY#G,8D,?Ob%Z1}^EcXJFAEyT#/'qkAEyKiKz]bA!bb	?D'b%F/BO4*V4XhU}i%4*?iUXUiT,%/*zu$L:j&b	b5XGX*z'bA~X0X=XtxU.4*}N`;U`3UFKRKG*NbUny;-6X%|KiT,1M/*zu$L:j&b	b5XGX*z'bA~X0_[L/PjK:%'Bmgb8K,a8$q'wYxb\5bpb-_iq'bA5D5DZCZxb8!bA~X"D,k*9E'4b	D'
-N5'KN,ItB`8^xb\5bpb-_q'XkXkXgb!b!b=
-q'\C`p{XVB<CbItvUF~UV`#%K]lQ\U
-J?:F=X
-K?2^hU,q V3Hu$L:j&b	b5iU,/4*N`pE{Fb	]:iT,I.NhT,xV7iT,I7oX%1W<X*kb?2^hU,%} V3Hu$L:j&b	b5iU,/4*N4pX	`znQIN0K}/]/-O]/b.FXpXO$*0`.:n~W'Q5plkqkK\G:{kqkRz<}^EcX~"bA~XpXb8*YXr}f\rX_P*E*%^ /Kl[  V+T`kDG>@|9O;b}{p]GBy-T7Dq){)2k(h KXXKhv<xLb-ZB1-v%O~\B=&bA~XpX2?BRI	K	37Rbup*q"Ym=]b}E,T0oK'ptRP!V~Y^aqLGL&Jt{CWPy-T7sU&Pj)jbiDsrB)A,B)A,:"ibXs bA?D,X"C+"	y
-pXg
-p,po6	gU|J~E'4C+jMFXGXD#Af" V3Hu$L^n8oJg"bA~X~K,"\Bq/[y_Az]l8%
-a']b^m?0Q"TobbU.v}|H_pX1K#0
-RZB5$kHk	+Z=[3 bA?D,XGu{@*p8D<?D,%V$B%2v~9E/-O|;>BXKl#"k,'VAIUab1W]biuxI"O,b,b?.bXuxI<XXgb?.bcXJOGo?^wOD,X"C?b	'<XFbImU*bQ$BO4*<X%24*eiUXUiT,K/*zu$L:j&b	b5XGX*z'bA~XKXN%Q$hWiTZWiU}
-6Xj_UvrSiDmV*(@,^Hb),jxUXD#Af" V3Hu$L:jUFdX;"CXX3(ME!TNpbIzo,PN,+bKN,IWl}0X%1Wbh1XpGg
-uukkA5D5D0X3kX"D,5QBMQveR"b]c]HXk,4Qr"Hkcb(;FXE5U5LFVM'Zz;$b!b&bD,B,D5N, bA?D,XYd=kcLQ*kGE*%"0JQ`7+X#)C,x/~wRsXJ9%}!Phqjjh 8XX%6$b!b&bDqbh D,!bA~X"D'-T5tBq
-O"0JIG:"H
-5~qXJ9%}!Pqj,;nh 8g2UlJ"b!m"VI'bA~X"D,h
-8	}XJ5j[O]WFR^D)5}R/$]Gn@)wD9<We"0*,jh 8XX%6$b!b&bDqbh D,!bAB%gbx$t/<KvMZ}KI+E_93X{t!xKMZ+N,0X%1Wbh1XCGgsukkA5D5D0X3kX"D,~V"xhyFbIm'bQ$UD*NbD*LbDUFTk
-XZ$xi#l)#V^wYb5XGXD#Af" V3HV2BbAD,X"C?b	k<XyU/4*}BO4*Nbq.4*$F]iUXUiT,V/*Zzu$L:j&b	b5XGX*z'bA~XKX s;fw4i1b'F%9.MZwT>vMZ3>b!b?Ob%Z4}^EcXJ1G:AEyT#/'qkAEyKiKz]bA!bA~I,PXr}An`XS!u+m"G1orSr?n?	0Q"T
-7`'o6.v}|Haf,A(G`eEk	" "D!A%D,8Kho-D bA? KR^_VW
-3dq*nw_{XX[g&Jy>>t	`?aX=ya=Af" V3Hu$L:j&b	b5ERX"D,)2!E "SXdJL	b)I}sOt&]+6Q=EY'n7t%QdDOE$?,	:o/7<xE+dJL	b)A,2%O{>Ll_h!r6<Mg)]C,yW.=y|){~-zs5*?/',y }l[&Qo.zd;]	[@VE:N?e:D
-T0fg1khy^NG~>mNw#m/l5=;YX]%rOHI<G#~iF~rK_X?X#X[eX[0c/E,GA,^nXHai2"SXdJL	b)?i3.    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2/version1.gif bioperl-1.1/t/data/biographics/t2/version1.gif
--- bioperl-1.0.2/t/data/biographics/t2/version1.gif	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t2/version1.gif	Fri Aug  9 12:46:29 2002
@@ -0,0 +1,58 @@
+GIF87aX     {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +                                                                                                                                                                                                                                                                                                                                                      ,    X  H*\#JH3j CI(S\0cI8s@
+JH*]PJJXj`Kh]pKxL+^#KL3k
+`0z4iAave7M|q#Wypo>[gyr]_{wG]y~|zRh_} q
+`Ga]V R	".Hc09c((%(?dB"BcRVy%Zn\+"Ac H&\
+fMb']:9xvy'D@i"
+d3"y&}h"FJx2(VjL
+da*jZX,N(I
+hjfXmx"l2bghj:z-
+/umw20kgw ,$l(,0I2l8<@Ls mH'L7PG-TWmXg\w`-a9Rdlp-t"m|.q'7+m8HGngOQ.nz{'zGAn/oo{7GwgO}o>i2Hv_/0toK_GA@	~ZL"M:GBY"H 
+u8s=H/%H"v!J|%CyX0kILUTKT*/z8F1Z"%5rQN ,h;1aS5nb!vH=62}Ld<b-4"$FIbR6"@BIG$'E Z%,J-^+dgp]^2 #+WLRL&079abTf({MR/iqrl3?9JR$5g/xdP2wSdy%;J'yOd$1R:(24:AsQ&,Mi9StL'u~32'M6hPUt(*Xj'Sk>0EGUu'F[c
+]+ZVb4P&N)]G36_#0&J<]_pS,,A_~
+VfSkW[vn]Id!vkh)jFF!l\r3tA}mr};ox{]B|zRvEs{F L/KG/m+y 3-RFioR	I%;p.xu0kX'V0CcU=;w<33 &$ K. Eia@d,RyU@x|{g,51W*F&CbxV6wYAH61vr	:WeXA?nMV0q% ,VF5 n1;36ET2VKL2$U69]mS$UOk^QlDwN6{]tUvmwKHm#MptS Mt6Whgw6+R xKt<WK<`d-jc9Jk3ma.9eZE{t_{M:.tW](9IJ;5N;m4<u~Hx}j7;#X.>y|}q}=xT/}y^Cx%7ct^U{Vm=a?#S-O~?/q~c^OGB>~M|xGgxYg~X}wX&'g($~r@Bg~w6gh&/+xWx$!-k+.D)&cB&19h0;16X2RJxw'GsCI,JHNx(,Chj>}7QgxB(|h8(xhXh<X{r(B
+"chwx,(B-8rXz8xhrPlGXmHm(*%S~i(Hky~H6nvo8f7VaR(#|YRVQxVh)"r\YVT\
+e(8frDR"Kzi6nyUSS}69 9$xztU[YXEIG	eIc?N=yy9w('JMduOHFxIi1Y9	0):82IY{Ixbyf\FU (Bizs 9Y-&T)Ty7)y}YU(Ki,Uv9)@W@nY siRje	y	'sPzu"pia	~. #ni8w*J,*
+2Bfi2iI&	At	7aj79x{]p*RzzBu$omuI:.YVU!)X&l'}*hnjcZa_uULt	saOnycYbTZjZUUTJUY7TpUTB:n:!OD?zJJ]9JJJa85zj{JJeZZS$;ZYQ&iF*9"{N=	dKHR9{9ZY0Z bHk+A!4`Q~J"aI2_k[if:/eI! *0`H	ri_Nk0K=*KK
+[i.kVzh+$;#/k^;_7vK}Lk{kKO+d[6;KJ{+}z[ {K++kzP;;[
+Ll[Kkk ;|'<)y&\kg-lZYXZ!+;;\JL,"L`k<I	|>LcL,	k*TK<jf|37|!ol#
+	W`l\^zUY,+M4kQV_\+H$SNV5JT<&PWc=;U	)~%(d]TL9|r%M|$rLkL!=cl+	TV'H,=l/z,+7}M$'9"QB!"M,,L@Q-*P!YF.4TfN,QhjdJl-n}uAzm{i}s=}}MmmM}mvP+-=-MH}}MMm]v=M-=]}]/-mM .Nmm.J)ID
+&*/y/H#JL1; J]-*NU,~AO=]=7.6]u\m.GY^aI_!MT= LQ.EYJZu{L"bE6Ml-JE(||=O.!N?2=R NN.j>>%~#~lEM$%y.@Y&|!n.N,)n<G.Q:QWOQ T%$?<>~{L*?o\O(oD{kT+O#P({?=?%.:-))*8aD	./%Ai!U#gZ_yJmTs~|Q<~?xJ/O">2#EUyc6?CmQ%I-s~_>N]N>jm]3mq<Lli\/-mg?#/   	<h.LPC-J1#D7z#/$RI(O%L+eYJ;}d	TPAlTRM(TP"yUZrmd=KukQkThky`5/vd	[Ys^54fG>mt]M`K][h}{/j_W8q/>\O]zq^\{_./9?cg?<g? 8O@dA$BKPdE|C@BP\1]LTBTleFHaGyQ$mI'M!)Q*RQq+, Pl5'RO79L3	D:4B]AuR.&S(%M HTTRUS#:UXMM;RPVOT}TT5Y#bZeS\{E2`i|,p*\]X[OQSV\TUh XU
+6xV5\QJwU.`M=d^dm7eV5vxh#X['{fdn}z^CIhP8`YnV>vcugUi?^%WM>xgzbN9pvk]fv\id_c!\lE^QIoub:w&<otXU\aWu[q]glfm?v~5|_v =@#` 7-pW	d whV||g|"E>d/"
+/$aoL3QNBD7L	CGBI`&
+ /a}x>.!YCD"&Q APE
+H6RH!#D7^cHC#AQncyFB&]dA(D,$@|b9~RHMzqe,G]Al,"*(H:iGV<e28iO*Hzr48LM|f)JQJ2|`yYMh.)q5(A"aC%:QVDMu:iH;)DSHvRTZ@
+GiNuS?jP:*2;&)s6=]f0PbM7X_+XYr{BV5o-*yT&Alk[79Vb	HG2+_4VIEld%U_'KThV)(=O%[;:Vi-l:vej)?Me=+-rw6pZ+fb%yO+z-vZC7;` G*=JM}vPF8~&f'2b'-a8qx%n%0Q"ca:>6d9vf\a+=~qj%.ffJgDw:3Ig=ycaw#w.f!#uYz^-e(f3mcfNd&QCZhs+K5T^9HSz?<c^$'l2vDt&3>N15^5}=lrr}baO7<VV}Y)VWrc'Nn5nhz{7#_3cu8U"J_kb'o3WqX/g;g8|_|VymoeNzk;toL4^@_mm[n7no=79>s]}>t=V"h.#=&~=}F2=xn~!nWZV6mQX=O=Ol-[y=
+Os]GG$DCJxh"4#uoYg-W$O?i+Y#5#D@-s? -3O=fr6=>	k<ym6=;*;T@>p)<>A7[
+n[B!>&A%D?B-C'\="B43-4C4, :h&9|B:LA?tCi+B;B<l9>,l!\,4?;>LDAK@TJF@BLC3EUlE(Bp?TWdDW[dE<@D
+b@S,]?aDb<K5<E~)Ei$fSD2FX)/]EjpC8tFV4G)**(`\dry|@v+?]5REx$HG4B{[%QsJCe\,tAG[2"jmPtGHlG;gl3EcZi\?d?|MEzHs"8s"hJ|HHw\,t\vD>B*=FFHDJolK$GT
+CZJ<LTLL;<,9HItL3H<\Qd=L\K.H<"tKTCj$$MMKWMdNdKMlITLTFDOdOMK<<C,O8DPXdP NO		lz.K6JDdZe Q%BGtPm??P8"#%e ]$9g8M|}Re"*3R$5}S>UR@uTS--T	S4FUQ,ET4S#0rKN].ATS{'-:+n:D
+GOL|QIW:XUUMzA"UQmR*0-I2Ub$Rj)+L_]M6oUCeShUu=,t5L{,
+}V<=TpVi}%{uWc$U-TryeJT"*0/WzOxS'VW@Yq5;]-}Y+YuYM^xY\MFr=MpR-gM-%mY]RmZeY]ZTOUYE[uU[mNZ5\mR7Y[%\-\.Tu\[m[%eE\%DU\-^][]]eW=5e^J^a9[^%1^]\IYi^e___)!e	]}_`xQ`1`mZAXa)`m^5apa(b6b+b<awa"&6#u!:^78Z.^-v$a8>f@A6dv.d$DVE}<+VsCd>adROXh;`tKz]E\`cheFJgB?d%e1A25O4Vh
+9"3c]-=eMSdn\_8*#!d?Y	ZLH>eQNegV&G,a2%lJg|F>+xO6N[Uv51"VDi1QYh["hLvN2Az<3h4vade?.h<s}2v^@{Df/"ql]-\J.d|G[n^jfdDcdkEfGK]e-U*,jReXOXnVlLl2^$s7 .mV7vmz>mTOn6*^*."fm^~jm~n(rn>v&m,,
+o[bV~m7n">/ ?g(p(FnVn5GN'n`Mio6?.pg?R6)rvpp!?'? gogoXr)rnVhs5Ml6:hH7G6m%dSk7kf9^snNg6dBp:=EGHGOBK
+zJ	LlblY$NwtH_-NO	E7IgVW XUs@r6t
+uT MvEuIvHb?vH`_avgwvW_vW` `a	cnfvhGq'wnonBw]X_tpvutcg	UGvmvov~vc?x~LrGjuOu/voxiwvu;kBgoyvVvxXtb?xjww?WyjtusPuxw`vozz'zIg?Gzw/wnuF@_wj{HuWxo_gyjyzdQwG"WdJxwwtgvG{sl|yxOsPw?7z>'VP{??_t	7u\'}W~_QWP/d~g  h 
+*,8@J8!7F +ziQ<eJ.cd9f:mN=i,PB*ej"R&=SXj5kU_Y,XirNr5:.vp
+.,/bNm#ky*7t(B1SW6]Kvw7d;am~~Xo^.5[Gyh^^bc^w;<9r(g"W})({omDdA%8an$B&va"S!iz"y"I!rXHVe3&yTqxhO6E_Z1id&5gyAbN`zudKW~e(d|vI'(P0Jv6jij^JU4:+z+sgK!Z+zeUNZ{-j-HD{qFp.6h:r4-y
+<"&Kp\JpkE'3J1-}524CyU,\A{l
+-
+}sPg\;SMOMAqfm:[^51sF1al8nPD+L,,8!:n+N.l^r;9ozWN.^g?;}g|+='J=k_3}_^(cOk}'Ng>p~[<
+x+ '@RfW	ZPS\We0d!
+#P`Yv~%T	gC4bCN)l"nhC):].jN"pm8lT #z~8 @B,Epec"_$C "%#EQx#$LfrRNy,QJC$"@R!(WJEz$i\/#rfS0`R|3)f1WS\'ZeAe&9Dw308KP>JPbk	:RGiOdHrLJEA4si(q
+MviU:K[S20nE&O]:nSjj5GjW9BWVOpz>]ZW_ceYR@*<@Xf6\$7-*UG ]W*ha)	,f?kCLUj2ms:\FKv5\>n$)VQrS]>)untjok$}_nlz3~0#,	S03sxKNC,&>1Sc-^1c,6T^,>1,!vg<&2%39)SV2$-c^2.[b>3f$?m^3,90=~3-h<cmoY^X2I/_CLvv3`F':\Z \+X^FWz5d+6H{Q59f8Q&vWN$)
+'Ih/'e"8:\miQJBIHDe&l{{&w-o#Z1VfYv9 \fg<<gyn{Bry+ &7(.As^:.v[x];v.w;ws<C}h?#/*3b1|''H3zV;=s{W4c?=/a=	xE[9}\?~:;~_wOU<5/u['1Igofi%]jZah[}]iiyl	>mm][AA\HhHa  !91i%!UiU	p4=`J "
+]`IM	qYiN]VsZaj!ua^0a _'``
+Qry" "	J-^!F  1#2"#c2364N#5*P3Zlb'W4V4.99#;:5 r<2/Fa*JF4;c3f0#AJa#4#7
+dc":cA:cUFZd`yiXG(62$bD dEAF$@dB$d7(iLdcMA0NJOF0c9MZQ&eA.LSvOBXFU"Q"SRr9zQ6eXMY=\[TDB,"f`A%^>YP/bNT~DbNdaR&&&fK^bCfyhnf%be*Z%i Y$""^>^cgf8]R&+ni$h'0Pf&gO&sB&m6gkbrglNr&t
+rconwv'x*y'zuV'prg0*'~ftgybe&{$g2h~t
+h6(lgg{Zp"gqkb^vh%_j'J!"RhPg}ge~hc~C4q(Fpz%rD)EHd2iY5nB%FuziiuFTJ/TBy.8G)i>i**Ti4TM5J]RM"jC)HK)i
+iYHR8Ef>yP(*)TjBJ*=B+6J2Ij/S4vjS~jkBPmkjIkZkUsvk+&&Z,
+:qh(,ll>klVJ VglbEnUj,l.xd:=TV0 -g-BUm! Fj!kj&lF,*L( t!rn".U:"RVBmitXbmV,~&uIf"-.
+o(ztxp`mmDn].,.*nr8*nf*y=@   @0'b&rB0z/ZfpKr0@/0+pof.-jAt p0*opMh?X_,no
+n/gp@(qppN^q7j0p0RqM{p1q
+0C"-1!!S"q$cn)-'3rB*r2c+2
+2r,r/So##)f.;2//-.s5{r-s(3s7q3"r45w8s+[q3/O	K7=bq*os"38s@m3;s23A@C7@p5St:39G4?3+#3H+4:;3G27?4=8#tK's2Eg4544F[64IkKJBO3tBs0+uR5>35cHCuISS;Rcu3Q)PcKAtSAWDWSd)X/RuZUYu^5Z`kTvU?2Bj.id?-Dt^aPgsbK:E\?65*{XtV{6`^hi6&8mLv<vmr+i{oi/ku[\#,NE]YzhCyWpKtEtf7mm72yk)cSv7@r6s7hkIbnM^+xakxgD!*o6}7lsQ{7rsvr7u88uFfTwx#Y	-F1x[WZkw_codA9za38/9;8hz8o[|n|sv1z_r0y'kY>9m7#J|OiW.:Y[z'zy;zxCEc{gRWI;w_;T{h;{;;;$eX<'/<73W_<;(C{{9|W:~z{<;:zk;y{z<#Z;}7}';##>w3CKS=gh`D}7{<-H=-EJ}E!?O|a[={=?=Xp`n$VG~/>BD ~)
+G&"?m}[E?K`;P{~>?@  @"T80.thP/"qD'QTRC&Ec"-)?BPB=iODO6:uIbjP_vleULmbR_YwVcjqaC+/8e{A|3fdK{&aa=6l[~{Mkz9?=zuog{w[?OW9zHxP	,OAAz,0|p0P6AQI,Q,oC+/EFXayR!GcK$"KH+R)WL9	/q/J(.=7	d*4O@*35LI<+HQGTT8NBSt@[TAG9]ROL5TBWUNSOetV^QXEurm4BOY`MoW%NXbC3ZY]E,Z[]Wh.JlA[o6]ne6`E^jUv_V`qS{-8r;25YU]xc'$8Jj>/9cxcm/5fd8f*+vdfhNf#~y\h&-~bR9luSWkzq3'_:a:m<rr>o.r>	qK#Etx_Gq%;U,#Zt$nv^m?'>jou'g__nO_~^wr|b_GKgxj[wnt-FkQti5MrXnB};awoX$b90"|f<k))=a7t*TN,G(E&6 85"YW:QVCLD:Q"EzP]IFp18.A~pk )3(=!1@E$%VUPfP{C%#q$N~J`J-+?hBa/GSRRY8.zOf9	ICf.t' WvFol%BNs'OtvSg:	VBP|Vz@	Q245jT-hAyyP4X4MAJQ&$08q*Qvf"5T+)sHbDZT.|^Qt0}PIt_CuTUYW.t\Saj^FuR>ihVVe,kRg>KqJ5b733k@qZ)gJ$kg[fZL M-qW4v%"etED6
+:ntMc$exV=hFK*"7d ^:bLT+
+7r5F@GE, ~;:x@d
+}H^u6("X3i^]\>wD.zYJ{[IyfS\Wqyf5mvg9ug=}yhA6hE/v!iIO1iMoAjQ6QjUvakYqk]la6le/vmiOv@  ;
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2/version1.png bioperl-1.1/t/data/biographics/t2/version1.png
--- bioperl-1.0.2/t/data/biographics/t2/version1.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t2/version1.png	Thu Sep 26 21:36:53 2002
@@ -0,0 +1,42 @@
+PNG
+
+   IHDR  X     J  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +    IDATxm<qDL6-
+}! %P&>Gy$4AAAAAAAAAAAA60+4kgDW5goO5go1S9{SYc}}Ysf`B;n[V,;}Ysv`MS>Rl/5g#jX.
+rc;^Og,k,/J@K bT,u`A].XP,9I Bbt~e OIX!u-, E "uHX2[`t-J,|O3S9;l`	6k,1WUk&-13'(kC>Elr?!Y-Er13 (-?, %!EPVhVmX7u}AXf'Pr"d}A
+UkrB13UtJXjjjWt7cCx:yA_Uj%OTu//9;K*,
+?1S{`_`VXWUx4	KJA',XGL_Le A!`9M}~b=}"q[^slm<yX	oAg`ML5C~7X
+LU`{	 VN43}oXTxE< 3agi_Uh4;# `u1W,aX `.fbX `.f|i`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l>lA_iXlv Rr2+_&`i}q3{qH/5go0m{1Zuf^J5k,1St/f1ajYL[^J5k0aWDi} VtKf`}z.+,f`*=i?yD]2w%swOU3#A@#8Xev,>T)TdnTX{ZyYsvm`Ysv%9J^T>rtri[b23HPpx+VO<g%*3SebJ)*Bf^!~83SL*}j	43?(SyYPgAh,f	C`I43T_C
+me4k5gX,fV3G/_@GL*g(,#flv$w:cyHn!foi=?>5>X<:c##V^fmp`}qA<
+`]!fbfj\wCX KYsv%9;jbf=g|jqvNWrT.+>3T|w??]Zv%
+`<l6AyXam2h|eQeV'z'vW*P`Uo
+YmZZv!XgS)O{2i,O{vY2Z_^y/9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;lXE9RYs`|Y;Ec&+7_Lefyhh-]{j9{C*%?NGIW5goMqRhehx/5goE
+XX#C9{C8'6
+ix/5goyc9+,fu9qrRb.v+'I8 `6/5g?^3wb~RYsSXd5g?AV/~EdM5go6c-m,Wgo.Y3:nXcXJ];`|s.tjXGYn ,,\fVT^kW-ZL_X"Esul1st%Y]f1oq*8v|+.Cm%`:8/Yi?>gDUb~B?,pl9C`-[E	QvHul!c~J]n[W3`[-G,ooKS0u5.~r,^Y=XE`EUvV}s=6LuE|~/-sw",+\0#osW9~v[LSu5Dq'wq0tMTRjcHev{]*a<0WtrVHq>z5()Z7p:rXnrX"FG^Ysv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k,X~G?'<4o^.:jXEWr`M,%w wl}vU r`-N9Tc_Q{rf|!hX$<"66j3X=X4E1XR+dRkRkO2[7/\p^wb{g-]Hy`Ee?*8Lu4k,7J7Kc/5gX,fECC
+3hRKGtf?wtum'?~Altu}7SX>P|/}7 k\^
+f]fd`f(+&`u:Lanq`VPZjfBOEQ +XQZh!fahnwCX`|RYs>`%3#A_iXh[cSMnw>M>\*L3('NW4t$'ENte[iPN6'O=(9`1O<-?GyXA:uxjVIe3m&Xk!3g``=;c:rj4X5u_*07krtmWyf` KYsv`dAs)]<Vo]XyVJbWte//\3F3SU<t1S!jTU-!OD`M,XjLUJ2^FPZ2;bWtUa,9;l]X<sUef%3WUj`	6k5gX,f`J?o*K5k.x#X0(j](Xg:5g
+!q_)? R:2IJku5gw~Tjl.]
+ok_c}%++]3`kX]azN{_!s]`7_	 \u4k.,,9`X_ KYsv%96bkb,fuq3`].X0.j])X7m]`513\P1_dI6*w1."5gB*XB7!lV)
+n]_V3cW(RB0KdE$z>hvd KqA(=x"r|EXo5k
+N;:XfqxMWh%`efj\P KqA.3S,]fLJ KYsv%9;l]%X=-:/F.`G4'v|E)O "3SM@PA31c)23=A
+`73=(.B*3S.)+OSf`s^>rtri[b23=h|se:*3meTJ)*BvQi?bI[-GMAu*8RZ@3SRJ`aT KUf=Pm*_g-lTf` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f`,5dj%/6
+JvfL\nfz)9{C{}QB/5goD`-XgEW5g%+]^8X]^J5kp>SpJf` KYsv%9;l]XdXC]]7
+->icGXGLjS;Oywjgk$),gfWbM]toE`InP(dZ^)^-h%or?[g#oSrQ({#* 3SZ,;{v]a|wq.ZX^)^-wd`b^3Pl VR_y}fx{tvu?xw;D0X6n@.^WMVs-nx;8x]I-Wwr8.Y'y?Xu%gg}]dfPy:}XG$|2bo
++fg]9~x:LW<yTvY+7S1~W:y)^/S
+g5X-Ur3V73c&lx|,]\dYm)+)^/w1q[YqC7AWj6k~qA_i}0X_wwo>/[&;-
+PlR;,[1,~M~e1ym;kXax73{N3SZ1X_,>{s@E
+Z[[`Ubr7lX_7E;e2q+.mkL)jL1k%<X~own5)Xiv~w<XN{`}+X]X8x?Y'{Xk=ofpuk)>Uuv-683SUkVmd635.+,f` KYsv%9*vu_2jlfs,)+f%~G]'-s-oP~A~t}<V3S3wwfHJ_o:LJ KYsv5`]6 H{a%*3SCo~[>k?\6LZVLQLKj2jrLuwUey>_jPgP 6,3S]ewC|UQefj\W5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gosgY'+<5,Me0s4X>2}3TJwv46T"`+Xz)9{'LeXc79{3.+vJ c}^/BJ4k	,7c=f{tW5gX,fe&9|^J5kE,{k,ER`Y^X]XC`,/,	hc*<lb{)9{;hr`nJ	RY^Xc9;lXwa, E "u`A].*8*h>]TSX4k5gXJp^9v3/7!h?X"EAD+XX%nu"XkCs
+eVz]RP^:X`< K^y`y,iwaA Kfy`E7Yh&+4k5gb@-A<, E "u`A].RLJ* f` KYsv`Q7l,XpJ #'1/eVXsdON5jo:CD>_+Bsv<jUr0`
+kfEP	.%\2[Bldg}A;@|3tyl-G^f-+f,yjjjWtPQu4k.9v<=]$[N>3SA2brfEXLXj23U`aT}<Xr~``B>7GX Qef>(RF KUf,5lTzY"E';K:U?jLJ KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f`Ol^|#@u4kgMVK[^Xlu:5go
+%<2'w]^K;D7
+-Nn4V}
+3jXc(@ < </ONC9{3^o+=*~zR7kZw %f,2($!X$#X0(j`	6k.,h}mVBYsv`,j";pP'%s?_7KfE-;JtKE7\;k&
+7$E~7	</Z ,`e,nWf+2}  IDAT KXJf,ZX fx{t|;<3L1+53E6uCJoVGmo+RK^+V`M K)^E1XO``23Kvy5,mfx zeW5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gV%pBe4a
+//dQ!hXtp#O|&Szy)`w=}qB]Vm/5g	n${BXR<}ku1zr%$%Jf` KYsv`QMN83^J5kE,{o/$` mI(I3br] KeyY`uk`-/,Z<
+wAKfEkTX*K+}=xXJklW5gX5[Ff Wmt5OOm !ImE%Xm>z[mQKT
+fQmr* X=f\Tc5>jcnWf` KYsv%9{)MYHjYKhOn37q+SGXDDW1DoMk
+K;f K^y&W7<kCs
+eg;ld6q]E+XSf7-*dUoca/O5XJ/ %|M<x5>npQfoLtr6q,Wy|_GgX	dB("O.:3kyR7q,T~j"u
+,u^3VX7\1gQk~d? L
+:|j{`[=Q<sfV4.+,f`*sUs=P_i=upf-Z>S7Q	,r?$vNf	`V h8D~	"k+EP\kfEP=":} JPfKWGS2L!o^/Br}~E>niu+L5J5f5+UXm++rkhO3Sy?TBzv+BYh`Tv?!e7g5,,R?awA7-85gul:'0w-IT`6vd8RTeT63SmKUfoTEE0pc>3S9;l`	6k5gX]Q8uFMGL*Zo<:l$!l.La!33S7h? kqAry&J}qAG),},+(Z-53S6y
+BW>Gn $ V+QEeM_,~3J{69Ds	VcSvpT8![|[zR`\3
+ jMp6''?[801S{kffcUfw/mFB/NPl40QiA^Op*j-XAAAAAAAAAAA/^    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2/version2.png bioperl-1.1/t/data/biographics/t2/version2.png
--- bioperl-1.0.2/t/data/biographics/t2/version2.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t2/version2.png	Thu Aug 22 13:02:12 2002
@@ -0,0 +1,47 @@
+PNG
+
+   IHDR  X     J  PLTE   {h      _k/  d p+ p     d /OOp @  cG 2? H= ""piii k#U  ijZ.W\\EE < wFf  **r  ""i22 p     zAi K    z| 2 PUk/H ` <q   R- i#    IDATxMDq@[5<j/~@6;w/'m!RI@P(
+BP(
+BP(
+BP(
+BP(
+BP(
+[<7'%K?RlZv%{?n!Vo<3]KT1`=57Op-QUzn#j-Q5eL
+c$l-Q	bfJeti(X{na^X39I-Q{uS(L!CBK1$bH,X!!CB`)c)RF|T*i
+sL^O#~*X<Qa+`]J$~+bH,X!!CB`)X
+u5 +#H1Hk*f.;Xnp-]97oa1u`=qrm>%lyxLoX,7;$n
+`#
+m ?
+n[0,k=wKbct0/GMwl7O^6'|Cwz M)q,M4P_{MZ_/Y$=TcckmTcct ?wjd`U2evSJ~Yn
+&/!]J
+``;&?Hzs&veV{k
+X[{T|.y K`O#:W|XcYzPjulzJ\`UXgCt\6Y V5feK'w- XHXI,K`!X`bc2X:%3{XbfX]`,`1w,f.3{XbfX]`,`1w,f.3{X[55s	`W
+,@J;X0D3{VM`^oNg7H`k0{$l;H`k]_'bM$ ]5/H`}i(KV{5yMV%3{I-Q3{+_/w&-lBq\}Xjn^t]UL`/;=>74IlF<zz,"1Xbc,W
+5y'cQk[NS`3{']Z,_sc
+XG#}eS~,\6,#V	%d-0T(1?TgHgiYY[PlFd,[ah2;ZXbc-(6|U~yQ#Xe`3{XbfX]`71Hk9xEe`"6i-_?p#KL[ZZi-{-hT?g_AZb6eQBlZ.|(tnPX7yXHbfX]`uY_:/"9TRZ.`Y.=/@ ;W @~63k`5k(kFK`} {\$/RTv+33X3+X'_ak`]eWRzbl ,`1w,f.3{XbfX]`,`1w,f.3{XbfX]`,`1~`?g6Y&X@`U'XG+?Ns~p6Vz\ g]g8H`RQ(apj][JtZS
+AgQ/CaV=B(`M8'SBXA:.r?#f.ukl$KKPf@%h*sc%+_E1=pXGH[I`u3{?@V)~%cu3{cX	,WOtN7m\M:u^g5cUC`	U{7(f~#\&d{]f$J$i3}*6ysj/6'e_>(Oj-i +W5;eq/o ^A]:_$MN*/`J8O,I$.Xk_O_.	NymHjiDI{-7$kPhMJ?nmi]8x&ehV`]\d%tc9;X[_Yj`YlIbbq`4yo
+]hCa#,lC.|Y&T+a~-J_C0yrk-t,fkIZU
+,3{XbfX]`,`1w,f.3{XbfX]`,`1w,f.3{Xbfv68({O-Qu{&V-*wyO}4zr0G8Q13frCVoY^}{;-6	9h"	<Q[<IS+{*;4c->D-`MNfj^|Pe+&N-hvSaM$VGU;XD3{XbfXX.h0[)q,"6Dj>Z-,|n/9<~nd47unV`<5 +{vmOkI3v-8<;6X!XSX})XA.ZbCOn,Zv/KgQBlP	~)
+];<Xq>3=rzZk*f>\nF1jyik9q[Yn2RccTd:w.\xiJYLe6NxKU9dpM4M4,vQx ~Vf^Ng+]VaEM> C,Y-:_`	!~Z|vk#A1 %3{Xbf`Yka:`|Wm_gu`sCo*.sx,n7$Lxifu7"5xr-^`c]g*`UBF`XSf{T-Q;X,M$*ci"%3{XbfX	|K	,tH`I^`};(X
+#XBjV|WJf`+/qZ>igXbc37niJlBVM;vlBJ67L}/toUM;/toy,wM;kz[-QaZOaH`ezX*iBVLw&m_sf1w,fV5RKT1w,f,) fN/Uk:/U}$XMyk6>^d3.16?[.<D
+Tz!ee5N%fklx]N/6Z-N`IrO
+,Il rMlyWO9y}o3{.m_Vk"N/:zvXJlX\bc,%:K %3{XbfXM/tkJ>NS`moIgo1Z^PH%6xq7/t_v3"`P;nnizlB)~J]`U:8N.>{b8ne]`;
+XG#}eS~,\6,.iJZBCj`U#YZ|VVVM
+CK!XK`wDY`5W[bfX]`,`1w,f.3{XbfX]`,`1w,f.3{XbfXXgl*7j*f,'fg9|bfBON@,vND3{/tk*'e	O))[D3{VO9w^S 0Z,`1w,f.;XybaIpq'x7%XR1w+y\wG.>z[+5={;I*SX.]K'6,(^`N#+M}hz21`M3s7p}C\aW:XX7Z.mX0XE_rcKPa+NuxU-|g50 
+7e3Z10M4P	j l-Wtr"Z5&VRr([{*~/{*&O<8lU$Yz|gUN+YiT[tk./Zl#`Yi{kV2XsUK?uTnvALUX.rTxrd{,sY~]5,9,V>8Z'XVxMeoocU~jCU-f~D3{0Xyso3z?[+xSmEtx{4R9`Y7=pOui'e9zr|a~c)>-{X3	Xy|Os =gB	17{1`0-Bi99XE;U?ziV ++a]}zUl+`Vx`Ca8;```=R0XS`-=j(+X,MCbzeZz4)zobl#l6lt=y-s>mJf;*z3,KbfX]`,`1w,fNGZ@56,68.<oysm_?7?%?%RC!Txz,B1X"6H\m(TlqF/HnbfX0Q)>{b8n
+5wO^|X>)\.k.@)i	Y%
+,k3&:M_Pgu>+W1hrRge%&&K``;ntl,Fe-1w,f.3{XbfX]`,`1w,f.3{XbfX]`,`1`n k*f?jn'`=Sz3%<]ng/v
+bf*B=R7yMbf2`+X`D3{"X,t2FDk,Xi$=Xau^c%=X0Hj*f>cU}XTD3{XbfXXN~[KT1~`=#orL/XS\bf=W}KTzk*f,W."(x5/SX.[KT1~`g
+REtCx, `U]`wfl*~<bH,X!!CB`)R	`)0aHT1ni)bfX]`k=+J:&XI`9AK7[CLVk50^k(NVy_"HVw-w,`[Womq.nTKj*f>,Z,`1`RE`B9R	K1$bH,X!!C,YKb[3{ "~)xqrE
+6Q^>_kpY8z[&zzzI`vt_X\D-S~{`i(ErXSH ;`Mn\6h|C<+er*o,(_k!6Q~!~<Vl3{rRXrlvT"/}T)R6JfjVU$'`{!!XK`-Q{8H\<UgXnXbc,%Xbct \FJ8,`1w,f.3{XbfX]`,`1w,f.3{XbfX`n7oa	`nh$	,`=h`c,&X?<n+O+e|$XPq
+#tcaGx3X$h"5)0	<B?$37c`X
+
+Xic4L{dh;yd1ZHVOc!Bc!F$H/U]`:VZWKT1wLM	E`:=-XwGo_wVXq_7_}P=Wm_`M~n9X*XH sB'X=+_4H\Z7bf+[lc	Vg?/X73Osaf4eXM$y*Wi,^_5/+&Xx`,kXlbc\9X/`x$z,kXlbc, N7@bfX]`,`1w,f.3{XbfX]`,`1w,f.3{Xbfj]\B' C*\aDk,XZ:SZ3/0m5}^!Wz&XD`i&(`kBoS	,-,v[v/k!LX`hp.z,`ZKT1w,f.bKi%]bfzF"X~e%&z,0`%*l.E,5	,p.0VA%{?oGcQG+;'4=XD3{Xa_}a>^}[  IDATmws }>Usz%$)ZS3kdi9HVq zmVq$+D3{XbfX]`O_>>YKT1O0oq{Xe<+Fa'?8m;Y%,hv,Kot8n!-e5
+>{!>YAz+Xnk=VU,,NxVq{R0/}C<Ca~Oa+o:};XC<tMai-7/_`r+ [hT;t;*@`4vrwE{xlW"q,q5."&gce!~+Wk +k<vbfX]`S4WNY/[_.]`[=Ph}w/pK`-v,XSkX`4]pCaXn[0ZY-XA
+K*w<?+6Ffhvw#-V)K[*n4BU6D1rU+_\RKri9?4_sgL-W	K8*Ybk9.`,:L,j`ZWC-y=*ImwL`l$Y.<;8K;P5+ Xh`Ksk%6F7Vxht=^d?<D3{XbfX]`!dkt[ 8V|]<II|#X~^9Xp~gWzXpsp={>AZe}eF	1Hk8A,`=K`!/qxk'krQJxm._9X.OU|Z~BKuXV^\@L`*?p^w.)1`-n.[aiqjWJNB/X
+BP(
+BP(
+BP(
+BP(
+BP(
+Bg    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2/version3.png bioperl-1.1/t/data/biographics/t2/version3.png
--- bioperl-1.0.2/t/data/biographics/t2/version3.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t2/version3.png	Wed Sep 11 10:53:41 2002
@@ -0,0 +1,39 @@
+PNG
+
+   IHDR  X     J  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  "    *'    IDATxMTj3(w\@I(uK$i            mOaVqA_i=X4k	`54kc}Ys`-k3/>JJv4XvJ"6`c^J5k	,{`Gb{)9{3C]8XwX8yX^Xc=f[?/`A].XP, E "u,ybkb~SD;`(~K "u`A].L|X?%`E0(4k5gX jU?""GKGL	JzZp"`y2{*vlEdu`CL5J.H0&7:}6yj,eb)vMcDf`fEP9.=Td\c?fEfafAP'd)BsU3sr(xCL]vGaR Cr!f]M`?|N^+jWlvUai3UxAfJ}2b1|Oyn^1Xn4UVU{j.fD8?n2MR<)dRI5=V?t=ShPXeW_n~*-|cH[d[)<O^Vf[XGSok3~+B41SX +^,Su//|egi_`5a0{y?AYWj`U,;7035.3X]U qAGbX `.fbX c.ft5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5g'[ifYtRY^
+XrZ}Ys`k4gl)f:^J5k,a6ib!j!Xc,_'bnajYL[^J5k0PDic NVtKf`}z.+,f`*=i?yD]2w%swOU3#A@#8Xe,>T)Tdn?TX{ZyYsvm`Ysv%9Jm/*W9l:[-lTz$((^WVynK.Uf* ST4xCl%m5qfecU=UJ|VQhfP>Y}( 'rXL=hf'gyoY^KFqA_i`	6k5gX.f__vT?QXGL:Hu`CL:Lz-~|i}6yty!KGGle`fj\f
+[AjGt V8RZh!fl>:ywD$5gX&fu<y6Xgiwt%A3/w ]+ `em+tP|eQevr*PlA8O/*?>>\7;"VR |Pj:JyjK-fIKgxjK-fzbf*.Dt%"O{f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f`"F-jf%R)}MMW5go?f,Z4[mj9{CSJ~2
+r80=
+_vGM9{khZ,N4E3/C{)9{Ch.P"fZif5E_y|>PH{)9{;A_i`	6ks|YsiW5]9]X ,da-,~9oQ*KfObEjl,Y5ajle]=Zz)99Xgo.teY7,,%0k9`rjq5},qoU7 Z|EWy*Pk+	Jsh-k/Jm,k"9:.MJ-Pe{{8t,ZB"<vL
+Z_(_ V-G%cn]t^p]jgYYX\?]I-.uE9()r+N~/X6t]*]lqc2bX(+.2	X P2M23*r1X[X
+Pg,ppU\};rl-rw2
+,OEv?N|`az>4MSI"%qv{\~X!yhckoQRj0nu\EJ2E KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;lY>Nyh6^.:jXEWr`M,%w w}vU r`-N9Tc_Q`[3>lu4kx|nfXYb^J5k,KyY,gO^lKfN2)XkKf[5'-XK
+_k.WDDP8=:p.V&v:5goGu'fR,f`"!A`oQ_W%#fXe{V\]T? zYo_~),dfbf(RIn}dCY]._How@/kno3ARi3C03
+m80+(Z-53CCo'"(~(^-43C0?y7; 
+b>{)9{4k	ZQq&wZ|7\b.k0o;]'f*E?{Nte[iPNv'O=(9`1{^ vs&>ZlRoLp'OEN;Z0>pjV0?BV[C?UJ `UtF'j;l07krtmWyf` KYsv`dq)]<Vo]XyVJbWte?^0\~BoJ.#XLUr!Iy/?|`)43UUcqQ=X9Z3SUk`m R3SUF`e68j53UU[w;y'V.*U5gXK+g,9$xR,f` KYsv%9;l]X<sUef/ of[QGB!=#.k5>zTj.#VWsv`m?3+?3,fv6C;_
+zEvCKvki>+^K5ge
+U.Nhy=y7dq>#v|E-XjWtw=	;De-+1k.,;,9;l`	6k,6sb7s KYsv`-e$5g5gW
+Vk[WXML=jrWt+)E|M]HD2}|2
+%F<Mv-U~<[D?V3P(:k,f,QfJA*y3dfD;];,Yf]~+<zYsUp]2lWh5`]rG/ .3S,]fXL
+t`235.(nefj\W5gX,f`*iu1bWt<J>+O0NxW`)23H
+d/
+U4a;f,Ef5H,fqfT}]) KYsve`9E6\X6Lu\bnEsv[r23=}d]70dXVQhf{;`+{$&Tm>,Xr23=(FAO~G?TW}.mK,Uf}Ysv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9{3>vM|>Z9{C Ys`-s^J5k,s(8e_Kfe<XnVYfk${(\_Kf[t_4NUVIc9;l`	6k5gX#Z__+v+F]13U`Q'm|}L;)^-~j~)9NMsL}|2y3ELjY@8u{(\` ,7_* ]+330$A~8R6%Y%$#S`
+ulehC
+ccyufxyy}XBAXPH~
+'}xZ?w{V#`Jkk}7 +^{1^7mX6xqgu%\-2y\l#f_F6v6[#hrJd4n]dfPy:}XG$|2b[MJ=&nW:9m0G,4Os8]|,ztEN$fm3CKU\vrX 3{)^/7.b/sV[JfoezyVu2kQ7nF[]7
+?1S{fV4.+k_{]|RoRxCFqfnQJf~o]|FMLeg62M~e1ym;kXaex)fuouf}nq-X; iV)f-7|~uSS,UXqm_c5MuUkfY+9|V|(t ,9LJ^7]ZgpJk`eg`]4X4fPiurfzs{W%>1ONGp>L=t{^W9>ZsI2z4k5gX,f`}sjVc3S&`G4/n]`563/(;?d%o0"H
+ULPG#[`03-<3znA|Ph]+4k,H4k5gWepdUw-lTzO6xi]Qef_jd]70dXVQkf[ou|*[V&TM>,Xe`.T'M>%*3S9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9{{>>>A_iX|`i*/c\-Yc,LN/5goVz(3PF/5go1\aKf;ewe*<fp]yp(TR^XzvNVbtX}YsN`4k9;l`	6k,N47RYsv`-
+`[v`,/,=3bfb KeyY`wM ,ESXaKfEkpvf,TMh Bf`sUC.XP, E "u,|fIA_i`	6k5g9SWxsf^t!h?X"EAD+X	0c	,/Eq(]^X* "?	~mGPdVv_V65A_i?X}Ysv%9{j!-`h(u`A].XP, EjI	X`V`9;l`	6k,1WU>7SFw"^/0`3S}TE \.`y$f%~ksS4cM +AMw!"x?+Bs<jUr0`
+kfEP9.%o\2[Bldg}A;@|3ty[F^f=+zf,L5J5f5+(v:5gU^.\YGMQfu1XXXj23U`aT}<Xra`B>7gX Qef>(RF KUf,5lTz^"E;;K:U?jLJ KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f`Ol^|#@u4kgMV%	`-/6:D7cOrkkRQGrBf7E:c99L/5go
+8@f7,m55OSu4kp
+gJT3?ywhK@y!`s,	_f,	5gX#Z_[oUPj]&X">+ZNGd:*kr77kMwnRYs`Q|<]2$rzmM/5`7_&EY,
+;{ule`XE+X`LT  IDATV8yu wfxWVb]XS_TVb}(X]QUa/y3k>2 KXy5,mfx"`=ut#f,Xo7.A_i`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;lX7
+W f8n)LE	XZYsf`}v0?Mp#L+Z
+uXj]&XIR	+>
+`FKzSYWFVXP32*icW5gX,fEfK4;p"{)9{;I\;|T,2%p'AwOX:r;t,enE	hc*+Ul/5goMQ1c,/`)-/A_i`nWkn&jEyz"h	Ij3.*j;jZ$R0c3VX86gPn!OW4.s$v4k5gX,feOiZL-!f-]</L`EQ\U2k2wG)Xd??h9
+lv4~S{h<:=PvyaN'
+M*e<,Z2Enb.>Jv^66vy[Ez(X2o)>iVvCh2~Ofpfd5gZ+2Xn0^=BJ\$z'GyRwq`mA_c%,
+MPS`%z `X<08Z8ED\$`Wa{P;o3k~qA_i`	6k5gW*7OmG63'h\`~:l/p+Obg)5j:CD>_yMs<jU|tO~je/!")Do8o> %(X3SKRsUeB:~-o#/`3SANp
+VC1jjjWtE!W>F%W^	S-f5\B|:W7fqF6AoCdojY,R?awA7;-85gul:'0w=IT`>vd8RTeT63SmKUfoTEE0pc>3S9;l`	6k5gX]QtFMGL*Zo<:l$&l>FBf!fo.i``jn^RQj*mfHfmXoh#L:LQ +
+)^-43S6"XK*X~_DT27}*._%X.Qtvlm-K_r<{]sfz*T5sw\8DotL5&3fqUTTcNqv3
+8AFy?2SJfcYs`AAAAAAAAAAA @G-G    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2/version4.png bioperl-1.1/t/data/biographics/t2/version4.png
--- bioperl-1.0.2/t/data/biographics/t2/version4.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t2/version4.png	Fri Sep 27 10:31:37 2002
@@ -0,0 +1,39 @@
+PNG
+
+   IHDR  X     J  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +    IDATx]<<sY;:	! %P&8q(C-ALAAAAAAAAAAAi|X=LJ|F}Ysv`}4O Ysf`-<3=+7k|,]?y>oW5goV+ecW5go1#RYsN`_ >Kf`.=tBJ4k
+.*AXP, E "ucA.*j/F+_`58bX
+`A].XP,)e OIX4(2435.+,f`*sUf,3S}^<Xj.[v!"{<r<X$73SmR+ljZif5`fpXg0jevk~*),OYAjGj/}\UL!
+)^-43SAM@Qup}Af|EX??GU?[]oXZq+LU"i:\rX3u[Wf|U}*Ly
+Yt`Moh{k;1]T*#)jk`'C~,,*5Q-f
+n`tT3~m
+P*MTu/ `TOC0?sYWj-XMu^^2svUaXNc.L: Vsq.h\fbX `.fbX `,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,fZok]fe=h`,/,GJ9X-9{ke=K_gK7RYs`@,N96O]gVT23%MG`?asKfkT
+vK+vX]ly`eK j`	6k9;l`	6k,;V.`G_
+,sZ2w7T8XL=tg{<"+OLPfWh+#XLujXLuJ]! KA5gO5gXXh;yE*Mg+%*3S%GbnEsv[r23@P&V)d2g[,i33=(t*8RZ@3Sm;E)%}X=hf< D3SO=U={;\X6LJ KYsv%9;l`u1Dd,Fi?bfj\f'@r' 3fbfj\fsS#CY9X<Wh?Kle`fj\f
+[AjGt VRZh!fl>:xw;D$5gX&fy<y6Xgiwt%A3Ow' Mm3 `eeWaf|U<;&,q0G_6U;`em|bonw|ElVeu6Z +Z k<,S{U<=\.oJ.E0,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,fEZ<+KX/5go	S=?{j9{Ch1e4_l&+7gRQa{}Ys`~'EYhf,_RYs`]0E>:D7k}kRYsv`7F9;l-Xl`aY7,,%0k9`rb#: Ypo[)XYs5G(WK/E5g?EM Yssd5"8WTNYsf3yKfp{bN5,8v\f7"{AWN-<&|ue9n-`qXUhj5Oj%A)zN%Ee-Rd1G\;wAWeg.qCa8T^PCKR[KXeCsJHT
+-// +?unY]tp]jgYYX\?]I-&uE9()r+fV<l(Tj<8CK\[g+ePV\d(Xeg%7'`]hC4]Xka2`ql-bqk(X]e
+16Wq9oWt)<UWCqrKwi4M%6ZXf*r/:sEJ,A`7^~{Rq*EnX&/R:`]}X/5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f`|^{sb|CsA0fYtU+dRxz\FkZh
+kg_`\.Ga?0`w,7~|kfO2O- +b<^lKf;e5OS4)Xmz)9{_I&+@zMz)9{k$k}qsr]k
+u'G{VXPQGrp9{s4RYsv%9;lX<4$0-*dPK =lo~0JWky}!dZX/Kw]z3CB}!}7I:Xx}6`-_m&hU]*mfHfb]aVfEfafh+MXdfbf(_;xw;DUVlGx/5gV2c=f;u\6*56vW4r"tLJ8LB~"\D8\K0]u88fU]dnst!
+cks\a`E,[v8;izEN;Z0>pjV0?3CK!X}J O^X
+>-}&-NWj6k~qA_i`	6k5gM4ShnfU`$v|EXB|
+)90ci43UU]CJyO?lX
+LUr)DTrkqTU,!X= KZ5X]a
+-S}lh]x+v|EXR,f%m3WUj]Xa<sUef` KYsv%9;l`	6k.	T K@7 fEzYsv`Rsl**2k.#VWsv`m/}L KvAi{.@.VE;17Z./;E;|V+1k.,U.Nh{8__}]`mQGb}Yjb-+1k5gXk,96,9;l]0XG7<sK	f fU~V3S]'/(yJfdr +,,Q9yf=-E	*zrf2.`5=e?3vLj.Y/3Y^Dz<(GX KFQnWHvdtaw{+'"WtyV/ ?+e't9k::-{f_,]fXL
+t`235.(efj\P|4k5gX,fUEb?yD|bWtk1NT`)23Hd/
+U4s1?3"3S ~3Sb+`23?bo;X?e`	6k1h;yE*Mg+%*3Sf;W[>k?\6Luz)d-rX*}j	43=h]!* A6Lu
+Qef{UyvKFqA_i`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k]OVb4k,jg9Xi(R7
+-91?9G%RYs`OqV}Ys[y
+Be/JT
+Sx:/* A_i`	6k5gX,fE;DE [~JR(6>~e|?yjiG`z{p&>fNr][y}fx, do.OWIv_n }BrXiV 8R6%Y7KLIL{03eawE),XrJ
+.y;c		`]!gfW+Gjiwx~_gQwCXjhcX++1k	 z@{a5&s{Lr8K{+s:?/{/zynA+.^W"K|f{wohNfguA'#vn`qmi	?{vjNNg{?t5G%;o?^`r?=]w2p:h[nR+:cu+;30 l`goKRrr[i|wxc;[(7t.tmWyf5oY{~]|RoR>Lqk}  )` +L{]m6ne|>435}>q-X; iV)f-7|vuSS,7L;1XQVk V+7xW6X.Xsfx)noX]'"w`uBn.f
+_vC]<9x_iyOO,h33\{]xku\'Jf i3S9;l`	6k5gXkwY+f:M2hR2jlf_Pr_G1Qw_~Kr1"H
+ULPG#[`03-<3znA|~Wh]+4k,H|4k5gWep6Pa[b23/0l;*3meT`%M!(o`m&&Ta xWUW)U[FM~A
+oQ)%}X
+j231(%]AO~G?TW}.mK,Uf}Ysv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYs`}>}u}9{;)X3T^X3LZ KSy9`-k3/>3-X^J5ktWh9Lcg^J5k)bj%Rw<XTuy0v#+7+"`aW1
+:k)/Jr3sA_iXO}Ysv%9;lXhZo"h_TZ&qRY^X4){(f,5; _ XzK9"&R&[&+X*K+}4 ,56+,fu,]n`A].XP, E r R/H5kO:%uJ KYsv%9{=tc7{#f,XDDE K^y`_b&,Zg,%xh<:=Pvy`U ,En_	^GxWdVq_V{j9{	J KYs`=y*BZ}J`A].XP, E "5`AZ0+j`	6k5gW*nz#{k}>AI*X"eN<rXv;m~I5K&oXAp]:DO"4'`aWYSv[%`M_yfZu`ZaE/3-O)tFvfjC}Tj7SHg&{elf>B`onv]2}Af|E!XQG:<cE+>T33U7#.+`V\U{>;T}P*3SA6L*X//ssKUf,5lT
+Qef>(RF%?_}bjS4k5gX,f` KYsv%9;l`	6k5gX,f` KYsv%9;l`	6k4X=2QG|vdjE$,epQ1XZYs`Yr#Xn-z8C9{3Mcn{7Xl/>Kf594C K[y`o,0D7++8g{)9{3 <>xz 2[bP^X-KBKB7 f`"hU,5g	VHO.,Mu"Z2){j}(XBn:/-OWI\te+^&{npKkXDWp	Yfrvh2kTO4  IDATEdafW+G^g:T|nR3SZjhcX++1k	[/*+1k>.duv"~9P ,aZ4 .3SZdXffW`.,| ZZ}Ysv%9;l`	6k5gX,f` KYsv%9;l`	6k5gX,f` KYsn`\+[^XM2J%`ifKg
+77i0V|h+U`RYsv`&MK+'x*aJ./,]g]6a./Z1XcI(,YBA2X A_i`	6k5go-C;TZ&qMRV=q0c,/,w>TY& RCpTjX49GWlw}YsvUc>eO
+;^mfj\Pap&!OWD6f\T7fH@AaF-gpSmE1V\s 
+	Ci\16H(xqA_i`	6k5gXe[v:d66~2uT:EADqUC$){ `$_h9
+mb5~S{h<:=Pvy&Of7*Y KAy.X5e6q"b=/>Jv^666y[E+X21S+7_0ev/D/+hA2k~qA;We`{<zQH/N:X"(im<1'uJXLn, "QqoK.\1cA|u3(Jy`cqGqQH/TFv]S?gj5O9;l`	6k,1WU>7%oS(_glfOS:lOpn+Obgh Vn5OSM7!"x9jZ*>}Z:X){_yfZu`p<,r-hyJekfAPt|u4*"$ yPt.]W>TTcV3,XE9*"Lo13,9G-+	]l"916L	nr^&{sVb"elyjtq(o
+-N^s]s yBd]KmhkG*@ +X6Li33&(TQefYPVL5_D)}^	;o135.+,f` KYsvLSgdA +]fN22B02135.xs)}6yty!KGj2!tbR035.`3G+xCL:|tv `I2k:Oq`2.UTf^PleN7CgN;}1`56H;oGu|`w/EN5yP	b grQ3ajn1VQezR9n~+FsuL*fAAAAAAAAAAAT1Mx    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t2.png bioperl-1.1/t/data/biographics/t2.png
--- bioperl-1.0.2/t/data/biographics/t2.png	Sun Jun 30 21:24:03 2002
+++ bioperl-1.1/t/data/biographics/t2.png	Wed Dec 31 19:00:00 1969
@@ -1,35 +0,0 @@
-PNG
-
-   IHDR  X     b$N  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +    IDATxQqqQLQBB HVgJ3EQEQEQEQEQEQEQEQEQEQEQeMb5`[fJ8f5tT4[^tM|igA_iX]0M+l9{=Xa	KT;KT%tqWHVc}z `{A_iXR`QMTE`QMD&"XT,Dj"~E5,qRkP~SVDJ;`*D~Kj"E5`QMD&eLz!X?%`%4coiV_W-g'Xf	rv`w2?_1+&kIC^]$CcO\f,T2l{B
-cl	sl0kZAeXX.b}t>2{R5NpzmBEG%.O[!j=JU*W>e~jW(j]J=:m	\e ]JU*Of
-cCxzZQg+rKM6nuEXd ,d^}._f\H*VW:]+kJTrD>m]Y])$Vt=Sz XiS_n~*-`I4`-^lm|-2u41=T[`Wa
-TX$X+$X+4D3~oXUUtzxAVRU7,h;^T=`51?:%XLV3"XM`51,LV3"XM`51,el9;6[N,`l9;6[N,`l9;6[N,`l9;6[N,`l9W|Z?JrgCLG+RV4[^2_gS0l9{E is+l9{EMIXOl9wrn]zj5Xq6\yDk'>x@ +z%rvl-XJl9;6[n,I;v|8XGOV+<U!R_	*{$O5MPnW+#XJ5"XJ5*]YAE;-gO-g'XfM%*]zE*Mg+#R_	*5us+UvgeY/UbZ!STt{LK;jpfUco3+HW)U[GTzrNiQ
-CI	BE`!NPZgUt}.mGf}rvl`-g'Xf	Vd>/~_1+/(yk>#4D_1+/hgskKpw1+/h!_,Wh?e`V_f VX!j=J,Q+
-%]Y~A;`,$l9;bV=g|jqvNWrT.+=Tp	~`7J>t:}l6og9:c|OO,/=@)G|{WjR:JuK+fI+gtK+fzVbV*>\.o\`:Uo-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf%ZR=+fkuvi|=Ol9{Ed1e2._~4[^,Jie@pGJW-gqJIdH^-g,E
-#XX#Cl9{E8ymJ^-gyc8+,`u:g\a9]`)1vy^$y}EBKVzxMwJR~l9)X*d X QrXW{^B-g?Kq6frYeY7,,%0o9`rjq5s*qoKU7zHEWu*5Q+	*sIdL_X"EwulqsteU?.ph9W:]4*cJeh%6p^jk) +~h}T)IH`{Xr/5El[7C&'&-\Y"E	36E-&E5))ro%WseCS0u5.~r,^Y=XE`EUvV
-{ m(RK`sW9~^Z,-ET,nsuK+g,pxU\mjl)rw2X3UWC97aJJm,)aU\7,~_tX)'oV%XUM+_t$z/_4[N,`l9;6[N,`l9;6[N,`l9;6[N,`l9;6[N,`l9w|k>^hME`ftU+R.s|5ssXS?*a/(+;
-gnCl9{3I0Ey|`%lguzj1X=X0$1X+yN/Qk=P7f^^-gd`-/nW\rWZs"2q=[h 1J~ZU*q54[^0FWb/Q,`l9{=$xKP0<[UZBq,By	zum? /wWn^,qY^H//&Arx~Rv6%{B)XpVn$Q0+MXEAw1+Cw"z Vjffu\K6*5VvW![*L3('NW4t$N2IxN<uy'=6\u29u:A5Kw`m0a$ezg{-Xk!o3g`E7POF`"XrJUebnT7kj~tEXmWuf	rvl,97WOO-g7VbUBXB|
-auBphVQp!+]4||!jeZGN8w>uk
-kyeZ+k`,fZiM
-pWhZgju;v"'/t2rvl	:fZ3?j`-g'Xf	rvl`-gGky2rv (Fh(Oj,3DCHxrvT{O_hgg_3,fE;rd<h'w.VE;17z./_kw0a%2E;}_K#KsB-Xf;QC`,fe`fel9;6[n,6s2rvk`Ql9;6[rv\h]`l9Qo^[2bV{Ag|$X['<X<ZW*r	je\W-kz*F
-J.Y.sy^J}=R9d6,$R@$]#2+/e2?_f_ V]rlWnh5`rC/K-R,[f%XJJl`2+/(?neV_W-g'Xf	rvl$X<-:/v|8Xg/tk1NT`2+3}qWhTq9c2+<C`7+<.B	)R.).S`rvlXcu6\,J5=\bnEsu[l<2+<}V]CvQi?bI[5GTw:UW8RjYA
-oQ)%}&X
-5JpxdVyP#R~:\,JJl9;6[N,`l9;6[N,`l9;6[N,`l9;6[N,`l9{5>vM|>Z+}r`V=&0E^-gzrbe_D%r`9O4@+|f8e5OqW],pyfktH_tM A_i`-g'Xf	rvl,dymX!.bd]7dYAe,w9N?`bVJWKt=j.'`rp&h>nN
-]fEJjy@8u+.`9}IXn2>Tz7fVJW+`)YH7-XQ)ZQBbYVft<X~`vr]4[Y(zE kcaysft{5o@A"XqW(v}xZsL=	u),-gpn ].Xdw6,|[[<d8vnqt3\-2y\l#Y0?Q.20i+A.Et]I,{C\v23:im R-nJ=&nW:9m0G,40n]|,ZtALN$VJ5X3Ag,u[Gw]gf`eg`OJz["vq1We\ltV~;\c~wjQ5nF[MW>R{fV/+w-n}JikE*w,`M)Xt7oZo/g{{u;~4v|c~7,kXa|_]gfRG?	-xVa0KZM[96zdVJY+LqgSyX=aVv`R9afV<X&
-&? + k5`^zk6a<X~m ,C5,?^k9ofxCzth}J}/Ytk\'ZX+of	rvl`-g'XfMsj	VeRrdR]2lV]P	_'Hw/t k7]o|K$w&J&LZj<#zYfA}~WM+4[n,{H~`T4[NK6Pa[l<2+.a/<4vs+UvgeYvABLK2jf[XEZJi5jf+=D0`).(zTnv,R~:\,JJl9;6[N,`l9;6[N,`l9;6[N,`l9;6[N,`|L}rz`3`Ry&f
-8`Mk3N?s=XN/QWk+3!F/QkHf8cl9{#nk.n}rj`\BW,
- +c}^o5c]_w+AZ1l9{#4[
-o}rvl`-gf'Wu|D5[^I,k,qM)CIMo8c,Vz7#X&c5=~h`-L	L%`l/QK [&+X&|TZMh `Jl9{53aq,Dj"E5`QMD&*4Ra8.`jtJkf	rvl=XHU:{1QQC,"YW,	KK8ckfFGb
-e<:X`<<8XMK]a\,VqC_{}r`}'+,`TYF;TG,Dj"E5`QMD&2eLF*E3XyVl9;6[n,yb~Tu7lJ	*`M;6CK`UkLK2c+Z
-Aua&7xHqw:a`KkVF 	N>heY
-AwHAJ*=x;ztB;0Xoav]rTlf|Cl9;X'rV?jtlmu3+<'#.+`V\"X
-=JJ=kQs__(`5+<(g,3l<2+<(2#R,3l<2+<(2#R^||QRN=5{f}rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rol^|#54[^gMVO-E`Yfq?'}`uk;^[;DW+
-=Na4V+0l9{=P& 2y`Y+oqX^?kwZfz]8+8g/l9{5 <=xjo<X5P`P`l9;6[GFrvL,/ty`}uUn=P'k^+~2dosf%-;J.t4Wn;5t^_Io?VV-M2Vn+L-EUe,	`f,YCE  MIDATXft{r|;y_Jb<x7jVJWKAm
-qe#f-5Ee#fK&euv"r`+C`Y3+5)<XGw<"XJjq.Oe.o,~ ],X5l9;6[N,`l9;6[N,`l9;6[N,`l9;6[N,`l9{3Jo.7 f8o	^,Cl9{5>{F&M&zy%_i/Qc4!G+'x*a"G{CdYV/Fu1By;`
-q(VIcl9;6[NKdw {jX"X$_I*H`'g,a
-]dy,$4AGK&]Pa{jX2Ge<
-X+;2ZA_i`=12J'lV_PahU'Wu6C$Tg\LU7UgHPQqF5gxRu1VZs W/hs$vY~A_i`-g'Xf	r`S/1?q+QQC&fo/J`$IZcGoM<#W,eL,wM<_MP	IsW]^I'
-]Y@y-X5d6qK"b9/>IvV67Tyk%+!Xl!x^Se/|p|`f__F+2Xa0^=Bz\/"Mi}:)o&*6OSNZsj{fPc"!vY<5j? J
-|ckguj__W-g'Xf	rv`f>srjDkJ	Z8m*W	nP	,
-?;cW$3@ru4hykW`qWYS~[O:e+oT,!HB;| 
-({_RKWGKQeYb:\2/{gR[(9x+aM#XdlVbPyb63_jk_\[C{z&o1+U-;'t},Yf,Tv9qgoTfQgm~fjlY7NEm_&1SDc9QGal~fmdOyyrrv GfjugX&xdVZPVJU_$i&90."Pw'bV_W-g'Xf	rvl`51H3fT`AkZ~A;>d`%.0w1+/hsH!H6uy"KGjq.;YbB{YVJ4{Rv6""XHf	VCS|0\ yPY{AoFqDR){-R{	m.e:m+wkLOZ!FlONFotJU%3gyUTY4c^m0fEg9:~SqeEfrvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	rvl`-g'Xf	r`QEQEQEQEQEQEQEQEQEQEQE OE5    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t3/version1.gif bioperl-1.1/t/data/biographics/t3/version1.gif
--- bioperl-1.0.2/t/data/biographics/t3/version1.gif	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t3/version1.gif	Fri Aug  9 12:46:29 2002
@@ -0,0 +1,16 @@
+GIF87a     {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +                                                                                                                                                                                                                                                                                                                                                      ,      H*\#JH3j CI(S\0cIMrc@
+J%s):JXB)5bWKhwU4 m*\wEW`{.
+^0	MKMN>xXn`v	l3Ew^:4kUI{[s7[#<tbc8]:oHS7X<d6{/=gs`aG}*]v!E	x^a |!v&j	c$^wx|=^DidLL6PF)TViXf\v`$"T@d9kpgYAj|thh
+&Fjhj&Vj9^b)"h*UYj*(dIh+k:*=mNSUlA2$-Ijm; lom"&bmo	,dLo0G[p]oOnn/1;2 L"{12)+@/|/-1[&>l.77Tq54@9u1M59M-!5Km6o]5=KY5B7{^mnwK+oG8vkn}43I{#_yS=/<x]~JOo>o^|N>X x.{'?uE- zZkWJ{$V@!03b?*.n5aKaEl&:PH*ZX.z`H2hLC6Hp#Y#7x
+->,IHB$FA!H|<$i ML	QLz(GIRL*WVrt+X |'[Oz%/k	+A9J,1Lpy+c:K]TTB9i.D/bTYaNl'3!Oe"+O3IR<%j6	Eh?G9g,L>Pgn96#*JSm4XZ(Oq%,	j:Uz]TKf;9DV'OLU5VyTt,+9mJMZi\uZ|uSDI
+6TSb}SgWjAV^VLd
+V3~Md+.X-jJ]5,JB|:{ZTVMX+}27%hUt?Ucj/"W,vhMGH" hR|:o~q/y;c/|u_/yvCLG8NWWQ1l`V(;\cuk"7a1tY|UFL*[XL&P%k0\,V%3ax#M@BT3<):6e?>-Sim%/UKh5i5V3Y:lUTas+HC3^L}MSNqW12]O7D$`xJy_y*<v3'N[7{ $79W=f>/WXN\A)T19QqfEGt\PcrHQP\cO]65pN}tbo<f2}tHYx
+{<_-"^I.W3r-w~}+%q\N{zhf6{HV(/>;{7uXO}|o}Ksw:IfwOW_sK{ufjGS4xk$Wff7XkelxV~WOjw]Ed }'~*XtTT^3hg%3(XcX7X}h}n=~WAU&wxh[{Gk$[{	!Fmzm%PZXyX5|RgiQzbdwc&[E}HaanEvxnhdWT|fRR5*NNv]|x+V(KFEB 8Uw((w(f8'h'DxhQ}\`&Xe(HLR8Nxoh*(&Xcx#8hXhaPc8&'ywS*xg&rYidfv!	l$RI%9
+	6,Ye]Zw9L\4i(T4XWy(m8fx/G'!:		)ji=i'XD6_xf y(<xu2(@POi8UfIacRkII%9Ix9M8&9Kci)OmyIg!	LQi+v	`9dNcwyNO#@))1	P95D!1uW
+)`$0yzB0:$2bMY.Lv9G?J&ZJjLNt)ZzW:^YZ*0	xR'hE>9pr^ZxDFIJPHo b:KXw8Z  j!*'FA*E
+ *zJjyyGE
+;zX{hkZE{	{ Z{b}V!{&K5<<{(`g7PQ;Z{6OW;lX|U8Y+7+UT :9z!$i/Ox[]zO*}t[j+{fgg.y[s5`rLi!J9
+qV5;9	zPIW;Y(9J[+*g;+Ig;kq{;7`v<\Hl+	lb
+rqkZBq* ;[*!,kn6991p3P{,lJ>A,.|JN+,AM<o3,(<5jjlpr<t\v|xz|P4H~uKb^1eXBYu4R&trt"/\p3'!;sa<*'*vT6uLnEI@'#y|*lF8n'&f~TXvGLgLhX\J6~TWZ+hY|J
+XgNY;fLTIGxOzWeKI9hwghheR2(XR,=/1357m9;M=?-A,]F}HJLNPR=T]V}XZ\F^b=d]f}hj=`--oC=sq=uMy{M}MK
+-IO\]mJIg6=I?7]|\Xk	\nl-IUR?I7[@KZIMDM/=]}=9Glltl$Nq$"IIgDGH!sr.I^Gtru%HQ#Bv\-ep89^M<.g>@BNF~I]INfC~L.r,xERV^Xr\bK]MOngTks|lDYl>7{wr:>8.?YPZW~pU}TnbW=tNqqf7^yq|M'j+\.&,MNnKWeV^e^Tv>eF ;
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t3/version1.png bioperl-1.1/t/data/biographics/t3/version1.png
--- bioperl-1.0.2/t/data/biographics/t3/version1.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t3/version1.png	Thu Sep 26 21:36:56 2002
@@ -0,0 +1,12 @@
+PNG
+
+   IHDR       )  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  IDATxI:E95rr5&B $26BmH$1  p7i: 2iP.+`7eyrkSt(*0~If25QKpa+xk_ZXC@JE{5ZY"]2KrJZzaqElT#($fR5YcL`v2c|6(!NSmKS4rxphB#W    av md`$
+/(s30,ZHF48~'%   .^?c.Fa; VH_2QTpLie],\X-r*4[n5{HJB
+D{B\OqYzSj7f^$,K<
+G!#r/{4!>,e#w."jj           !;xWLGLu&}5rAp#H^       :II))MN^R.^&hMbXmc#_%s42fE*ri=Os~[JUkY#{u;Jn(KF#iT.?mF
+:.&{H.wj)]j5Rxv|V,={))C`rw?>&Q.e;lj;r#KK^{H	71)LSm_`8Yr=19&K8],.[N.9zw)-]V7v>_	}-p.OuL,Y9=Le?m-c(R	e^u{Al];Sh,{6r;3Ey7kR1     /-=eHR/mWrZ6YZ}-Q]kqo&S.dk7&jZ^9{3VuqFv}1E-dq?K&{:40BW8XZkVC$/&b&@OGod;{^uL5py? Z\0s{h;sC);c;s;           f-nqwkZ;tJn0 S57@_?k!S#wx:'"       |SyVo6{W!^GvqsUgGU'b%bJjlU--?V^;$98q[we[W%_/\C7i=_p]8qvm^8dk5=#ks?#dNaCH>ml[q8;oG8C7\C{wi}yycjX!otOjh_TY\$Pn2:vZ&t:|K!JcYp#.*ruf[ifXCg?2?+g^TVZZb&kV
+5T}#=
+WKqFi^VkhLlK"
+Z065L~ >(3ikvmz/RVxoivyf]}}aD;{8=*4{6y^Lue[njg<!jW:U[HpReT>iYzw"B'mz|0K~raOo\-j<Mlkr/mct[-6g	}|{T4U}wXcRO=^Vj\S,3g/9Uvpz?D<!LN&Y4!HN$~e`WWbr9v?-A5:|hVjhJ~'IUj]Drm/"  !y|<'	*{t7(w3E#m1q61$vrVr7R! .BUN|R~]IH`rBJ}yLO,rp8.qW9<qqr_kZ5NU$9,$rF9fco?2)wMP9U]6'veQj"v@]Q{a0gRTUL=LUML0 c/#[. \+yw2Z~NeAQ0JARCfrrg0CF wnr   /nk'EY>Gf#Lyl[H>rDpUP#Ct|9@pY'rO)s$gr{xaX<}nZ          fZ 8I) )Rpq~UD(Kq/6Jb1\\SW;tQ!,LiQ<M=d
+        uKM9,|p,+ Z^V"RG`+AK"w'8>Y|$M[m5~wp1a`(wE)
+={:Un;0P	ODe8q) 45-|y30`f`7?hG{76o?lL>|y30= b6T `]-g?={#:W1*1/qz\Ry$DNA.SG$O]3Q<\)Y95",~              p#ij]3MEi?;;jE0"Ky^k'z(6C8I;#;VmX750)| ||s06_8/F|!w_nru-OBx>\/Y}RP/"g}JBrA"w~}P7=p.;evp#+	R:\f\.	ruW9wrr>:\wR|UNP{?pn0[?p	rUNp'	nW9}@p'nr;72-    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t3/version2.png bioperl-1.1/t/data/biographics/t3/version2.png
--- bioperl-1.0.2/t/data/biographics/t3/version2.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t3/version2.png	Thu Aug 22 13:02:12 2002
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR       )  PLTE   {h      _k/  d p+ p     d /OOp @  cG 2? H= ""piii k#U  ijZ.W\\EE < wFf  **r  ""i22 p     zAi K    z| 2 PUk/H ` <q   R- i#  IDATxI*FqcQI]/Si1Psj  i>^ O4a(~ETy,\rplLdM-jmL~XJ.^8hWk~iH=X'#Ks^TdI,XCU7H^1I[Y xxm<Bb&[k1tf`+CNkS,8,K9u<M#S&42Xp    n/.%H,rw[0^Qtf`X;rU;i~oJ   \bJD]N><S"q|1<gQ-9?Ku1wDy\S!Bqv*W C8K	^JM#rjr.Vbahyx-Rq,e,uSC!rGr/%{95!>OLi#w&`Z            hH#~$1E02#rIya`;p##w       _e_iRj_r
+Oj&X][G~JnGlOcX4bE6+r[G~<LnI;wVJoZ`^w{b7!dO*4j^N~T/GesYAAUAgEsDp_MKB
++
+y%KK>lkJ
+i\s'1KW	=g1^)Sm]`uw~dJgRiO([QI*EVfQ\Z:I-]f7vVgh|%tzJLB	'=)X9})XI~^S-?elVr@W^,.l|*;^H-}mgg^Oyi      6<GqQ:6lv\kdi	[Q5<7mCbt843#ypol)J^kdY^b?;}L!<c`2?,M1PPZ&i~1`69T_-};J=^&aoy1{3Vy
+[3m.;c=i{wr?-;cN           PdYao-?nqw{;t\r7Xw)T{/tOu;HMUa@Eo        PyV:\!^WvysdWvo.,yCMxewYSX?Wqf*=*@K>G]_ .9Z|Y:u>+5/9SVpriz!k^sn#dLaK>m,[powxvq.lm.9I/CYB^'Z aYQ2w!\WM"2t;|K!JsT]p"&*ryf[)fU?2>+G^z5?>jh!qLV1[)w*THykS5wNXKc.dE%SQ>JY)X'w?D:+`r[cj$l )IkH+r{	YM;.,nD{m88=A+UZI@]uhYJ#cWZ~9$KqDRwcm~4@r/[%I?|1K97mSy.9trG{&w5{zl,Uea6g0Qs0T /{qliz&4Yr.W
+|7WuK0	oAr_)Ar/7r}*o(w-I|VrhJ|%'IUr*D!Drm'  <~XsrK
+8E<ls8=,%l'~H<[nm.'<'vMu
+ )wYP@Qamu?7rBrsmv U3m>|~Q;1N`[Zk&<i *$D#Zw_8&_L{~wI+]@,Jr(83Tm-.rWGqow^m7<Mbejb((l9l+L \+w2Z~N w(ncIXw%w")!:3hAp#;7H$   Grx|5#woeq"3pQ{$)s.FWE5K<.Kc E!(y|W.m2FK+q&wnGQW%'6u          du cr/U WO[?jw|Y8L>QYR"Dlu7sr wavfO7ScZ%CU        #>j2f[~ \'kZg	RGF?peI+$:vo`V,&.I*tVu[\#7)]GpQBOUs[= ;0&tTbn\E  unUyfP:oUyfP:oUyfPu-~kZ7ATATAT= b6u:*_ 'QW)KHvRyD
+{j)b<e"w hM8UDX#	Epi]J\(.HyX              4LSQ	r;H"wow\T< v ig9rWgr{QFCr:38 z!7chsA08n7rF|#]Xhx7j|#=X"@bGwH|9}@{Prw7j-w~}w44;L;4;L
+uCzYN;a]O0i/;f9wC:A! vCN0	nN0	nN0nr;>F wzLm     IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t3/version3.png bioperl-1.1/t/data/biographics/t3/version3.png
--- bioperl-1.0.2/t/data/biographics/t3/version3.png	Wed Dec 31 19:00:00 1969
+++ bioperl-1.1/t/data/biographics/t3/version3.png	Wed Sep 11 10:53:41 2002
@@ -0,0 +1,20 @@
+PNG
+
+   IHDR       )  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  X   IDATxIF95rroP/DUH c  nLz xiC+$wUM_8e^ccd*%kjQl(`Wr:A;ZK@JEz=i^Y"h"KbJZZT7D8W"LhYt3,^1Pt3Xr>M>]Jdee'dd^lnR,84)    l0u~	0NvY,N6.Fb[
+723ah;ta`Hg'S   |S:'rZo$~nQ<jIj,;-bZ$BL~k}W">ZKpr7 rrGG.Vbahyx-Rq,e,uSC!rGr/%{95!>OLi#w&`Z            hH#~$1E02#rIya`;p##w       _e_iRj_r
+Oj&X][G~JnGlOcX4bE6+r[G~<LnI;wVJoZ`^w{b7!dO*4j^N~T/GesYAAUAgEsDp_MKB
++
+y%KK>lkJ
+i\s'1KW	=g1^)Sm]`uw~dJgRiO([QI*EVfQ\Z:I-]f7vVgh|%tzJLB	'=)X9})XI~^S-elVr@W^,.l|*;^H-}mgg^Oyi      6<GqQ:6lv\kdi	[Q5<7mCbt843#ypol)J^kdY^b?;}L!<c`2?,M1PPZ&i~1`69T_-};J=^&aoy1{3Vy
+[3m.{yfOZON);};s;           fu[6c[1]#$-W`=4 K4b/`s*}w#R;CU/`[F$       g(?TG7n,*W{3q^~}\;y8o1o5p^|P5_-^VV;$1AY2jOg-oJ3PQtj.wi=_hw8pvmr/\ulr\~H[=S8K`f.9w]wi.[C[wi}yycj>Iie'94/Vo*H|3'q]Hd1bL.~\$Uh*:3H
+\*YVJ+lsW*+>^Z:ZqHk>V
+
+sjeTmz]o(Y{}.ywVkr/e+s94b|6jJE-\C	&[+w*D4D46^k2e}NC&d7}5"{A^$?&rjJVPdrWgHX_I.Ri.]f<!j7hr26%`r5<d	xEFF1_G8l:ITEmM[3KUeYXkMYn<{zc5&U3<}^n.ya4[f=;MVh (*G"j]A+>LFB[u{hW
+| q0r_)!ryflsn{3_I~Go(
+y&~I  0$u/N![NOK	r7_46Op".lmK	(e]SnB@]D+?.|Dun]&w)"w? +<GwC|'(_qo"Xh	O%a!*W3l>dRJ#r.NUceG*[{|(BgW7dzn
+`<71[}!#l-0 gAzE>( l""}X;A]H
+pA08Ztf`h;7@p#?3    xyM&*yxYD*1'\6CGxawm!UBo|/ eQoJ&=}$/JD]Q;z:3k	1"xhnr          8ij&K#U wZ/ig=_V7%%pmbvCo) wo3q.CvX(x/{sP        -w(; Zl/fpTG6>\s6|
+.I$rw>?K
+FV{#/~ #ufr;\C\C	 FXrj; @sunUyfP:oUyfP:oUyfP?hG[nA7<y3C7<y3C7<y3z 8/N!ltT N`]U-g;=[#=:S>*1/qz\Ry$DNAp.SG$]:3Q<\)Y9 5,              p#ijW"wD;<=	)?,fGy{ANAhs.U4qCr/tf
++q B"YCUqoK:7 rBp#;/7CSP.~4. r;r/Ew r;Phw_`	`]W
+ufr	zYN{aQG0i/#nw}7I}uwR|,'wYNp#wYNp#wip#;	}@p'7@-jg<    IENDB`
\ No newline at end of file
diff -Naur bioperl-1.0.2/t/data/biographics/t3.png bioperl-1.1/t/data/biographics/t3.png
--- bioperl-1.0.2/t/data/biographics/t3.png	Mon Jun 24 20:49:13 2002
+++ bioperl-1.1/t/data/biographics/t3.png	Wed Dec 31 19:00:00 1969
@@ -1,8 +0,0 @@
-PNG
-
-   IHDR    1   C  PLTE   {h    AicG@p <qH= P p  E .W      k zi"" iiiK     ?""/jZ22<  z  k#R-rH\\  p p _ d 2 i`   /OOwf2  Fd  EUk/|   pU**      +  ZIDATxI:E95rr5&B,$2#(# 1M{ S5M#w_t%2r]N~kSx
-oLlM-im\~XJ.^8R)eR{qK:d'1e(Q%}SKT{\["u+"L+($fRY-;BF1be4Swm*%(.8!M''R`+Ou	\)    `+[ md`$
-/(s:30,ZHF4K?~7%   .>1s.Ff)w@lfR#	|1gQ9>Kt1w2D	elR:pkhVrC!rGr/e{979[GyIz+0ox-Ru,,wsC!rGr/e{97!>Oy#w~D>j           !;xWLGLu&}5rAp#H^       :II))^%\M[GJnGlcX_EieHl~U6#_{^!=d5U-0w{b7!5|	F?O]KW\~;= Tt]4M'\\"JHmYzzb[SRM{w?9>&=Q.]e;j;r#KK^{ribl	m[SRwwHj#gu{Z3'TI\|fYtY$Fvri]\e{c?F+S/v3mt%x`;g<;\,KJ&K!\X<g] wwah,{!6rO;3~.ol     gh"3Kl_kdi'lqFA6|_3{3A:t!VNyDM_FR.A73&vPw`C?y6el2j$-7Ij"lQ2t]|cp jS =M<q}l'-`yxP|';vN           E;l--NAnkR[ar_`=4 Ktb+s*}w#R;CU/`[F$       g(?TLj~PGqbxZ<zA6N^Us>O^,]LO\~n1e;~8RxTqf*=%_j.+wi^/R{}Et.GsEXu6gp:6[Mr?rvq1rO6#}5rg{3CWgvhg]Z~h7t.kg7G=&0%>+;&	>jc)bL]%B%IILhW=Y/p"&*ref[(fV,IY#h*+^^-OZZK5Fb+AZYR6Rq[$X
-\us%+r/9K7N&R _Bc`*gf\TTn`Vp %3[H+r{	yM;M.,/nE;{8=*d:4{+-r]4c"i=jlkq)jHZmUV\{,N>]HY9]W?iss({8y;}kn*EFlGI;7[KhP5lZFjv3gHr_r/^19rIkT0	oAt T 	oAq0r_!rfls|VJh.Jz'IUJ   $'p$psD/i[xKf/v}nVPr7R! .+B1.|D"tf]&w)"w? +"pC|6OQ?'E-5[4{UHB"TAg=f~dRJ#r!NUceC*{{|(BggRPU=UM0 c/G_oywrX,UP>^ :qV'AQ0Jj")!:3hAp#;7H   @_<=;5	CdqOU>3pQl~G0a0a]H>?X^q8)>^P;\5CP2+{:L$b%"{0< >E@           '3MK p^R=r wZ/i?_gJK.(I,pswN"6S@9GgC;T;3H7S}Z%CU        #^j2axNp-im Hz++_wWZ%DN{fB7nSvcD:3E.JQj.wdJ}~#R,K9T 9.m7lLyy307?Zi7lLyy307lL geu(M*	zDa/r+pOH?KLwRyD
-{?j)<e"w M8UD\E#EpiCJ\(.Hy\              4.LSQ	r;H"w7	)?,@?j\]C6lEr^	 dUO>UMy       ?dAN,LXR'\T2l5(~4^'\<3a,!x,r8B}I[fH#Kc-w6z-kCC5\-GAU1yG4F\6/^r:%;z2_l_"{`n6j?h`n6j?h`n6j?h`n   |J 
-a`",L7#F woF0<z,c@p#;	fN03wF w7`f j     D&,4    IENDB`
\ No newline at end of file
